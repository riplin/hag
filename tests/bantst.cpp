//Copyright 2025-Present riplin

#include <new>
#include <dos.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>

#include <vector>
#include <string>

#include <dpmi.h>
#include <sys/nearptr.h>
#include <support/allocatr.h>
#include <hag/testing/mock.h>
#include <hag/testing/testpat.h>

#include <hag/system/bda.h>
#include <hag/system/pci.h>
#include <hag/system/pit.h>
#include <hag/drivers/vga/vga.h>
#include <hag/vesa/vidmodes.h>

#include <hag/drivers/vga/modeset.h>

#include <hag/system/keyboard.h>
#include <hag/drivers/vga/vga.h>
#include <support/dump.h>

#include <hag/drivers/3dfx/shared/crtc/ext0.h>
#include <hag/drivers/3dfx/shared/crtc/ext1.h>
#include <hag/drivers/3dfx/shared/crtc/ext2.h>
#include <hag/drivers/3dfx/shared/crtc/ext3.h>
#include <hag/drivers/3dfx/shared/crtc/horext.h>
#include <hag/drivers/3dfx/shared/crtc/verext.h>

#include <hag/drivers/3dfx/shared/io/dacmode.h>
#include <hag/drivers/3dfx/shared/io/drminit0.h>
#include <hag/drivers/3dfx/shared/io/drminit1.h>
#include <hag/drivers/3dfx/shared/io/vgainit0.h>
#include <hag/drivers/3dfx/shared/io/vgainit1.h>
#include <hag/drivers/3dfx/shared/io/viddostr.h>
#include <hag/drivers/3dfx/shared/io/viddsa.h>
#include <hag/drivers/3dfx/shared/io/vidprcfg.h>
#include <hag/drivers/3dfx/shared/io/vidscrs.h>
#include <hag/drivers/3dfx/shared/io/pllctrl0.h>
#include <hag/drivers/3dfx/shared/io/pllctrl1.h>
#include <hag/drivers/3dfx/shared/io/pllctrl2.h>

#include <hag/drivers/3dfx/shared/pci/fbbaddr.h>
#include <hag/drivers/3dfx/shared/pci/iobaddr.h>

Hag::System::BDA::VideoParameterTable s_VideoParameters[] =
{
    {
        0x28,
        0x18,
        0x08,
        0x0800,
        { 0x09, 0x03, 0x00, 0x02 },
        0x63,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0xA0, 0xBF, 0x1F, 0x00, 0xC7, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x0800,
        { 0x09, 0x03, 0x00, 0x02 },
        0x63,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0xA0, 0xBF, 0x1F, 0x00, 0xC7, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x1000,
        { 0x01, 0x03, 0x00, 0x02 },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0xC7, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x1000,
        { 0x01, 0x03, 0x00, 0x02 },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0xC7, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x4000,
        { 0x09, 0x03, 0x00, 0x02 },
        0x63,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0x80, 0xBF, 0x1F, 0x00, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x00, 0x96, 0xB9, 0xA2, 0xFF },
        { 0x00, 0x13, 0x15, 0x17, 0x02, 0x04, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x03, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0F, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x4000,
        { 0x09, 0x03, 0x00, 0x02 },
        0x63,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0x80, 0xBF, 0x1F, 0x00, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x00, 0x96, 0xB9, 0xA2, 0xFF },
        { 0x00, 0x13, 0x15, 0x17, 0x02, 0x04, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x03, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0F, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x4000,
        { 0x01, 0x01, 0x00, 0x06 },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x00, 0x96, 0xB9, 0xC2, 0xFF },
        { 0x00, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x01, 0x00, 0x01, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x1000,
        { 0x00, 0x03, 0x00, 0x03 },
        0xA6,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x4D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x28, 0x0D, 0x63, 0xBA, 0xA3, 0xFF },
        { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x0F, 0x08 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0A, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x10,
        0xFFFF,
        { 0x01, 0x0F, 0x00, 0x0E },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x0E, 0x8F, 0x50, 0x1F, 0x96, 0xB9, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF }
    },
    {
        0x50,
        0x1D,
        0x10,
        0xFFFF,
        { 0x01, 0x0F, 0x00, 0x0E },
        0xE3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x52, 0x9E, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C, 0xDF, 0x50, 0x00, 0xE7, 0x04, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF }
    },
    {
        0x64,
        0x24,
        0x10,
        0xFA00,
        { 0x01, 0x0F, 0x00, 0x06 },
        0x2F,
        { 0x7F, 0x63, 0x64, 0x82, 0x6B, 0x1B, 0x72, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x0D, 0x57, 0x32, 0x00, 0x57, 0x73, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x64,
        0x24,
        0x10,
        0xFFFF,
        { 0x01, 0x0F, 0x00, 0x0E },
        0x2F,
        { 0x7F, 0x63, 0x64, 0x82, 0x69, 0x19, 0x72, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x0D, 0x57, 0x64, 0x00, 0x58, 0x73, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF }
    },
    {
        0xA0,
        0x3F,
        0x10,
        0xFFFF,
        { 0x01, 0x0F, 0x00, 0x0E },
        0x2F,
        { 0xCE, 0x9F, 0xA0, 0x91, 0xA6, 0x14, 0x28, 0x52, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0xFF, 0xA0, 0x00, 0x01, 0x28, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x2000,
        { 0x09, 0x0F, 0x00, 0x06 },
        0x63,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0x80, 0xBF, 0x1F, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x00, 0x96, 0xB9, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x4000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x00, 0x96, 0xB9, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x80,
        0x2F,
        0x10,
        0xFFFF,
        { 0x01, 0x0F, 0x00, 0x0E },
        0x2F,
        { 0xA3, 0x7F, 0x80, 0x87, 0x83, 0x94, 0x24, 0xF5, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x09, 0xFF, 0x80, 0x00, 0xFF, 0x25, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF }
    },
    {
        0x50,
        0x3B,
        0x08,
        0x2600,
        { 0x01, 0x03, 0x00, 0x02 },
        0xE3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0x0B, 0x3E, 0x00, 0x47, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C, 0xDF, 0x28, 0x1F, 0xE7, 0x04, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x8000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0xA2,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x28, 0x0F, 0x63, 0xBA, 0xE3, 0xFF },
        { 0x00, 0x08, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x0B, 0x00, 0x05, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x8000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0xA3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x28, 0x0F, 0x63, 0xBA, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x28,
        0x18,
        0x0E,
        0x0800,
        { 0x09, 0x03, 0x00, 0x02 },
        0xA3,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0xA0, 0xBF, 0x1F, 0x00, 0x4D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x14, 0x1F, 0x63, 0xBA, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x0E,
        0x0800,
        { 0x09, 0x03, 0x00, 0x02 },
        0xA3,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0xA0, 0xBF, 0x1F, 0x00, 0x4D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x14, 0x1F, 0x63, 0xBA, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x1000,
        { 0x01, 0x03, 0x00, 0x02 },
        0xA3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x4D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x28, 0x1F, 0x63, 0xBA, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x1000,
        { 0x01, 0x03, 0x00, 0x02 },
        0xA3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x4D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x28, 0x1F, 0x63, 0xBA, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x10,
        0x0800,
        { 0x08, 0x03, 0x00, 0x02 },
        0x67,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0xA0, 0xBF, 0x1F, 0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x08 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x10,
        0x1000,
        { 0x00, 0x03, 0x00, 0x02 },
        0x67,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x08 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x10,
        0x1000,
        { 0x00, 0x03, 0x00, 0x02 },
        0x66,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x0F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x0F, 0x08 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0A, 0x00, 0xFF }
    },
    {
        0x50,
        0x1D,
        0x10,
        0xA000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0xE3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C, 0xDF, 0x28, 0x00, 0xE7, 0x04, 0xC3, 0xFF },
        { 0x00, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x01, 0x00, 0x01, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01, 0xFF }
    },
    {
        0x50,
        0x1D,
        0x10,
        0xA000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0xE3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C, 0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x2000,
        { 0x01, 0x0F, 0x00, 0x0E },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x40, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF }
    },
    {
        0x84,
        0x18,
        0x10,
        0x2000,
        { 0x01, 0x03, 0x00, 0x02 },
        0x6F,
        { 0x9A, 0x83, 0x84, 0x9D, 0x85, 0x13, 0xBF, 0x1F, 0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x42, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x84,
        0x2A,
        0x09,
        0x4000,
        { 0x01, 0x03, 0x00, 0x02 },
        0x6F,
        { 0x9A, 0x83, 0x84, 0x9D, 0x85, 0x13, 0xBF, 0x1F, 0x00, 0x48, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x92, 0x84, 0x82, 0x42, 0x1F, 0x89, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x84,
        0x31,
        0x08,
        0x4000,
        { 0x01, 0x03, 0x00, 0x02 },
        0x6F,
        { 0x9E, 0x83, 0x84, 0x81, 0x8A, 0x9E, 0xBF, 0x1F, 0x00, 0x47, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x42, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x84,
        0x3B,
        0x08,
        0x4000,
        { 0x01, 0x03, 0x00, 0x02 },
        0xEF,
        { 0x9E, 0x83, 0x84, 0x81, 0x8A, 0x9E, 0x0B, 0x3E, 0x00, 0x47, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C, 0xDF, 0x42, 0x1F, 0xE7, 0x04, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0xFFFF,
        { 0x01, 0x0F, 0x00, 0x0E },
        0x6F,
        { 0x2D, 0x27, 0x28, 0x90, 0x29, 0x8F, 0xBF, 0x1F, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF }
    },
    {
        0x28,
        0x1D,
        0x08,
        0xFFFF,
        { 0x01, 0x0F, 0x00, 0x0E },
        0xEF,
        { 0x2D, 0x27, 0x28, 0x90, 0x29, 0x8F, 0x0B, 0x3E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C, 0xDF, 0x28, 0x1F, 0xE7, 0x04, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF }
    },
    {
        0x32,
        0x24,
        0x08,
        0xFFFF,
        { 0x01, 0x0F, 0x00, 0x0E },
        0x2F,
        { 0x3D, 0x31, 0x32, 0x80, 0x35, 0x1D, 0x72, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x0D, 0x57, 0x64, 0x00, 0x58, 0x73, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF }
    },
    {
        0x40,
        0x1C,
        0x0E,
        0xFFFF,
        { 0x01, 0x0F, 0x00, 0x0E },
        0x2F,
        { 0x4F, 0x3F, 0x40, 0x83, 0x42, 0x0C, 0x24, 0xF5, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x09, 0xFF, 0x80, 0x00, 0xFF, 0x25, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF }
    }
};

struct ModeData
{
    Hag::VGA::VideoMode_t LegacyMode;//0x00 
    uint8_t OtherTableIndex;//0x01 Also used as index into the video param table if unknown3 is 0
    Hag::Vesa::VideoMode_t VesaMode;//0x02
    uint8_t Flags;//0x04 Also index for palette setting. Instead of flags, perhaps type?
    uint8_t Unknown1;//0x05
    uint8_t BitsPerPixel;//0x06
    uint16_t Width;//0x07 In pixels or chars
    uint16_t Height;//0x09 In pixels or chars
    uint16_t Stride;//0x0b Bytes per scan line
    uint8_t CharacterHeight;//0x0d
};

ModeData s_ModeData[] =
{
    //                           +----
    //                           | 0 =  0xb800, 32KB
    //                           | 1 =  0xb000, 32KB
    //                           | 2 =  0xb800, 32KB
    //                           | else 0xa000, 64KB
    //                           |
    //                           |
    //       Table               |        Bits    Width in    Height in
    //Legacy   0                 |         per     pixels      pixels     Bytes per  char
    // Mode  index VESA Mode     |        pixel   or chars    or chars    scan line height
    { 0x00,  0x17,  0x0000,    0x00, 0x08, 0x04,   0x0028,      0x0019,     0x0050,  0x10 },
    { 0x01,  0x17,  0x0001,    0x00, 0x08, 0x04,   0x0028,      0x0019,     0x0050,  0x10 },
    { 0x02,  0x18,  0x0002,    0x00, 0x08, 0x04,   0x0050,      0x0019,     0x00A0,  0x10 },
    { 0x03,  0x18,  0x0003,    0x00, 0x08, 0x04,   0x0050,      0x0019,     0x00A0,  0x10 },
    { 0x04,  0x04,  0x0004,    0x02, 0x01, 0x02,   0x0140,      0x00C8,     0x0050,  0x08 },
    { 0x05,  0x05,  0x0005,    0x02, 0x01, 0x02,   0x0140,      0x00C8,     0x0050,  0x08 },
    { 0x06,  0x06,  0x0006,    0x02, 0x01, 0x01,   0x0280,      0x00C8,     0x0050,  0x08 },
    { 0x07,  0x19,  0x0007,    0x01, 0x08, 0x00,   0x0050,      0x0019,     0x00A0,  0x10 },
    { 0x0D,  0x0D,  0x000D,    0x05, 0x08, 0x04,   0x0140,      0x00C8,     0x0028,  0x08 },
    { 0x0E,  0x0E,  0x000E,    0x05, 0x04, 0x04,   0x0280,      0x00C8,     0x0050,  0x08 },
    { 0x0F,  0x11,  0x000F,    0x03, 0x02, 0x01,   0x0280,      0x015E,     0x0050,  0x0E },
    { 0x10,  0x12,  0x0010,    0x05, 0x02, 0x04,   0x0280,      0x015E,     0x0050,  0x0E },
    { 0x11,  0x1A,  0x0011,    0x04, 0x01, 0x01,   0x0280,      0x01E0,     0x0050,  0x10 },
    { 0x12,  0x1B,  0x0012,    0x05, 0x01, 0x04,   0x0280,      0x01E0,     0x0050,  0x10 },
    { 0x13,  0x1C,  0x0013,    0x06, 0x01, 0x08,   0x0140,      0x00C8,     0x0140,  0x08 },
    { 0x5B,  0x08,  0x0100,    0x06, 0x01, 0x08,   0x0280,      0x0190,     0x0280,  0x10 },
    { 0x5F,  0x09,  0x0101,    0x06, 0x01, 0x08,   0x0280,      0x01E0,     0x0280,  0x10 },
    { 0x6A,  0x0A,  0x0102,    0x05, 0x01, 0x04,   0x0320,      0x0258,     0x0064,  0x10 },
    { 0x5C,  0x0B,  0x0103,    0x06, 0x01, 0x08,   0x0320,      0x0258,     0x0320,  0x10 },
    { 0x5E,  0x0F,  0x0105,    0x06, 0x01, 0x08,   0x0400,      0x0300,     0x0400,  0x10 },
    { 0x6B,  0x0C,  0x0107,    0x06, 0x01, 0x08,   0x0500,      0x0400,     0x0500,  0x10 },
    { 0x68,  0x10,  0x0108,    0x00, 0x06, 0x04,   0x0050,      0x003C,     0x00A0,  0x08 },
    { 0x55,  0x1D,  0x0109,    0x00, 0x02, 0x04,   0x0084,      0x0019,     0x0108,  0x10 },
    { 0x54,  0x1E,  0x010A,    0x00, 0x02, 0x04,   0x0084,      0x002B,     0x0108,  0x08 },
    { 0x65,  0x1F,  0x010B,    0x00, 0x02, 0x04,   0x0084,      0x0032,     0x0108,  0x08 },
    { 0x64,  0x20,  0x010C,    0x00, 0x02, 0x04,   0x0084,      0x003C,     0x0108,  0x08 },
    { 0x78,  0x21,  0x0180,    0x06, 0x01, 0x08,   0x0140,      0x00C8,     0x0140,  0x08 },
    { 0x20,  0x22,  0x0181,    0x06, 0x01, 0x08,   0x0140,      0x00F0,     0x0140,  0x08 },
    { 0x23,  0x23,  0x0184,    0x06, 0x01, 0x08,   0x0190,      0x012C,     0x0190,  0x08 },
    { 0x26,  0x24,  0x0187,    0x06, 0x01, 0x08,   0x0200,      0x0180,     0x0200,  0x08 },
    { 0x79,  0x25,  0x010E,    0x07, 0x01, 0x10,   0x0140,      0x00C8,     0x0280,  0x08 },
    { 0x7A,  0x26,  0x010F,    0x08, 0x01, 0x18,   0x0140,      0x00C8,     0x0400,  0x08 },
    { 0x21,  0x27,  0x0182,    0x07, 0x01, 0x10,   0x0140,      0x00F0,     0x0280,  0x08 },
    { 0x22,  0x28,  0x0183,    0x08, 0x01, 0x18,   0x0140,      0x00F0,     0x0400,  0x08 },
    { 0x24,  0x29,  0x0185,    0x07, 0x01, 0x10,   0x0190,      0x012C,     0x0320,  0x08 },
    { 0x25,  0x2A,  0x0186,    0x08, 0x01, 0x18,   0x0190,      0x012C,     0x0800,  0x08 },
    { 0x27,  0x2B,  0x0188,    0x07, 0x01, 0x10,   0x0200,      0x0180,     0x0400,  0x0E },
    { 0x28,  0x2C,  0x0189,    0x08, 0x01, 0x18,   0x0200,      0x0180,     0x0800,  0x0E },
    { 0x29,  0x2D,  0x018A,    0x07, 0x01, 0x10,   0x0280,      0x0190,     0x0500,  0x10 },
    { 0x2A,  0x2E,  0x018B,    0x08, 0x01, 0x18,   0x0280,      0x0190,     0x0800,  0x10 },
    { 0x6E,  0x2F,  0x0111,    0x07, 0x01, 0x10,   0x0280,      0x01E0,     0x0500,  0x10 },
    { 0x69,  0x30,  0x0112,    0x08, 0x01, 0x18,   0x0280,      0x01E0,     0x0800,  0x10 },
    { 0x70,  0x31,  0x0114,    0x07, 0x01, 0x10,   0x0320,      0x0258,     0x0640,  0x10 },
    { 0x71,  0x32,  0x0115,    0x08, 0x01, 0x18,   0x0320,      0x0258,     0x1000,  0x10 },
    { 0x72,  0x33,  0x0117,    0x07, 0x01, 0x10,   0x0400,      0x0300,     0x0800,  0x10 },
    { 0x73,  0x34,  0x0118,    0x08, 0x01, 0x18,   0x0400,      0x0300,     0x1000,  0x10 },
    { 0x74,  0x35,  0x011A,    0x07, 0x01, 0x10,   0x0500,      0x0400,     0x0A00,  0x10 },
    { 0x75,  0x36,  0x011B,    0x08, 0x01, 0x18,   0x0500,      0x0400,     0x1000,  0x10 }
};

// inputs:
//    al = mode

// outputs:
//    carry = 0 = found, 1 = not found
//    es:bx = pointer to mode data

bool FindModeData(Hag::VGA::VideoMode_t mode, ModeData*& modeData)//Offset 0x40d9
{
    modeData = nullptr;

    //     call   FetchCustomDataPointer       ;Offset 0x40f6
    //     les    bx, es:[bx + 04h]
    // Find:                                   ;Offset 0x40e0
    //     cmp    byte ptr es:[bx], 0ffh
    //     je     NotFound                     ;Offset 0x40f2
    //     cmp    byte ptr es:[bx], al
    //     je     Found                        ;Offset 0x40f0
    //     add    bx, 000eh
    //     jmp    Find                         ;Offset 0x40e0
    // Found:                                  ;Offset 0x40f0
    //     clc
    //     ret
    for (uint32_t i = 0; i < sizeof(s_ModeData) / sizeof(ModeData); ++i)
    {
        if (mode == s_ModeData[i].LegacyMode)
        {
            modeData = &s_ModeData[i];
            return true;
        }
    }

    // NotFound:                               ;Offset 0x40f2
    //     sub    bx, bx
    //     stc
    //     ret
    return false;
}

struct ExtraModeData
{
    uint8_t Unknown0;//Flags?
    uint8_t VerticalExtension;//Vertical Extension Register Byte 1
    uint8_t Unknown2;
    uint8_t Unknown3;//VideoParameterTable index
    Hag::TDfx::Shared::PLLControl0_t PLLControl0;//PLL Control 0
};

ExtraModeData s_ExtraModeData[] =
{
    { 0x00, 0x00, 0x04, 0x00, 0x0000 }, // 0x00
    { 0x00, 0x00, 0x04, 0x00, 0x0000 }, // 0x01
    { 0x00, 0x00, 0x01, 0x00, 0x0000 }, // 0x02
    { 0x00, 0x00, 0x01, 0x00, 0x0000 }, // 0x03
    { 0x00, 0x00, 0x04, 0x00, 0x0000 }, // 0x04-
    { 0x00, 0x00, 0x04, 0x00, 0x0000 }, // 0x05-
    { 0x00, 0x00, 0x01, 0x00, 0x0000 }, // 0x06-
    { 0x00, 0x00, 0x00, 0x00, 0x0000 }, // 0x07
    { 0x01, 0x00, 0x01, 0x00, 0x0000 }, // 0x08
    { 0x01, 0x00, 0x02, 0x00, 0x0000 }, // 0x09
    { 0x00, 0x00, 0x03, 0x00, 0xBC3E }, // 0x0a
    { 0x01, 0x00, 0x03, 0x00, 0xBC3E }, // 0x0b
    { 0x01, 0x51, 0xFF, 0x00, 0xB358 }, // 0x0c
    { 0x00, 0x00, 0x04, 0x00, 0x0000 }, // 0x0d-
    { 0x00, 0x00, 0x01, 0x00, 0x0000 }, // 0x0e-
    { 0x01, 0x00, 0xFF, 0x00, 0xE15D }, // 0x0f
    { 0x00, 0x00, 0x02, 0x00, 0x0000 }, // 0x10
    { 0x00, 0x00, 0x00, 0x00, 0x0000 }, // 0x11-
    { 0x00, 0x00, 0x00, 0x00, 0x0000 }, // 0x12-
    { 0x00, 0x00, 0x04, 0x00, 0x0000 }, // 0x13
    { 0x00, 0x00, 0x04, 0x00, 0x0000 }, // 0x14
    { 0x00, 0x00, 0x01, 0x00, 0x0000 }, // 0x15
    { 0x00, 0x00, 0x01, 0x00, 0x0000 }, // 0x16
    { 0x00, 0x00, 0x04, 0x00, 0x0000 }, // 0x17-
    { 0x00, 0x00, 0x01, 0x00, 0x0000 }, // 0x18-
    { 0x00, 0x00, 0x01, 0x00, 0x0000 }, // 0x19-
    { 0x00, 0x00, 0x02, 0x00, 0x0000 }, // 0x1a-
    { 0x00, 0x00, 0x02, 0x00, 0x0000 }, // 0x1b-
    { 0x00, 0x00, 0x01, 0x00, 0x0000 }, // 0x1c-
    { 0x00, 0x00, 0xFF, 0x00, 0xAEF4 }, // 0x1d
    { 0x00, 0x00, 0xFF, 0x00, 0xAEF4 }, // 0x1e
    { 0x00, 0x00, 0xFF, 0x00, 0xAEF4 }, // 0x1f
    { 0x00, 0x00, 0xFF, 0x00, 0xAEF4 }, // 0x20
    { 0x05, 0x00, 0x01, 0x00, 0xD1EA }, // 0x21
    { 0x05, 0x00, 0x02, 0x00, 0xD1EA }, // 0x22
    { 0x05, 0x00, 0x03, 0x00, 0x56F4 }, // 0x23
    { 0x05, 0x00, 0xFF, 0x00, 0x8DF4 }, // 0x24
    { 0x0D, 0x00, 0x01, 0x21, 0xD1EA }, // 0x25
    { 0x15, 0x00, 0x01, 0x21, 0xD1EA }, // 0x26
    { 0x0D, 0x00, 0x02, 0x22, 0xD1EA }, // 0x27
    { 0x15, 0x00, 0x02, 0x22, 0xD1EA }, // 0x28
    { 0x0D, 0x00, 0x03, 0x23, 0x56F4 }, // 0x29
    { 0x15, 0x00, 0x03, 0x23, 0x56F4 }, // 0x2a
    { 0x0D, 0x00, 0xFF, 0x24, 0x8DF4 }, // 0x2b
    { 0x15, 0x00, 0xFF, 0x24, 0x8DF4 }, // 0x2c
    { 0x09, 0x00, 0x01, 0x08, 0x0000 }, // 0x2d
    { 0x11, 0x00, 0x01, 0x08, 0x0000 }, // 0x2e
    { 0x09, 0x00, 0x02, 0x09, 0x0000 }, // 0x2f
    { 0x11, 0x00, 0x02, 0x09, 0x0000 }, // 0x30
    { 0x09, 0x00, 0x03, 0x0B, 0xBC3E }, // 0x31
    { 0x11, 0x00, 0x03, 0x0B, 0xBC3E }, // 0x32
    { 0x09, 0x00, 0xFF, 0x0F, 0xE15D }, // 0x33
    { 0x11, 0x00, 0xFF, 0x0F, 0xE15D }, // 0x34
    { 0x09, 0x51, 0xFF, 0x0C, 0xB358 }, // 0x35
    { 0x11, 0x51, 0xFF, 0x0C, 0xB358 }  // 0x36
};

ExtraModeData* GetExtraModeData(ModeData& modeData)//Offset 0x3f29
{
    return &s_ExtraModeData[modeData.OtherTableIndex];
    // push   ax
    // push   cx
    // movzx  ax, byte ptr es:[bx + 01h]
    // mov    cl, 06h
    // mul    cl
    // call   FetchCustomDataPointer       ;Offset 0x40f6
    // les    si, es:[bx]
    // add    si, ax
    // pop    cx
    // pop    ax
    // ret
}

void ResetAttributeIndex()//Offset 0x4135
{
    using namespace Hag::System;
    // push  ax
    // push  dx

    // mov   dx, VGA_InputStatus1D         ;Port 0x3da
    // in    al, dx
    Hag::VGA::InputStatus1::Read(BDA::VideoBaseIOPort::Get() + 0x06);

    // mov   dl, VGA_InputStatus1B_lowbyte ;Port 0x3ba
    // in    al, dx
    //Hag::VGA::InputStatus1::Read(Hag::VGA::Register::InputStatus1B);

    // pop   dx
    // pop   ax
    // ret
}

void DisableAttributeControllerPaletteOutput()//Offset 0x407d
{
    // push   ax
    // push   dx

    // cli
    SYS_ClearInterrupts();

    // call   ResetAttributeIndex          ;Offset 0x4135
    ResetAttributeIndex();

    // mov    dx, VGA_AttributeControllerIndex;Port 0x3c0
    // sub    al, al
    // out    dx, al
    Hag::VGA::AttributeControllerIndex::Write(0);
    
    // sti
    SYS_RestoreInterrupts();

    // pop    dx
    // pop    ax
    // ret
}

void EnableAttributeControllerPaletteOutput()//Offset 0x408d
{
    // push   ax
    // push   dx

    // cli
    SYS_ClearInterrupts();

    // call   ResetAttributeIndex          ;Offset 0x4135
    ResetAttributeIndex();

    // mov    dx, VGA_AttributeControllerIndex;Port 0x3c0
    // mov    al, VGA_ATTR_PaletteAddressSource;0x20
    // out    dx, al
    Hag::VGA::AttributeControllerIndex::Write(Hag::VGA::AttributeControllerIndex::EnableVideoDisplay);

    // call   ResetAttributeIndex          ;Offset 0x4135
    ResetAttributeIndex();

    // sti
    SYS_RestoreInterrupts();

    // pop    dx
    // pop    ax
    // ret
}

void ApplyModeSettingsToBDA(Hag::System::BDA::VideoParameterTable& parameters)//Offset 0x3d6
{
    using namespace Hag;
    using namespace Hag::System;

    static uint8_t CRTControlRegValues[]=
    {
        0x2C,
        0x28,
        0x2D,
        0x29,
        0x2A,
        0x2E,
        0x1E,
        0x29
    };

    //     push      di
    //     push      es
    //     mov       cx, 0009h
    //     mov       di, BDA_VideoBufferOffset ;Offset 0x44e
    //     call      GetBIOSDataSelectorInES   ;Offset 0x3f46
    //     sub       ax, ax
    //     rep stosw
    BDA::VideoBufferOffset::Get() = 0;
    BDA::CursorPositions::Clear();

    //     pop       es
    //     pop       di
    //     mov       byte ptr ds:[BDA_ActiveDisplayNumber], al;Offset 0x462
    BDA::ActiveDisplayNumber::Get() = 0;

    //     mov       bl, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    //     mov       bh, ah

    //     cmp       bl, BDA_DM_80x25_Monochrome_Text;0x7
    //     ja        Label0x40c                ;Offset 0x40c
    if (BDA::DisplayMode::Get() <= VGA::VideoMode::T80x25x1bppM)
    {
        //     mov       al, byte ptr cs:[bx + CRTControlRegValues];Offset 0x3ce
        //     mov       byte ptr ds:[BDA_CRTModeControlRegValue], al;Offset 0x465
        BDA::CRTModeControlRegValue::Get() = CRTControlRegValues[BDA::DisplayMode::Get()];

        //     mov       byte ptr ds:[BDA_CGAColorPaletteMaskSetting], 3fh;Offset 0x466 0x3f
        BDA::CGAColorPaletteMaskSetting::Get() = 0x3f;

        //     cmp       bl, BDA_DM_640x200_BW_Graphics;0x6
        //     je        Label0x40c                ;Offset 0x40c
        //     mov       byte ptr ds:[BDA_CGAColorPaletteMaskSetting], 30h;Offset 0x466 0x30
        if (BDA::DisplayMode::Get() != VGA::VideoMode::G640x200x1bppM)
            BDA::CGAColorPaletteMaskSetting::Get() = 0x30;

        // Label0x40c:                             ;Offset 0x40c
    }
    else
    {
        BDA::CRTModeControlRegValue::Get() = 0;
        BDA::CGAColorPaletteMaskSetting::Get() = 0;
    }
    //     mov       al, byte ptr es:[di]
    //     mov       word ptr ds:[BDA_NumberOfScreenColumns], ax;Offset 0x44a
    BDA::NumberOfScreenColumns::Get() = parameters.NumCharacterColumns;

    //     mov       al, byte ptr es:[di + 02h]
    //     mov       word ptr ds:[BDA_PointHeightOfCharacterMatrix], ax;Offset 0x485
    BDA::PointHeightOfCharacterMatrix::Get() = parameters.CharacterMatrixHeightInPoints;

    //     mov       al, byte ptr es:[di + 01h]
    //     mov       byte ptr ds:[BDA_RowsOnScreen], al;Offset 0x484
    BDA::RowsOnScreen::Get() = parameters.NumScreenRowsMinus1;

    //     mov       ax, word ptr es:[di + 03h]
    //     mov       word ptr ds:[BDA_VideoBufferSize], ax;Offset 0x44c
    BDA::VideoBufferSize::Get() = parameters.VideoBufferSize;

    //     mov       ax, word ptr es:[di + 14h]
    //     xchg      al, ah
    //     mov       word ptr ds:[BDA_CursorEndStartScanLine], ax;Offset 0x460
    BDA::CursorScanLines::Get().End = parameters.CRTCRegisters[VGA::CRTController::Register::CursorEndScanLine];
    BDA::CursorScanLines::Get().Start = parameters.CRTCRegisters[VGA::CRTController::Register::CursorStartScanLine];

    //     ret
}

uint8_t GetVideoParameterTableIndex(Hag::VGA::VideoMode_t mode)//Offset 0x35d4
{
    using namespace Hag;
    using namespace Hag::System;

    ModeData* modeData = nullptr;

    REGS r;
    memset(&r, 0, sizeof(r));

    r.h.al = mode;

    //     push      bx
    //     push      es
    //     cmp       al, 07h
    //     ja        Label0x3605               ;Offset 0x3605
    if (r.h.al > VGA::VideoMode::T80x25x1bppM)
        goto Label0x3605;
    
    //     je        Label0x35fa               ;Offset 0x35fa
    if (r.h.al == VGA::VideoMode::T80x25x1bppM)
        goto Label0x35fa;

    //     cmp       al, 03h
    //     ja        Label0x360e               ;Offset 0x360e
    if (r.h.al > VGA::VideoMode::T80x25x4bppC)
        goto Label0x360e;
    
    //     test      byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_LineMode200;Offset 0x80
    //     jne       Label0x360e               ;Offset 0x360e
    if ((BDA::VideoDisplayDataArea::Get() & BDA::VideoDisplayDataArea::LineMode200) != 0)
        goto Label0x360e;

    //     mov       bl, al
    r.h.bl = r.h.al;

    //     add       al, 13h
    r.h.al += 0x13;

    //     test      byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_LineMode400;Offset 0x489 0x10
    //     je        Label0x360e               ;Offset 0x360e
    if ((BDA::VideoDisplayDataArea::Get() & BDA::VideoDisplayDataArea::LineMode400) == 0)
        goto Label0x360e;
    
    //     mov       al, bl
    r.h.al = r.h.bl;

    //     shr       al, 01h
    r.h.al >>= 1;

    //     add       al, 17h
    r.h.al += 0x17;

    //     jmp       Label0x360e               ;Offset 0x360e
    goto Label0x360e;

    // Label0x35fa:                            ;Offset 0x35fa
    Label0x35fa:

    //     test      byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_LineMode400;Offset 0x489 0x10
    //     je        Label0x360e               ;Offset 0x360e
    if ((BDA::VideoDisplayDataArea::Get() & BDA::VideoDisplayDataArea::LineMode400) == 0)
        goto Label0x360e;

    //     mov       al, 19h
    r.h.al = 0x19;

    //     jmp       Label0x360e               ;Offset 0x360e
    goto Label0x360e;

    // Label0x3605:                            ;Offset 0x3605
    Label0x3605:

    //     call      FindModeData              ;Offset 0x40d9
    //     jb        Label0x3611               ;Offset 0x3611
    if (!FindModeData(r.h.al, modeData))
        goto Label0x3611;

    //     mov       al, byte ptr es:[bx + 01h]
    r.h.al = modeData->OtherTableIndex;

    // Label0x360e:                            ;Offset 0x360e
    Label0x360e:
    //     pop       es
    //     pop       bx
    //     ret
    return r.h.al;

    // Label0x3611:                            ;Offset 0x3611
    Label0x3611:

    //     sub       al, al
    r.h.al = 0;

    //     jmp       Label0x360e               ;Offset 0x360e
    goto Label0x360e;
}

Hag::System::BDA::VideoParameterTable& GetVideoParameterTable()//Offset 0x35a7
{
    using namespace Hag;
    using namespace Hag::System;

    ModeData* modeData = nullptr;
    ExtraModeData* extraModeData = nullptr;

    //     push      bx
    //     push      si

    //     mov       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    VGA::VideoMode_t mode = BDA::DisplayMode::Get();

    //     cmp       al, BDA_DM_320x200_256_Color_Graphics;0x13
    //     jbe       Label0x35c1               ;Offset 0x35c1
    if (mode <= VGA::VideoMode::G320x200x8bppC)
        goto Label0x35c1;

    //     call      FindModeData              ;Offset 0x40d9
    FindModeData(mode, modeData);

    //     call      Func0x3f29                ;Offset 0x3f29
    extraModeData = GetExtraModeData(*modeData);

    //     mov       al, byte ptr es:[si + 03h]
    mode = extraModeData->Unknown3;

    //     test      al, al
    //     jne       Label0x35c4               ;Offset 0x35c4
    if (mode != 0)
        goto Label0x35c4;

    //     mov       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
        mode = BDA::DisplayMode::Get();

    // Label0x35c1:                            ;Offset 0x35c1
    Label0x35c1:

    //     call      GetVideoParameterTableIndex                ;Offset 0x35d4
    mode = GetVideoParameterTableIndex(mode);

    // Label0x35c4:                            ;Offset 0x35c4
    Label0x35c4:

    //     les       di, ds:[BDA_VideoParameterControlBlockPointer];Offset 0x4a8
    //     les       di, es:[di]               ;BDA_VPCB_VideoParameterTable
    //     cbw
    //     shl       ax, 06h
    //     add       di, ax
    return s_VideoParameters[mode];

    //     pop       si
    //     pop       bx
    //     ret
}

void TurnScreenOff()//Offset 0x3f6a
{
    // mov    dx, VGA_SequenceIndex        ;Port 0x3c4
    // mov    al, VGA_SEQIdx_ClockingMode  ;0x1
    // call   ReadIndexedRegister          ;Offset 0x3f84
    // or     ah, VGA_SEQ1_ScreenOff       ;0x20
    // out    dx, ax
    Hag::VGA::Sequencer::ClockingMode::Write(
        Hag::VGA::Sequencer::ClockingMode::Read() |
        Hag::VGA::Sequencer::ClockingMode::ScreenOff);

    // ret
}

void TurnScreenOn()//Offset 0x3f77
{
    // mov    dx, VGA_SequenceIndex        ;Port 0x3c4
    // mov    al, VGA_SEQIdx_ClockingMode  ;0x1
    // call   ReadIndexedRegister          ;Offset 0x3f84
    // and    ah, NOT VGA_SEQ1_ScreenOff   ;0xdf
    // out    dx, ax
    Hag::VGA::Sequencer::ClockingMode::Write(
        Hag::VGA::Sequencer::ClockingMode::Read() &
        ~Hag::VGA::Sequencer::ClockingMode::ScreenOff);

    // ret
}

// outputs:
//    dx = IO Base Address

uint16_t GetIOBaseAddress()//Offset 0x3d69
{
    // push   ax
    // call   GetCRTControllerIndexPort    ;Offset 0x40aa
    // mov    al, 1ch
    // call   ReadIndexedRegister          ;Offset 0x3f84
    // mov    dh, ah
    // sub    dl, dl
    // pop    ax
    // ret
    //TODO: fix
    Hag::System::PCI::Device_t device = 0;
    Hag::System::PCI::FindDevice(0x121a, 0x0003, device);
    return Hag::TDfx::Shared::PCI::IOBaseAddress::GetBaseAddress(device);
}

void EnableVGAExtensions() //Offset 0x3852
{
    using namespace Hag::TDfx::Shared;

    // push      ax
    // push      dx
    // call      GetIOBaseAddress          ;Offset 0x3d69
    uint16_t baseAddress = GetIOBaseAddress();

    // add       dx, TDFX_IO_VGAInit0      ;0x28
    // in        eax, dx
    // or        al, TDFX_VI0_EnableVGAExtensions;0x40
    // out       dx, eax
    IO::VGAInit0::Write(baseAddress, IO::VGAInit0::Read(baseAddress) | VGAInit0::ExtensionsEnabled);
    // pop       dx
    // pop       ax
    // ret
}

void SetVGAReadWriteAperture64K(uint16_t offset)//Offset 0x3c10
{
    using namespace Hag::TDfx::Shared;
    offset <<= 1;
    // push   eax
    // push   ebx
    // push   dx
    // sub    ebx, ebx
    // mov    bl, dl
    // shl    bx, 01h
    // call   GetIOBaseAddress             ;Offset 0x3d69
    uint16_t baseAddress = GetIOBaseAddress();

    // add    dx, TDFX_IO_VGAInit1         ;0x2c
    // in     eax, dx
    // and    eax, 0fff00000h
    // mov    ax, bx
    // shl    ebx, 0ah
    // or     eax, ebx
    // out    dx, eax
    IO::VGAInit1::Write(baseAddress,
        (IO::VGAInit1::Read(baseAddress) & ~(VGAInit1::VBEReadAperture32K | VGAInit1::VBEWriteAperture32K)) |
        offset | (offset << VGAInit1::Shift::VBEReadAperture32K));

    // pop    dx
    // pop    ebx
    // pop    eax
    // ret
}

void SetupExtensionsAndMemoryConfig()//Offset 0x3615
{
    using namespace Hag;
    using namespace Hag::TDfx::Shared;

    // push      eax
    // push      dx
    // call      EnableVGAExtensions       ;Offset 0x3852
    EnableVGAExtensions();

    // call      GetIOBaseAddress          ;Offset 0x3d69
    uint16_t baseAddress = GetIOBaseAddress();

    // add       dx, TDFX_IO_VGAInit0      ;0x28
    // in        eax, dx
    // and       eax, TDFX_VI0_WakeUpSelect;0x100
    // or        al, TDFX_VI0_EnableVGAExtensions;0x40
    // out       dx, eax
    IO::VGAInit0::Write(baseAddress, (IO::VGAInit0::Read(baseAddress) & VGAInit0::WakeUpSelect) | VGAInit0::ExtensionsEnabled);
    
    // sub       dx, dx
    // call      SetVGAReadWriteAperture64K;Offset 0x3c10
    SetVGAReadWriteAperture64K(0);

    // mov       dx, VGA_MiscellaneousWrite;Port 0x3c2
    // mov       al, 67h                   ;IO address select, Enable RAM, Clock 28.322 MHz, High page ram, negative hsync, positive vsync
    // out       dx, al
    VGA::MiscellaneousOutput::Write(
        VGA::MiscellaneousOutput::IOAddressSelect |
        VGA::MiscellaneousOutput::EnableCPUDisplayMemoryAccess |
        VGA::MiscellaneousOutput::ClockSelect28p322MHz |
        VGA::MiscellaneousOutput::PageSelect |
        VGA::MiscellaneousOutput::SelectNegativeHorizontalSyncPulse);

    // pop       dx
    // pop       eax
    // ret
}

uint16_t GetMemorySizeIn256KBlocks()//Offset 0x37fc
{
    using namespace Hag::TDfx::Shared;
    static uint8_t MemorySizes[] ={ 0x10, 0x20, 0x20, 0x40 };

    // push      bx
    // push      dx
    // call      GetIOBaseAddress          ;Offset 0x3d69
    uint16_t baseAddress = GetIOBaseAddress();

    // add       dx, TDFX_IO_DRamInit0     ;0x18
    // in        eax, dx
    // shr       eax, 1ah                  ;26
    // and       ax, 0003h                 ;26-27 : number of chipsets, size of chips
    uint32_t index = (IO::DRAMInit0::Read(baseAddress) & (DRAMInit0::SGRAMChipSetCount | DRAMInit0::SGRAMChipSize)) >> DRAMInit0::Shift::SGRAMChipSetCount;

    // mov       bx, ax
    // mov       al, byte ptr cs:[bx + Data0x37f8];Offset 0x37f8
    // pop       dx
    // pop       bx
    // ret
    return MemorySizes[index];
}

void ClearScreen()//Offset 0x3740
{
    using namespace Hag;
    using namespace Hag::System;

    //     pushaw
    //     push      eax
    //     push      es
    //     mov       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    //     call      FindModeData              ;Offset 0x40d9
    //     jb        Label0x37b0               ;Offset 0x37b0

    ModeData* modeData = nullptr;
    if (FindModeData(BDA::DisplayMode::Get(), modeData))
    {
        uint16_t pageCount = 1;
        uint16_t pageIndex = 0;
        uint16_t memorySize = GetMemorySizeIn256KBlocks();

        //     sub       di, di
        //     mov       ax, 0720h
        uint16_t clearValue = 0x720;

        //     mov       cx, 4000h
        uint16_t clearCount = 0x4000;
        
        //     mov       dx, word ptr cs:[B800Selector];Offset 0x77e4
        uint16_t clearSegment = 0xb800;

        //     mov       bl, byte ptr es:[bx + 04h]
        //     cmp       bl, 00h
        //     je        Label0x3778               ;Offset 0x3778
        if (modeData->Flags == 0x00)
            goto Label0x3778;

        //     mov       dx, word ptr cs:[B000Selector];Offset 0x77e2
        clearSegment = 0xb000;

        //     cmp       bl, 01h
        //     je        Label0x3778               ;Offset 0x3778
        if (modeData->Flags == 0x01)
            goto Label0x3778;

        //     cmp       bl, 02h
        //     jne       Label0x377e               ;Offset 0x377e
        if (modeData->Flags != 0x02)
            goto Label0x377e;

        //     mov       dx, word ptr cs:[B800Selector];Offset 0x77e4
        clearSegment = 0xb800;

        //     sub       ax, ax
        clearValue = 0x0000;

        // Label0x3778:                            ;Offset 0x3778
        Label0x3778:

        //     mov       es, dx
        //     rep stosw
        for (uint16_t i = 0; i < clearCount; ++i)
            *FARPointer(clearSegment, i).ToPointer<uint16_t>() = clearValue;

        //     jmp       Label0x37b0               ;Offset 0x37b0
        goto Label0x37b0;

        // Label0x377e:                            ;Offset 0x377e
        Label0x377e:

        //     mov       ax, 01h
        pageCount = 1;

        //     cmp       byte ptr ds:[BDA_DisplayMode], BDA_DM_320x200_256_Color_Graphics;Offset 0x449 0x13
        //     jbe       Label0x3793               ;Offset 0x3793
        if (BDA::DisplayMode::Get() < VGA::VideoMode::G320x200x8bppC)
            goto Label0x3793;

        //     call      GetMemorySizeIn256KBlocks ;Offset 0x37fc
        pageCount = memorySize;

        //     cmp       bl, 05h
        //     je        Label0x3793               ;Offset 0x3793
        if (modeData->Flags == 0x05)
            goto Label0x3793;

        //     shl       ax, 02h
        pageCount <<= 2;

        // Label0x3793:                            ;Offset 0x3793
        Label0x3793:

        //     mov       si, ax
        //     mov       ax, word ptr cs:[A000Selector];Offset 0x77e0
        clearSegment = 0xa000;

        //     mov       es, ax
        //     mov       ax, di
        //     mov       dx, di
        //set ax and dx to 0

        // Label0x379f:                            ;Offset 0x379f
        Label0x379f:

        //     call      SetVGAReadWriteAperture64K;Offset 0x3c10
        SetVGAReadWriteAperture64K(pageIndex);

        //     mov       cx, 8000h
        //     rep stosw
        memset(FARPointer(0xa000, 0x0000).ToPointer<uint8_t>(), 0, 0x10000);

        //     inc       dx
        ++pageIndex;

        //     dec       si
        --pageCount;

        //     jne       Label0x379f               ;Offset 0x379f
        if (pageCount != 0)
            goto Label0x379f;

        //     sub       dx, dx
        //     call      SetVGAReadWriteAperture64K;Offset 0x3c10
        SetVGAReadWriteAperture64K(0);

        // Label0x37b0:                            ;Offset 0x37b0
        Label0x37b0:
        (void)pageCount;
    }
    //     pop       es
    //     pop       eax
    //     popaw
    //     ret
}

void Func0x1e5a(uint8_t& red, uint8_t& green, uint8_t& blue)//Offset 0x1e5a
{
    // push      bx
    // mov       al, 1eh
    // mul       dh
    uint16_t redScaled = red * 0x1e;
    // mov       bx, ax
    // mov       al, 3bh
    // mul       ch
    uint16_t greenScaled = green * 0x3b;

    // add       bx, ax
    // mov       al, 0bh
    // mul       cl
    uint16_t blueScaled = blue * 0x0b;

    // add       ax, bx
    // sub       dx, dx
    // mov       bx, 0064h
    // add       ax, 0032h
    // div       bx
    uint8_t grey = (redScaled + greenScaled + blueScaled + 0x32) / 0x64;

    // mov       dh, al
    red = grey;

    // mov       cl, al
    green = grey;

    // mov       ch, al
    blue = grey;

    // pop       bx
    // ret
}

void Func0x1d41(uint8_t red, uint8_t green, uint8_t blue)//Offset 0x1d41
{
    using namespace Hag;
    using namespace Hag::System;

    //     push      ax
    //     push      dx
    //     test      byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_GrayScale OR BDA_VDDA_MonochromeMonitor;Offset 0x489 0x6
    //     je        Label0x1d4d               ;Offset 0x1d4d
    //     call      Func0x1e5a                ;Offset 0x1e5a
    if ((BDA::VideoDisplayDataArea::Get() & (BDA::VideoDisplayDataArea::GrayScale | BDA::VideoDisplayDataArea::MonochromeMonitor)) != 0)
        Func0x1e5a(red, green, blue);

    // Label0x1d4d:                            ;Offset 0x1d4d
    //     mov       al, dh
    //     mov       dx, VGA_RAMDACData        ;Port 0x3c9
    //     cli
    SYS_ClearInterrupts();

    //     out       dx, al
    VGA::RAMDACData::Write(red);

    //     mov       al, ch
    //     out       dx, al
    VGA::RAMDACData::Write(green);

    //     mov       al, cl
    //     out       dx, al
    VGA::RAMDACData::Write(blue);

    //     sti
    SYS_RestoreInterrupts();

    //     pop       dx
    //     pop       ax
    //     ret
}

void Func0x54c(uint8_t* paletteData, uint8_t startIndex, uint16_t count)//Offset 0x54c
{
    using namespace Hag;

    uint8_t ColorTable[]
    {
        0x00, 0x15, 0x2a, 0x3f
    };

    //     mov       bx, offset ColorTable      ;Offset 0x539
    //     mov       dx, VGA_DACWriteIndex     ;Port 0x3c8
    //     out       dx, al
    VGA::DACWriteIndex::Write(startIndex);

    for (uint16_t index = 0; index < count; ++index)
    {
        // Label0x553:                             ;Offset 0x553
        //     mov       ah, byte ptr es:[si]
        uint8_t entry = paletteData[index];

        //     inc       si
        //     mov       al, ah
        //     and       al, 03h
        //     xlatb     cs:[bx]
        uint8_t red = ColorTable[entry & 0x03];

        //     mov       dh, al
        //     mov       al, ah
        //     and       al, 0ch
        //     shr       al, 02h
        //     xlatb     cs:[bx]
        uint8_t green = ColorTable[(entry >> 2) & 0x03];

        //     mov       ch, al
        //     shr       ax, 0ch
        //     xlatb     cs:[bx]
        uint8_t blue = ColorTable[entry >> 4];

        //     mov       cl, al
        //     call      Func0x1d41                ;Offset 0x1d41
        Func0x1d41(red, green, blue);

        //     dec       di
        //     jne       Label0x553                ;Offset 0x553
    }

    //     ret
}

uint8_t Data0x73eb[] =
{
    0x00, 0x20, 0x08, 0x28, 0x02, 0x22, 0x06, 0x2A, 0x00, 0x20, 0x08, 0x28, 0x02, 0x22, 0x06, 0x2A,
    0x15, 0x35, 0x1D, 0x3D, 0x17, 0x37, 0x1F, 0x3F, 0x15, 0x35, 0x1D, 0x3D, 0x17, 0x37, 0x1F, 0x3F
};

void Func0x578()//Offset 0x578
{
    // mov       si, offset Data0x73eb     ;Offset 0x73eb
    // mov       di, 0020h
    // sub       al, al
    // push      si
    // push      di
    // call      Func0x54c                 ;Offset 0x54c
    Func0x54c(Data0x73eb, 0, 0x20);

    // pop       di
    // pop       si
    // mov       al, 20h
    // jmp       Func0x54c                 ;Offset 0x54c
    Func0x54c(Data0x73eb, 0x20, 0x20);
}

uint8_t Data0x73ab[] =
{
    0x00, 0x20, 0x08, 0x28, 0x02, 0x22, 0x0A, 0x2A, 0x10, 0x30, 0x18, 0x38, 0x12, 0x32, 0x1A, 0x3A,
    0x04, 0x24, 0x0C, 0x2C, 0x06, 0x26, 0x0E, 0x2E, 0x14, 0x34, 0x1C, 0x3C, 0x16, 0x36, 0x1E, 0x3E,
    0x01, 0x21, 0x09, 0x29, 0x03, 0x23, 0x0B, 0x2B, 0x11, 0x31, 0x19, 0x39, 0x13, 0x33, 0x1B, 0x3B,
    0x05, 0x25, 0x0D, 0x2D, 0x07, 0x27, 0x0F, 0x2F, 0x15, 0x35, 0x1D, 0x3D, 0x17, 0x37, 0x1F, 0x3F
};

void Func0x544()//Offset 0x544
{
    // mov       si, offset Data0x73ab     ;Offset 0x73ab
    // mov       di, 0040h
    // sub       al, al
    //Func0x54c
    Func0x54c(Data0x73ab, 0, 0x40);
}

void Func0x53d()//Offset 0x53d
{
    using namespace Hag::System;
    
    // test      byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_LineMode200;Offset 0x489 0x80
    // jne       Func0x578                 ;Offset 0x578
    //else Func0x544
    if ((BDA::VideoDisplayDataArea::Get() & BDA::VideoDisplayDataArea::LineMode200) != 0)
        Func0x578();
    else Func0x544();
}

uint8_t Data0x740b[] =
{
    0x00, 0x2A, 0x00, 0x3F
};

void Func0x58b()//Offset 0x58b
{
    using namespace Hag;

    //     mov       si, offset Data0x740b     ;Offset 0x740b
    //     mov       dx, VGA_DACWriteIndex     ;Port 0x3c8
    //     sub       al, al
    //     out       dx, al
    VGA::DACWriteIndex::Write(0);

    //     inc       dx
    //     mov       cx, 0002h
    for (uint32_t i = 0; i < 2; ++i)
    {
        uint32_t index = 0;
        // Label0x598:                             ;Offset 0x598
        //     push      cx
        //     push      si
        //     mov       cx, 0004h
        for (uint32_t j = 0; j < 4; ++j)
        {
            // Label0x59d:                             ;Offset 0x59d
            //     lodsb     byte ptr es:[si]

            uint8_t color = Data0x740b[index];
            ++index;

            //     mov       bx, 0018h
            for (uint32_t k = 0; k < 0x18; ++k)
            {
                // Label0x5a2:                             ;Offset 0x5a2
                //     out       dx, al
                VGA::RAMDACData::Write(color);

                //     dec       bx
                //     jne       Label0x5a2                ;Offset 0x5a2
            }
            //     loop      Label0x59d                ;Offset 0x59d
        }
        //     pop       si
        //     pop       cx
        //     loop      Label0x598                ;Offset 0x598
    }
    //     ret
}

void Func0x1d6d(uint8_t* paletteData, uint8_t startIndex, uint16_t count)//Offset 0x1d6d
{
    using namespace Hag;

    //     mov       al, bl
    //     mov       dx, VGA_DACWriteIndex     ;Port 0x3c8
    //     out       dx, al
    VGA::DACWriteIndex::Write(startIndex);
    
    //     mov       bx, cx
    uint16_t index = 0;
    for (uint16_t i  = 0; i < count; ++i)
    {
        // Label0x1d75:                            ;Offset 0x1d75
        //     mov       dh, byte ptr es:[si]
        uint8_t red = paletteData[index];

        //     inc       si
        ++index;

        //     mov       ch, byte ptr es:[si]
        uint8_t green = paletteData[index];

        //     inc       si
        ++index;

        //     mov       cl, byte ptr es:[si]
        uint8_t blue = paletteData[index];

        //     inc       si
        ++index;

        //     call      Func0x1d41                ;Offset 0x1d41
        Func0x1d41(red, green, blue);

        //     dec       bx
        //     jne       Label0x1d75               ;Offset 0x1d75
    }
    //     ret
}

uint8_t Data0x740f[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x00, 0x2A, 0x2A, 0x2A, 0x00, 0x00, 0x2A,
    0x00, 0x2A, 0x2A, 0x15, 0x00, 0x2A, 0x2A, 0x2A, 0x15, 0x15, 0x15, 0x15, 0x15, 0x3F, 0x15, 0x3F,
    0x15, 0x15, 0x3F, 0x3F, 0x3F, 0x15, 0x15, 0x3F, 0x15, 0x3F, 0x3F, 0x3F, 0x15, 0x3F, 0x3F, 0x3F,
    0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x08, 0x08, 0x08, 0x0B, 0x0B, 0x0B, 0x0E, 0x0E, 0x0E, 0x11,
    0x11, 0x11, 0x14, 0x14, 0x14, 0x18, 0x18, 0x18, 0x1C, 0x1C, 0x1C, 0x20, 0x20, 0x20, 0x24, 0x24,
    0x24, 0x28, 0x28, 0x28, 0x2D, 0x2D, 0x2D, 0x32, 0x32, 0x32, 0x38, 0x38, 0x38, 0x3F, 0x3F, 0x3F,
    0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F, 0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00, 0x3F, 0x3F,
    0x00, 0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F,
    0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00, 0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x00,
    0x00, 0x3F, 0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F, 0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00,
    0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F, 0x2F, 0x1F,
    0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x1F, 0x37, 0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27,
    0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F, 0x2F, 0x1F, 0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x37,
    0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27, 0x3F, 0x1F, 0x1F, 0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F,
    0x2F, 0x1F, 0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x37, 0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27, 0x3F,
    0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36, 0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D, 0x3F, 0x3F,
    0x2D, 0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36,
    0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D, 0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x2D,
    0x2D, 0x3F, 0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36, 0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D,
    0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C, 0x0E, 0x00,
    0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x1C, 0x1C, 0x00, 0x15, 0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07,
    0x1C, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C, 0x0E, 0x00, 0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x15,
    0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07, 0x1C, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C,
    0x0E, 0x00, 0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x15, 0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07, 0x1C,
    0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15, 0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E, 0x1C, 0x1C,
    0x0E, 0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15,
    0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E, 0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x0E,
    0x0E, 0x1C, 0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15, 0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E,
    0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C, 0x18, 0x14,
    0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1C, 0x1C, 0x14, 0x1A, 0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16,
    0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C, 0x18, 0x14, 0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1A,
    0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16, 0x1C, 0x14, 0x14, 0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C,
    0x18, 0x14, 0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1A, 0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16, 0x1C,
    0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10,
    0x00, 0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08,
    0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00, 0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00,
    0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10, 0x0C, 0x08,
    0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x10, 0x10, 0x08, 0x0E, 0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A,
    0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10, 0x0C, 0x08, 0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x0E,
    0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A, 0x10, 0x08, 0x08, 0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10,
    0x0C, 0x08, 0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x0E, 0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A, 0x10,
    0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D, 0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B, 0x10, 0x10,
    0x0B, 0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D,
    0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B, 0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x0B,
    0x0B, 0x10, 0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D, 0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B,
    0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10
};

void Func0x5ad()//Offset 0x5ad
{
    // mov       si, offset Data0x740f     ;Offset 0x740f
    // mov       cx, 0f8h
    // sub       bl, bl
    // jmp       Func0x1d6d                ;Offset 0x1d6d
    Func0x1d6d(Data0x740f, 0x00, 0xf8);//0x2E8
}

void Func0x6ca()//Offset 0x6ca
{
    //ret
}

void Func0x3d04()//Offset 0x3d04
{
    // jmp    Func0x5ad                    ;Offset 0x5ad
    Func0x5ad();
}

void Func0x3d07()//Offset 0x3d07
{
    // jmp    Func0x5ad                    ;Offset 0x5ad
    Func0x5ad();
}

void ConfigurePalette()//Offset 0x509
{
    using namespace Hag;
    using namespace Hag::System;

    ModeData* modeData = nullptr;

    // PaletteSetCallTable     DW offset Func0x53d;0x53d
    //                         DW offset Func0x58b;0x58b
    //                         DW offset Func0x578;0x578
    //                         DW offset Func0x58b;0x58b
    //                         DW offset Func0x544;0x544
    //                         DW offset Func0x544;0x544
    //                         DW offset Func0x5ad;0x5ad
    //                         DW offset Func0x3d04;0x3d04
    //                         DW offset Func0x3d07;0x3d07
    //                         DW offset Func0x6ca;0x6ca

    //     mov       dx, VGA_DACMask           ;Port 0x3c6
    //     mov       al, 0ffh
    //     out       dx, al
    VGA::DACMask::Write(0xff);

    //     mov       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    VGA::VideoMode_t mode = BDA::DisplayMode::Get();

    //     mov       bx, 04h
    uint16_t index = 2;
    //     cmp       al, BDA_DM_320x200_16_Color_Graphics;0xd
    //     je        Label0x52f                ;Offset 0x52f
    if (mode == VGA::VideoMode::G320x200x4bppC)
        goto Label0x52f;

    //     cmp       al, BDA_DM_640x200_16_Color_Graphics;0xe
    //     je        Label0x52f                ;Offset 0x52f
    if (mode == VGA::VideoMode::G640x200x4bppC)
        goto Label0x52f;

    //     call      FindModeData              ;Offset 0x40d9
    FindModeData(mode, modeData);

    //     mov       bl, byte ptr es:[bx + 04h]
    index = modeData->Flags;

    //     sub       bh, bh
    //     cmp       bl, 0ah
    //     jb        Label0x52d                ;Offset 0x52d
    if (index < 0x0a)
        goto Label0x52d;

    //     mov       bl, 09h
    index = 0x09;

    // Label0x52d:                             ;Offset 0x52d
    Label0x52d:

    //     shl       bx, 01h
    //index <<= 1;

    // Label0x52f:                             ;Offset 0x52f
    Label0x52f:

    //     push      es
    //     push      cs
    //     pop       es
    //     call      word ptr cs:[bx + PaletteSetCallTable];Offset 0x4f5
    switch(index)
    {
    case 0:         // Text 4bpp
        Func0x53d();
        break;
    case 1:
        Func0x58b();
        break;
    case 2:
        Func0x578();
        break;
    case 3:
        Func0x58b();
        break;
    case 4:
        Func0x544();
        break;
    case 5:         // Graphics 4bpp
        Func0x544();
        break;
    case 6:         // Graphics 8bpp
        Func0x5ad();
        break;
    case 7:         // Graphics 16bpp
        Func0x3d04();
        break;
    case 8:         // Graphics 32bpp
        Func0x3d07();
        break;
    case 9:
        Func0x6ca();
        break;
    default:
        break;
    }
    //     pop       es
    //     ret
}

void Func0x687(Hag::VGA::Register_t inputStatus1, Hag::System::BDA::VideoParameterTable& parameters)//Offset 0x687
{
    using namespace Hag;

    //     push      dx
    //     push      di
    //     push      ds
    //     push      es
    //     push      es
    //     les       di, ds:[BDA_VideoParameterControlBlockPointer];Offset 0x4a8
    //     les       di, es:[di + BDA_VPCB_DynamicParamSaveArea];Offset 0x4
    //     pop       ds
    //     mov       ax, es
    //     or        ax, di
    //     je        Label0x6a4                ;Offset 0x6a4
    //     mov       cx, 0010h
    //     push      si
    //     rep movsb
    //     inc       si
    //     movsb
    //     pop       si
    // Label0x6a4:                             ;Offset 0x6a4

    //     sub       bl, bl
    //     mov       cx, 0014h
    //     cli
    SYS_ClearInterrupts();

    //     in        al, dx
    VGA::InputStatus1::Read(inputStatus1);

    //     mov       dl, VGA_AttributeControllerIndex_lowbyte;Port 0x3c0
    // Label0x6ad:                             ;Offset 0x6ad
    //     mov       al, bl
    //     out       dx, al
    //     lodsb
    //     out       dx, al
    //     inc       bx
    //     loop      Label0x6ad                ;Offset 0x6ad
    VGA::AttributeControllerData::Write(0, parameters.AttributeControllerRegisters, 0x14);

    //     sti
    SYS_RestoreInterrupts();

    //     pop       es
    //     pop       ds
    //     pop       di
    //     pop       dx
    //     ret
}

bool CheckModeList(Hag::VGA::VideoMode_t* modeList)//Offset 0x6bb
{
    using namespace Hag::System;

    //     mov       ah, byte ptr ds:[BDA_DisplayMode]    ;Offset 0x449
    while (*modeList != 0xff)
    {
        // Label0x6bf:                             ;Offset 0x6bf
        //     lodsb     byte ptr es:[si]
        //     cmp       ah, al
        //     je        Label0x6ca                ;Offset 0x6ca
        //     cmp       al, 0ffh
        //     jne       Label0x6bf                ;Offset 0x6bf
        if (*modeList == BDA::DisplayMode::Get())
            return true;

        //     dec       ax
        ++modeList;
    }
    // Label0x6ca:                             ;Offset 0x6ca
    //     ret
    return false;
}

void SetAttributePalette(Hag::VGA::Register_t inputStatus1)//Offset 0x1e7f
{
    using namespace Hag;

    //     cli
    SYS_ClearInterrupts();

    //     in        al, dx
    VGA::InputStatus1::Read(inputStatus1);

    //     mov       dl, VGA_AttributeControllerIndex_lowbyte;Port 0x3c0h
    // Label0x1e83:                            ;Offset 0x1e83
    //     cmp       ah, 10h
    //     jae       Label0x1e96               ;Offset 0x1e96
    //     mov       al, ah
    //     out       dx, al
    //     lodsb
    //     out       dx, al
    //     inc       ah
    //     loop      Label0x1e83               ;Offset 0x1e83
    // Label0x1e91:                            ;Offset 0x1e91
    //     mov       al, VGA_ATTR_PaletteAddressSource;0x20
    //     out       dx, al
    //     sti
    SYS_RestoreInterrupts();

    //     ret
    // Label0x1e96:                            ;Offset 0x1e96
    //     mov       al, VGA_ATTR_OverscanColor;0x11
    //     out       dx, al
    //     lodsb
    //     out       dx, al
    //     jmp       Label0x1e91               ;Offset 0x1e91
}

void PaletteSetup(Hag::System::BDA::VideoParameterTable& parameters)//Offset 0x48a
{
    using namespace Hag;
    using namespace Hag::System;

    //     push      di
    //     push      es
    //     mov       dx, word ptr ds:[BDA_VideoBaseIOPort];Offset 0x463
    //     add       dl, 06h                   ;Port 0x3?a
    //     push      dx
    //     lea       si, [di + 23h]
    //     call      Func0x687                 ;Offset 0x687
    Func0x687(BDA::VideoBaseIOPort::Get() + 0x6, parameters);

    //     cli
    SYS_ClearInterrupts();

    //     in        al, dx
    VGA::InputStatus1::Read(BDA::VideoBaseIOPort::Get() + 0x6);

    //     mov       dl, VGA_AttributeControllerIndex_lowbyte;Port 0x3c0
    //     mov       al, VGA_ATTR_ColorSelect  ;0x14
    //     out       dx, al
    //     sub       al, al
    //     out       dx, al
    VGA::AttributeController::PixelPadding::Write(0);

    //     sti
    SYS_RestoreInterrupts();

    //     test      byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_PaletteLoadingEnabled;Offset 0x489 0x8
    //     jne       Label0x4af                ;Offset 0x4af
    if ((BDA::VideoDisplayDataArea::Get() & BDA::VideoDisplayDataArea::PaletteLoadingDisabled) == 0)
    {
        //     call      Func0x509                 ;Offset 0x509
        ConfigurePalette();

        // Label0x4af:                             ;Offset 0x4af
    }
    
    //     pop       dx
    //     les       di, ds:[BDA_VideoParameterControlBlockPointer];Offset 0x4a8
    //     les       di, es:[di + BDA_VPCB_SecondarySavePointerTbl];Offset 0x10
    //     mov       ax, es
    //     or        ax, di
    //     je        Label0x4f2                ;Offset 0x4f2
    //     les       di, es:[di + BDA_VPCB_PaletterProfileTable];Offset 0xa
    //     mov       ax, es
    //     or        ax, di
    //     je        Label0x4f2                ;Offset 0x4f2
    //     lea       si, [di + BDA_PPT_ApplicableModeList];Offset 0x14
    //     call      CheckModeList             ;Offset 0x6bb
    //     jne       Label0x4f2                ;Offset 0x4f2
    //     push      ds
    //     mov       cx, word ptr es:[di + BDA_PPT_AttributeRegCount];Offset 0x4
    //     mov       ah, byte ptr es:[di + BDA_PPT_AttributeRegStartIndex];Offset 0x6
    //     lds       si, es:[di + BDA_PPT_AttributeRegsPtr];Offset 0x8
    //     call      SetAttributePalette       ;Offset 0x1e7f
    //     mov       ax, 1012h                 ;Dac functions - Set block of dac registers
    //     mov       cx, word ptr es:[di + BDA_PPT_DACRegCount];Offset 0xc
    //     mov       bx, word ptr es:[di + BDA_PPT_DACRegStartIndex];Offset 0xe
    //     les       dx, es:[di + BDA_PPT_DacRegsPtr];Offset 0x10
    //     int       10h
    //     pop       ds
    // Label0x4f2:                             ;Offset 0x4f2
    //     pop       es
    //     pop       di
    //     ret
}

void ConfigureExtensionRegisters()//Offset 0x363c
{
    using namespace Hag::System;
    using namespace Hag::TDfx;
    //     pushad
    //     push      es
    //     mov       ax, 0b102h                ;Find PCI Device
    //     sub       si, si
    //     mov       cx, PCI_DEVICE_Banshee    ;0003h
    //     mov       dx, PCI_VENDOR_3Dfx       ;0x121a
    //     int       1ah
    PCI::Device_t device = 0;
    PCI::FindDevice(0x121a, 0x0003, device);

    //     mov       ax, 0b109h                ;Read Configuration Word
    //     mov       di, PCI_Header_Word_Command;0x4
    //     int       1ah
    //     and       cl, NOT PCI_Cmd_VGAPaletteSnoop;0dfh
    //     mov       ax, 0b10ch                ;Write Configuration Word
    //     int       1ah
    PCI::Write16(device, PCI::PreHeader::Command,
    PCI::Read16(device, PCI::PreHeader::Command) & ~PCI::Command::VGAPaletteSnoop);

    //     mov       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    //     call      FindModeData              ;Offset 0x40d9
    //     jb        Label0x373c               ;Offset 0x373c
    ModeData* modeData = nullptr;
    if (FindModeData(BDA::DisplayMode::Get(), modeData))
    {
        //     mov       ax, word ptr es:[bx + 0bh]
        //     push      ax
        uint16_t saveAX = modeData->Stride;

        //     movzx     eax, word ptr es:[bx + 09h]
        uint32_t saveEAX = modeData->Height;

        //     shl       eax, 0ch
        //     push      eax
        saveEAX <<= 12;
        
        //     mov       cx, word ptr es:[bx + 07h]
        //     and       cx, 0fffh
        uint32_t saveEAX2 = modeData->Width & Shared::VideoScreenSize::Width;

        //     or        ax, cx
        //     push      eax
        saveEAX2 |= saveEAX;
        
        //     call      GetExtraModeData          ;Offset 0x3f29
        ExtraModeData* extraModeData = GetExtraModeData(*modeData);

        //     mov       dx, word ptr ds:[BDA_VideoBaseIOPort];Offset 0x463
        //     mov       ax, TDFX_CRTC_HorizontalExtension;0x1a
        //     out       dx, ax
        Shared::CRTController::HorizontalExtension::Write(BDA::VideoBaseIOPort::Get(), 0);

        //     inc       ax
        //     mov       ah, byte ptr es:[si + 01h]
        //     out       dx, ax                    ;Vertical Extension Register
        Shared::CRTController::VerticalExtension::Write(BDA::VideoBaseIOPort::Get(), extraModeData->VerticalExtension);

        //     mov       al, TDFX_CRTC_ExtensionByte1;0x1d
        //     call      ReadIndexedRegister       ;Offset 0x3f84
        //     and       ah, 7fh
        //     out       dx, ax
        Shared::CRTController::Extension1::Write(BDA::VideoBaseIOPort::Get(),
            Shared::CRTController::Extension1::Read(BDA::VideoBaseIOPort::Get()) & 0x7f);

        //     call      GetIOBaseAddress          ;Offset 0x3d69
        uint16_t baseAddress = GetIOBaseAddress();

        //     mov       di, dx
        //     add       dx, TDFX_IO_PLLControl0   ;0x40
        //     sub       eax, eax
        //     mov       ax, word ptr es:[si + 04h]
        //     test      ax, ax
        //     je        Label0x36b2               ;Offset 0x36b2
        //     out       dx, eax
        if (extraModeData->PLLControl0 != 0)
            Shared::IO::PLLControl0::Write(baseAddress, extraModeData->PLLControl0);

        // Label0x36b2:                            ;Offset 0x36b2
        //     movzx     ecx, byte ptr es:[si]
        //     lea       dx, [di + TDFX_IO_DACMode];0x4c
        //     sub       eax, eax
        //     out       dx, eax
        Shared::IO::DACMode::Write(baseAddress, 0);

        //     lea       dx, [di + TDFX_IO_VideoDesktopStartAddress];0xe4
        //     sub       eax, eax
        //     out       dx, eax
        Shared::IO::VideoDesktopStartAddress::Write(baseAddress, 0);

        //     pop       eax
        //saveEAX2

        //     pop       edx
        //saveEAX

        //     test      cl, 04h
        //     je        Label0x36d4               ;Offset 0x36d4
        //     add       eax, edx
        if ((extraModeData->Unknown0 & 0x4) != 0)
            saveEAX2 += saveEAX;
            
        // Label0x36d4:                            ;Offset 0x36d4
        //     lea       dx, [di + TDFX_IO_VideoScreenSize];0x98
        //     out       dx, eax
        Shared::IO::VideoScreenSize::Write(baseAddress, saveEAX2);

        //     sub       eax, eax
        //     pop       ax
        //saveAX

        //     lea       dx, [di + TDFX_IO_VideoDesktopOverlayStride];0xe8
        //     out       dx, eax
        Shared::IO::VideoDesktopOverlayStride::Write(baseAddress, saveAX);

        //     mov       bl, cl
        //     lea       dx, [di + TDFX_IO_VGAInit0];0x28
        //     in        eax, dx
        //     and       eax, 00000100h
        //     and       bl, 01h
        //     shl       bx, 0ch
        //     or        bx, 0040h
        //     or        ax, bx
        //     out       dx, eax
        Shared::IO::VGAInit0::Write(baseAddress,
            (Shared::IO::VGAInit0::Read(baseAddress) & Shared::VGAInit0::WakeUpSelect) |
            (uint32_t(extraModeData->Unknown0 & 1) << 12) |
            Shared::VGAInit0::ExtensionsEnabled);

        //     lea       dx, [di + TDFX_IO_VGAInit1];0x2c
        //     mov       eax, ecx
        //     and       eax, 00000001h
        //     shl       eax, 14h
        //     out       dx, eax
        Shared::IO::VGAInit1::Write(baseAddress, uint32_t(extraModeData->Unknown0 & 1) << 20);

        //     lea       dx, [di + TDFX_IO_VideoProcessorConfig];0x5c
        //     mov       eax, ecx
        //     and       al, 38h
        //     shl       eax, 0fh
        uint32_t val = (extraModeData->Unknown0 & 0x38) << 0xf;

        //     test      cl, 01h
        //     je        Label0x3731               ;Offset 0x3731
        if ((extraModeData->Unknown0 & 1) != 0)
        {
            //     or        al, 81h
            val |= 0x81;

            //     test      cl, 38h
            //     je        Label0x3729               ;Offset 0x3729
            if ((extraModeData->Unknown0 & 0x38) != 0)
            {
                //     or        ah, 0ch
                val |= 0x0c00;

                // Label0x3729:                            ;Offset 0x3729
            }

            //     and       cl, 06h
            //     shl       cl, 02h
            //     or        al, cl
            val |= (extraModeData->Unknown0 & 0x06) << 2;

            // Label0x3731:                            ;Offset 0x3731
        }

        //     out       dx, eax
        Shared::IO::VideoProcessorConfiguration::Write(baseAddress, val);

        //     lea       dx, [di + TDFX_IO_DRamInit1];0x1c
        //     in        eax, dx
        //     or        al, 01h
        //     out       dx, eax
        Shared::IO::DRAMInit1::Write(baseAddress,
            Shared::IO::DRAMInit1::Read(baseAddress) |
            Shared::DRAMInit1::SGRAMRefreshEnable);

        // Label0x373c:                            ;Offset 0x373c
    }
    //     pop       es
    //     popad
    //     ret
}

bool Func0x3faf(Hag::VGA::VideoMode_t mode)//Offset 0x3faf
{
    //     push   bx
    //     push   es
    //     call   FindModeData                 ;Offset 0x40d9
    //     jb     Label0x3fc2                  ;Offset 0x3fc2
    ModeData* modeData = nullptr;
    if (!FindModeData(mode, modeData))
    {
        //     cmp    byte ptr es:[bx + 04h], 00h
        //     je     Label0x3fc2                  ;Offset 0x3fc2
        //     cmp    byte ptr es:[bx + 04h], 01h
        // Label0x3fc2:                            ;Offset 0x3fc2
        if ((modeData->Flags != 0x00) &&
            (modeData->Flags != 0x01))
            return true;
    }
    //     pop    es
    //     pop    bx
    //     ret
    return false;
}

void Func0x1ee5()//Offset 0x1ee5
{
    using namespace Hag;
    // push      dx
    // mov       dx, VGA_GraphicsControllerIndex;Port 0x3ce
    // mov       ax, VGA_GCTLIdx_GraphicMode;0x5
    // out       dx, ax
    VGA::GraphicsController::GraphicsControllerMode::Write(0);

    // mov       al, VGA_GCTLIdx_Miscellaneous;0x6
    // call      ReadIndexedRegister       ;Offset 0x3f84
    // and       ah, VGA_GCTL6_GfxMode     ;0x1
    // or        ah, VGA_GCTL6_Mem_A0000_AFFFF;0x4
    // out       dx, ax
    VGA::GraphicsController::MemoryMapModeControl::Write(
        (VGA::GraphicsController::MemoryMapModeControl::Read() &
         VGA::GraphicsController::MemoryMapModeControl::SelectTextGraphicsMode) |
        VGA::GraphicsController::MemoryMapModeControl::A0000HtoAFFFFH);

    // mov       dl, VGA_SequenceIndex_lowbyte;Port 0x3c4
    // mov       ax, VGA_SEQIdx_MapMask OR (VGA_SEQ2_Mask2 SHL 8);0x402
    // out       dx, ax
    VGA::Sequencer::EnableWritePlane::Write(VGA::Sequencer::EnableWritePlane::Plane3);

    // mov       ax, VGA_SEQIdx_MemoryMode OR ((VGA_SEQ4_MemSize256k OR VGA_SEQ4_CPUAnyMap) SHL 8);0x604
    // out       dx, ax
    VGA::Sequencer::MemoryModeControl::Write(VGA::Sequencer::MemoryModeControl::ExtendedMemoryAddress |
                                             VGA::Sequencer::MemoryModeControl::SequentialAddressingMode);

    // pop       dx
    // ret
}

uint8_t Font8x8[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E,
    0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E, 0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00,
    0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x38, 0x7C, 0x38, 0xFE, 0xFE, 0x7C, 0x38, 0x7C,
    0x10, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x7C, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00,
    0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF, 0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00,
    0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF, 0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78,
    0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0,
    0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0, 0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99,
    0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00, 0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00,
    0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
    0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00, 0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0xCC, 0x78,
    0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,
    0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,
    0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00,
    0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
    0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
    0x30, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x30, 0x00, 0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,
    0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00, 0x60, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
    0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00, 0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00,
    0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00, 0x78, 0xCC, 0x0C, 0x38, 0x0C, 0xCC, 0x78, 0x00,
    0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00, 0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
    0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00, 0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
    0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00,
    0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
    0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0xFC, 0x00, 0x00,
    0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x78, 0xCC, 0x0C, 0x18, 0x30, 0x00, 0x30, 0x00,
    0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00, 0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00,
    0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00, 0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00,
    0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00,
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00, 0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00,
    0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, 0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00,
    0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
    0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
    0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0xDC, 0x78, 0x1C, 0x00,
    0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00, 0x78, 0xCC, 0xE0, 0x70, 0x1C, 0xCC, 0x78, 0x00,
    0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFC, 0x00,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, 0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00,
    0xC6, 0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00,
    0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
    0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
    0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00,
    0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
    0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
    0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00, 0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x0C, 0x00, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00,
    0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xC6, 0x00,
    0x00, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
    0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E,
    0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x00,
    0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
    0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, 0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00,
    0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
    0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00, 0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00,
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00, 0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00,
    0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00,
    0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x18, 0x0C, 0x78, 0x00, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00,
    0x1C, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 0x7E, 0xC3, 0x3C, 0x06, 0x3E, 0x66, 0x3F, 0x00,
    0xCC, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00, 0xE0, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00,
    0x30, 0x30, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00, 0x00, 0x00, 0x78, 0xC0, 0xC0, 0x78, 0x0C, 0x38,
    0x7E, 0xC3, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00, 0xCC, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
    0xE0, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 0xCC, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x7C, 0xC6, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00, 0xE0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
    0xC6, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0x00, 0x30, 0x30, 0x00, 0x78, 0xCC, 0xFC, 0xCC, 0x00,
    0x1C, 0x00, 0xFC, 0x60, 0x78, 0x60, 0xFC, 0x00, 0x00, 0x00, 0x7F, 0x0C, 0x7F, 0xCC, 0x7F, 0x00,
    0x3E, 0x6C, 0xCC, 0xFE, 0xCC, 0xCC, 0xCE, 0x00, 0x78, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
    0x00, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0xE0, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
    0x78, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00, 0x00, 0xE0, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00,
    0x00, 0xCC, 0x00, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, 0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00,
    0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x18, 0x18, 0x7E, 0xC0, 0xC0, 0x7E, 0x18, 0x18,
    0x38, 0x6C, 0x64, 0xF0, 0x60, 0xE6, 0xFC, 0x00, 0xCC, 0xCC, 0x78, 0xFC, 0x30, 0xFC, 0x30, 0x30,
    0xF8, 0xCC, 0xCC, 0xFA, 0xC6, 0xCF, 0xC6, 0xC7, 0x0E, 0x1B, 0x18, 0x3C, 0x18, 0x18, 0xD8, 0x70,
    0x1C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00, 0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x00, 0x1C, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x1C, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00,
    0x00, 0xF8, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0x00, 0xFC, 0x00, 0xCC, 0xEC, 0xFC, 0xDC, 0xCC, 0x00,
    0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00,
    0x30, 0x00, 0x30, 0x60, 0xC0, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xC0, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFC, 0x0C, 0x0C, 0x00, 0x00, 0xC3, 0xC6, 0xCC, 0xDE, 0x33, 0x66, 0xCC, 0x0F,
    0xC3, 0xC6, 0xCC, 0xDB, 0x37, 0x6F, 0xCF, 0x03, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00,
    0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00, 0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00,
    0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
    0xDB, 0x77, 0xDB, 0xEE, 0xDB, 0x77, 0xDB, 0xEE, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36,
    0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36,
    0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00,
    0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36,
    0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
    0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36,
    0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xDC, 0xC8, 0xDC, 0x76, 0x00, 0x00, 0x78, 0xCC, 0xF8, 0xCC, 0xF8, 0xC0, 0xC0,
    0x00, 0xFC, 0xCC, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00,
    0xFC, 0xCC, 0x60, 0x30, 0x60, 0xCC, 0xFC, 0x00, 0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0x70, 0x00,
    0x00, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0xC0, 0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x00,
    0xFC, 0x30, 0x78, 0xCC, 0xCC, 0x78, 0x30, 0xFC, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x6C, 0x38, 0x00,
    0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x6C, 0xEE, 0x00, 0x1C, 0x30, 0x18, 0x7C, 0xCC, 0xCC, 0x78, 0x00,
    0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00, 0x06, 0x0C, 0x7E, 0xDB, 0xDB, 0x7E, 0x60, 0xC0,
    0x38, 0x60, 0xC0, 0xF8, 0xC0, 0x60, 0x38, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00,
    0x00, 0xFC, 0x00, 0xFC, 0x00, 0xFC, 0x00, 0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0xFC, 0x00,
    0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xFC, 0x00, 0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xFC, 0x00,
    0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0x70,
    0x30, 0x30, 0x00, 0xFC, 0x00, 0x30, 0x30, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00,
    0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x0F, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x3C, 0x1C,
    0x78, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

uint8_t Font8x14[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0x81, 0xBD, 0x99, 0x81, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0xFF, 0xDB, 0xFF, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x6C, 0xFE, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x3C, 0xE7, 0xE7, 0xE7, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x1E, 0x0E, 0x1A, 0x32, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3F, 0x33, 0x3F, 0x30, 0x30, 0x30, 0x70, 0xF0, 0xE0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0x63, 0x7F, 0x63, 0x63, 0x63, 0x67, 0xE7, 0xE6, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0xDB, 0x3C, 0xE7, 0x3C, 0xDB, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x02, 0x06, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0xDB, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x1B, 0x00, 0x00, 0x00,
    0x00, 0x7C, 0xC6, 0x60, 0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x38, 0x0C, 0xC6, 0x7C, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x7E, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x28, 0x6C, 0xFE, 0x6C, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7C, 0x7C, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0xFE, 0x7C, 0x7C, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x66, 0xC6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xE6, 0x66, 0x6C, 0x6C, 0x78, 0x6C, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xFE, 0x7C, 0x6C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0x8C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38, 0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00,
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x70, 0x1C, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x66, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x0C, 0x06, 0x7C, 0x00,
    0x00, 0x00, 0xCC, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x18, 0x30, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xCC, 0xCC, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x38, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x0C, 0x06, 0x3C, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xCC, 0xCC, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x3C, 0x66, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0xC6, 0xC6, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00, 0x00, 0x00,
    0x38, 0x6C, 0x38, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00, 0x00, 0x00,
    0x18, 0x30, 0x60, 0x00, 0xFE, 0x66, 0x60, 0x7C, 0x60, 0x66, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xCC, 0x76, 0x36, 0x7E, 0xD8, 0xD8, 0x6E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3E, 0x6C, 0xCC, 0xCC, 0xFE, 0xCC, 0xCC, 0xCC, 0xCE, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x78, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00,
    0x00, 0xC6, 0xC6, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00,
    0x00, 0xC6, 0xC6, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x3C, 0x66, 0x60, 0x60, 0x66, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0xE6, 0xFC, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0xF8, 0xCC, 0xCC, 0xF8, 0xC4, 0xCC, 0xDE, 0xCC, 0xCC, 0xC6, 0x00, 0x00, 0x00,
    0x00, 0x0E, 0x1B, 0x18, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x18, 0xD8, 0x70, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x18, 0x30, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xDC, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
    0x76, 0xDC, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0x00, 0x00, 0x00,
    0x00, 0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC0, 0xC0, 0xC6, 0xCC, 0xD8, 0x30, 0x60, 0xDC, 0x86, 0x0C, 0x18, 0x3E, 0x00,
    0x00, 0xC0, 0xC0, 0xC6, 0xCC, 0xD8, 0x30, 0x66, 0xCE, 0x9E, 0x3E, 0x06, 0x06, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x36, 0x6C, 0xD8, 0x6C, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xD8, 0x6C, 0x36, 0x6C, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,
    0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
    0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0xD8, 0xD8, 0xDC, 0x76, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0x40, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0xC6, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0x60, 0x30, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x6C, 0x6C, 0xEE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1E, 0x30, 0x18, 0x0C, 0x3E, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x06, 0x7E, 0xDB, 0xDB, 0xF3, 0x7E, 0x60, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1C, 0x30, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x30, 0x1C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x3C, 0x1C, 0x00, 0x00, 0x00,
    0x00, 0xD8, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x70, 0xD8, 0x30, 0x60, 0xC8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

uint8_t Font8x16[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0x81, 0xA5, 0x99, 0x81, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0xFF, 0xDB, 0xFF, 0xFF, 0xDB, 0xE7, 0xFF, 0xFF, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0xE7, 0xE7, 0xE7, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x1E, 0x06, 0x0E, 0x1A, 0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3F, 0x33, 0x3F, 0x30, 0x30, 0x30, 0x30, 0x70, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0x63, 0x7F, 0x63, 0x63, 0x63, 0x63, 0x67, 0xE7, 0xE6, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x18, 0xDB, 0x3C, 0xE7, 0x3C, 0xDB, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFE, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x06, 0x0E, 0x1E, 0x3E, 0xFE, 0x3E, 0x1E, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0xDB, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x7C, 0xC6, 0x60, 0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x6C, 0xFE, 0x6C, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7C, 0x7C, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x7C, 0x7C, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06, 0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xD6, 0xD6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38, 0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38, 0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x0C, 0x06, 0x7C, 0x00, 0x00,
    0x00, 0x00, 0xCC, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x18, 0x30, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xCC, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x38, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x66, 0x3C, 0x0C, 0x06, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x3C, 0x66, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC6, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x38, 0x6C, 0x38, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x30, 0x60, 0x00, 0xFE, 0x66, 0x60, 0x7C, 0x60, 0x60, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x76, 0x36, 0x7E, 0xD8, 0xD8, 0x6E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3E, 0x6C, 0xCC, 0xCC, 0xFE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x78, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00,
    0x00, 0xC6, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC6, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xE6, 0xFC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xF8, 0xCC, 0xCC, 0xF8, 0xC4, 0xCC, 0xDE, 0xCC, 0xCC, 0xCC, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0E, 0x1B, 0x18, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0x70, 0x00, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x18, 0x30, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xDC, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x76, 0xDC, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0xC0, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30, 0x60, 0xDC, 0x86, 0x0C, 0x18, 0x3E, 0x00, 0x00,
    0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xCE, 0x9E, 0x3E, 0x06, 0x06, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x6C, 0xD8, 0x6C, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x6C, 0x36, 0x6C, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,
    0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
    0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0xD8, 0xD8, 0xD8, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0xD8, 0xCC, 0xC6, 0xC6, 0xC6, 0xCC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0xC6, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0xC6, 0x60, 0x30, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7E, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x6C, 0x6C, 0x6C, 0xEE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1E, 0x30, 0x18, 0x0C, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xDB, 0xDB, 0xDB, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03, 0x06, 0x7E, 0xDB, 0xDB, 0xF3, 0x7E, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1C, 0x30, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x30, 0x1C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x6C, 0x3C, 0x1C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xD8, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x70, 0xD8, 0x30, 0x60, 0xC8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//out: di = font, bh = charHeight
void GetFontAndCharHeight(uint8_t*& font, uint8_t& charHeight)//Offset 0x1ec8
{
    using namespace Hag::System;

    //     push      cs
    //     pop       es
    //     mov       di, offset Font8x8        ;Offset 0x4b3a
    font = Font8x8;
    
    //     mov       bh, 08h
    charHeight = 8;
    
    //     mov       al, byte ptr ds:[BDA_PointHeightOfCharacterMatrix];Offset 0x485
    //     cmp       al, 09h
    //     jbe       Label0x1ee4               ;Offset 0x1ee4
    if (BDA::PointHeightOfCharacterMatrix::Get() > 9)
    {
        //     mov       bh, 0eh
        charHeight = 14;

        //     mov       di, offset Font8x14       ;Offset 0x533a
        font = Font8x14;

        //     cmp       al, 0eh
        //     jbe       Label0x1ee4               ;Offset 0x1ee4
        if (BDA::PointHeightOfCharacterMatrix::Get() > 14)
        {
            //     mov       bh, 10h
            charHeight = 16;

            //     mov       di, offset Font8x16       ;Offset 0x613a
            font = Font8x16;

            // Label0x1ee4:                            ;Offset 0x1ee4
        }
    }
    //     ret
}

//in: bx = bankIndex, dx = characterIndex
//out: di = offset
uint16_t GetCharacterBankOffset(uint16_t bankIndex, uint16_t characterIndex)//Offset 0x2267
{
    static uint16_t bankOffset[]
    {
        0x0000,
        0x4000,
        0x8000,
        0xc000,
        0x2000,
        0x6000,
        0xa000,
        0xe000
    };

    // push bx
    // push dx
    // and  bx, 07h
    // shl  bx, 01h
    // call GetA000SelectorInES            ;Offset 0x3f4c
    // mov  di, word ptr cs:[bx + Data0x2257];Offset 0x2257
    // shl  dx, 05h
    // add  di, dx
    // pop  dx
    // pop  bx
    // ret
    return bankOffset[(bankIndex & 7)] + (characterIndex << 5);
}

//in: bl = bankIndex, bh = charHeight, dx = characterIndex, cx = count, di = font
void UploadCharacters(uint8_t bankIndex, uint8_t charHeight, uint16_t characterIndex, uint16_t count, uint8_t* font)//Offset 0x1f3d
{
    //     push      bx
    //     push      ds
    //     push      es
    //     mov       si, di
    //     push      es
    //     pop       ds
    //     call      GetCharacterBankOffset    ;Offset 0x2267
    //     jcxz      Label0x1f5f               ;Offset 0x1f5f
    if (count != 0)
    {
        //     mov       dx, cx
        //     mov       bl, bh
        //     sub       bh, bh
        //     push      bp
        //     mov       bp, 0020h
        //     sub       bp, bx
        uint16_t offset = GetCharacterBankOffset(bankIndex, characterIndex);
        uint8_t* ptr = FARPointer(0xa000, offset).ToPointer<uint8_t>(count * 0x20);
        for (uint16_t i = 0; i < count; ++i)
        {
            // Label0x1f55:                            ;Offset 0x1f55
            //     mov       cx, bx
            //     rep movsb
            //     add       di, bp

            memcpy(ptr, font, charHeight);
            ptr += 0x20;
            font += charHeight;

            //     dec       dx
            //     jne       Label0x1f55               ;Offset 0x1f55
        }
        //     pop       bp
        // Label0x1f5f:                            ;Offset 0x1f5f
    }
    //     pop       es
    //     pop       ds
    //     pop       bx
    //     ret
}

void Func0x37b5(uint8_t bankIndex, uint8_t charHeight, uint16_t characterIndex)//Offset 0x37b5
{
    using namespace Hag;
    using namespace Hag::System;

    //     pushaw
    //     push      ds
    //     push      es
    //     sub       dx, dx
    //     mov       ds, dx
    //     mov       cl, byte ptr ds:[BDA_PointHeightOfCharacterMatrix];Offset 0x485
    //     sub       cl, bh
    //     jbe       Label0x37f3               ;Offset 0x37f3
    if (charHeight > BDA::PointHeightOfCharacterMatrix::Get())
    {
        //     call      GetCharacterBankOffset    ;Offset 0x2267
        uint16_t offset = GetCharacterBankOffset(bankIndex, characterIndex);
        (void)offset;

        //     sub       ch, ch
        //     mov       dx, VGA_GraphicsControllerIndex;Port 0x3ce
        //     mov       ax, VGA_GCTLIdx_ReadMapSelect OR (VGA_GCTL4_Map2 SHL 8);0x204
        //     out       dx, ax
        VGA::GraphicsController::ReadPlaneSelect::Write(VGA::GraphicsController::ReadPlaneSelect::Plane3);

        //     mov       dx, 0020h
        //     sub       dx, cx
        //     mov       al, bh
        //     cbw
        //     add       di, ax
        //     mov       si, 0100h
        //     mov       bl, cl
        // Label0x37df:                            ;Offset 0x37df
        //     mov       al, byte ptr es:[di - 01h]
        //     mov       cl, bl
        //     rep stosb
        //     add       di, dx
        //     dec       si
        //     jne       Label0x37df               ;Offset 0x37df
        //     mov       dx, VGA_GraphicsControllerIndex;Port 0x3ce
        //     mov       ax, 0004h
        //     out       dx, ax
    }
    // Label0x37f3:                            ;Offset 0x37f3
    //     pop       es
    //     pop       ds
    //     popaw
    //     ret
}

bool Is8Dot()//Offset 0x3fc5
{
    // pushaw
    // mov    dx, VGA_SequenceIndex        ;Port 0x3c4
    // mov    al, VGA_SEQIdx_ClockingMode  ;0x1
    // call   ReadIndexedRegister          ;Offset 0x3f84
    // test   ah, VGA_SEQ1_8DotChar        ;0x1
    // popaw
    // ret
    return (Hag::VGA::Sequencer::ClockingMode::Read() & Hag::VGA::Sequencer::ClockingMode::DotClockSelect) != 0;
}

uint8_t Font8x14Patch[] =
{
    0x1D, 0x00, 0x00, 0x00, 0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x22, 0x00, 0x63, 0x63, 0x63, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2B, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x2D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x4D, 0x00, 0x00, 0xC3, 0xE7, 0xFF, 0xDB, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x00, 0x00, 0x00,
    0x54, 0x00, 0x00, 0xFF, 0xDB, 0x99, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x56, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00,
    0x57, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xDB, 0xDB, 0xFF, 0x66, 0x66, 0x00, 0x00, 0x00,
    0x58, 0x00, 0x00, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0xC3, 0xC3, 0x00, 0x00, 0x00,
    0x59, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
    0x5A, 0x00, 0x00, 0xFF, 0xC3, 0x86, 0x0C, 0x18, 0x30, 0x61, 0xC3, 0xFF, 0x00, 0x00, 0x00,
    0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0xFF, 0xDB, 0xDB, 0xDB, 0xDB, 0x00, 0x00, 0x00,
    0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00,
    0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xC3, 0xDB, 0xDB, 0xFF, 0x66, 0x00, 0x00, 0x00,
    0x91, 0x00, 0x00, 0x00, 0x00, 0x6E, 0x3B, 0x1B, 0x7E, 0xD8, 0xDC, 0x77, 0x00, 0x00, 0x00,
    0x9B, 0x00, 0x18, 0x18, 0x7E, 0xC3, 0xC0, 0xC0, 0xC3, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x9D, 0x00, 0x00, 0xC3, 0x66, 0x3C, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x9E, 0x00, 0xFC, 0x66, 0x66, 0x7C, 0x62, 0x66, 0x6F, 0x66, 0x66, 0xF3, 0x00, 0x00, 0x00,
    0xF1, 0x00, 0x00, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x00, 0xFF, 0x00, 0x00, 0x00,
    0xF6, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00
};

uint8_t Font8x16Patch[] =
{
    0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x00, 0x00, 0x3C, 0x66, 0xC3, 0xC3, 0xDB, 0xDB, 0xC3, 0xC3, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x4D, 0x00, 0x00, 0xC3, 0xE7, 0xFF, 0xFF, 0xDB, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x00, 0x00, 0x00, 0x00,
    0x54, 0x00, 0x00, 0xFF, 0xDB, 0x99, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x56, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x57, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xDB, 0xDB, 0xFF, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x58, 0x00, 0x00, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x66, 0xC3, 0xC3, 0x00, 0x00, 0x00, 0x00,
    0x59, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x5A, 0x00, 0x00, 0xFF, 0xC3, 0x86, 0x0C, 0x18, 0x30, 0x60, 0xC1, 0xC3, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0xFF, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x00, 0x00, 0x00, 0x00,
    0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xDB, 0xDB, 0xFF, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0xC3, 0x00, 0x00, 0x00, 0x00,
    0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6E, 0x3B, 0x1B, 0x7E, 0xD8, 0xDC, 0x77, 0x00, 0x00, 0x00, 0x00,
    0x9B, 0x00, 0x18, 0x18, 0x7E, 0xC3, 0xC0, 0xC0, 0xC0, 0xC3, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x9D, 0x00, 0x00, 0xC3, 0x66, 0x3C, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x9E, 0x00, 0xFC, 0x66, 0x66, 0x7C, 0x62, 0x66, 0x6F, 0x66, 0x66, 0x66, 0xF3, 0x00, 0x00, 0x00, 0x00,
    0xAB, 0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30, 0x60, 0xCE, 0x9B, 0x06, 0x0C, 0x1F, 0x00, 0x00,
    0xAC, 0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xCE, 0x96, 0x3E, 0x06, 0x06, 0x00, 0x00,
    0x00
};

//out: di = patch, bh = charHeight
void GetPatch(uint8_t*& patch, uint8_t& charHeight)//Offset 0x1f29
{
    //     push      cs
    //     pop       es
    //     mov       di, offset Font8x14Patch  ;Offset 0x713a
    patch = Font8x14Patch;

    //     mov       bh, 0eh
    charHeight = 0x0e;

    //     cmp       word ptr ds:[BDA_PointHeightOfCharacterMatrix], 0eh;Offset 0x485
    //     jbe       Label0x1f3c               ;Offset 0x1f3c
    if (Hag::System::BDA::PointHeightOfCharacterMatrix::Get() > 0x0e)
    {
        //     mov       di, Offset Font8x16Patch  ;Offset 0x7267
        patch = Font8x16Patch;

        //     mov       bh, 10h
        charHeight = 0x10;

        // Label0x1f3c:
    }
    //     ret
}

//bl = bankIndex, bh = charHeight, di = patch
void PatchFont(uint8_t bankIndex, uint8_t charHeight, uint8_t* patch)//Offset 0x1f63
{
    uint16_t bankOffset[] =
    {
        0x0000,
        0x4000,
        0x8000,
        0xc000,
        0x2000,
        0x6000,
        0xa000,
        0xe000
    };

    //     push      bx
    //     push      ds
    //     push      es

    //     mov       si, di
    //     push      es
    //     pop       ds
    //     push      bx
    //     sub       bh, bh
    //     shl       bx, 01h
    //     call      GetA000SelectorInES       ;Offset 0x3f4c
    //     mov       di, word ptr cs:[bx + Data0x2257];Offset 0x2257
    uint16_t offset = bankOffset[bankIndex];
    uint8_t* ptr = FARPointer(uint16_t(0xa0000), offset).ToPointer<uint8_t>(256 * 0x20);

    //     pop       bx
    //     mov       dl, 20h
    //     mov       bl, bh
    //     sub       bh, bh
    while (patch[0] != 0)
    {
        // Label0x1f7e:                            ;Offset 0x1f7e
        //     lodsb
        //     test      al, al
        //     je        Label0x1f8f               ;Offset 0x1f8f
        //     push      di
        //     mul       dl
        //     add       di, ax
        //     mov       cx, bx
        //     rep movsb
        memcpy(ptr + patch[0] * 0x20, patch + 1, charHeight);

        //     pop       di
        //     jmp       Label0x1f7e               ;Offset 0x1f7e
        patch += charHeight + 1;
    }
    // Label0x1f8f:                            ;Offset 0x1f8f
    //     pop       es
    //     pop       ds
    //     pop       bx
    //     ret       
}

void Func0x1f05()//Offset 0x1f05
{
    using namespace Hag;
    //     push      dx
    //     mov       dx, VGA_MiscellaneousRead ;Port 0x3cc
    //     in        al, dx
    //     test      al, VGA_Misc_IOAddressSel_CGA;0x1
    //     je        Label0x1f14               ;Offset 0x1f14
    //     mov       dl, VGA_GraphicsControllerIndex_lowbyte;Port 0x3ce
    if ((VGA::MiscellaneousOutput::Read() & VGA::MiscellaneousOutput::IOAddressSelect) == 0)
    {
        //     mov       bx, VGA_GCTLIdx_Miscellaneous OR ((VGA_GCTL6_ChainEven OR VGA_GCTL6_Mem_B0000_B7FFF) SHL 8);0xa06
        //     mov       ax, bx
        //     out       dx, ax
        VGA::GraphicsController::MemoryMapModeControl::Write(VGA::GraphicsController::MemoryMapModeControl::ChainOddEvenPlanes |
                                                             VGA::GraphicsController::MemoryMapModeControl::B0000HtoB7FFFH);
    }
    else
    {
        // Label0x1f14:                            ;Offset 0x1f14
        //     mov       bx, VGA_GCTLIdx_Miscellaneous OR ((VGA_GCTL6_ChainEven OR VGA_GCTL6_Mem_B8000_BFFFF) SHL 8);0xe06
        //     mov       ax, bx
        //     out       dx, ax
        VGA::GraphicsController::MemoryMapModeControl::Write(VGA::GraphicsController::MemoryMapModeControl::ChainOddEvenPlanes |
                                                             VGA::GraphicsController::MemoryMapModeControl::B8000HtoBFFFFH);
    }

    //     mov       ax, VGA_GCTLIdx_GraphicMode OR (VGA_GCTL5_OddEven SHL 8);0x1005
    //     out       dx, ax
    VGA::GraphicsController::GraphicsControllerMode::Write(VGA::GraphicsController::GraphicsControllerMode::OddEvenAddressing);

    //     mov       dl, VGA_SequenceIndex_lowbyte;Port 0x3c4
    //     mov       ax, VGA_SEQIdx_MapMask OR ((VGA_SEQ2_Mask0 OR VGA_SEQ2_Mask1) SHL 8);0x302
    //     out       dx, ax
    VGA::Sequencer::EnableWritePlane::Write(VGA::Sequencer::EnableWritePlane::Plane1 |
                                            VGA::Sequencer::EnableWritePlane::Plane2);

    //     mov       ax, VGA_SEQIdx_MemoryMode OR (VGA_SEQ4_MemSize256k SHL 8);0x204
    //     out       dx, ax
    VGA::Sequencer::MemoryModeControl::Write(VGA::Sequencer::MemoryModeControl::ExtendedMemoryAddress);

    //     pop       dx
    //     ret
}

void FontSetup()//Offset 0x5b8
{
    using namespace Hag;
    using namespace Hag::System;

    //     push      bp
    //     mov       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    //     call      Func0x3faf                ;Offset 0x3faf
    //     jne       Label0x650                ;Offset 0x650
    if (Func0x3faf(BDA::DisplayMode::Get()))
    {
        //     call      Func0x1ee5                ;Offset 0x1ee5
        Func0x1ee5();

        //     les       di, ds:[BDA_VideoParameterControlBlockPtrOfs];Offset 0x4a8
        //     les       di, es:[di + BDA_VPCB_AlphaNumCharSetOverride];Offset 0x8
        //     mov       dx, es
        //     or        dx, di
        //     je        Label0x5f6                ;Offset 0x5f6
        //     lea       si, [di + BDA_ACSO_ApplicableModeList];Offset 0xb
        //     call      CheckModeList             ;Offset 0x6bb
        //     jne       Label0x5f6                ;Offset 0x5f6
        //     mov       ax, 1110h                 ;Text functions - load user specified patterns
        //     mov       bh, byte ptr es:[di + BDA_ACSO_ChardDefLength];Offset 0x0
        //     mov       bl, byte ptr es:[di + BDA_ACSO_RamBankIndex];Offset 0x1
        //     mov       cx, word ptr es:[di + BDA_ACSO_NumCharacters];Offset 0x2
        //     mov       dx, word ptr es:[di + BDA_ACSO_StartIndex];Offset 0x4
        //     les       bp, es:[di + BDA_ACSO_FontData];Offset 0x6
        //     int       10h
        //     jmp       Label0x613                ;Offset 0x613
        // Label0x5f6:                             ;Offset 0x5f6
        //     call      GetFontAndCharHeight      ;Offset 0x1ec8   //out: di = font, bh = charHeight
        uint8_t* font = nullptr;
        uint8_t charHeight = 0;
        GetFontAndCharHeight(font, charHeight);
        //     sub       dx, dx                    ;characterIndex = 0
        //     mov       bl, dl                    ;bankIndex = 0
        //     mov       cx, 0100h                 ;count = 256
        //     call      UploadCharacters          ;Offset 0x1f3d   //in: bl = bankIndex, bh = charHeight, dx = characterIndex, cx = count, di = source data
        UploadCharacters(0, charHeight, 0, 0x100, font);

        //     call      Func0x37b5                ;Offset 0x37b5
        Func0x37b5(0, charHeight, 0);

        //     call      Is8Dot                    ;Offset 0x3fc5
        //     jne       Label0x613                ;Offset 0x613
        if (!Is8Dot())
        {
            //     call      GetPatch                  ;Offset 0x1f29
            uint8_t* patch = nullptr;
            GetPatch(patch, charHeight);
            
            //     sub       bl, bl
            //     call      PatchFont                 ;Offset 0x1f63
            PatchFont(0, charHeight, patch);

            // Label0x613:                             ;Offset 0x613
        }
        //     call      Func0x1f05                ;Offset 0x1f05
        Func0x1f05();

        //     les       di, ds:[BDA_VideoParameterControlBlockPointer];Offset 0x4a8
        //     les       di, es:[di + BDA_VPCB_SecondarySavePointerTbl];Offset 0x10
        //     les       di, es:[di + BDA_SSP_SecondaryAlphaOverr];Offset 0x6
        //     mov       dx, es
        //     or        dx, di
        //     je        Label0x685                ;Offset 0x685
        //     mov       al, byte ptr es:[di + BDA_SACSO_CharDefLength];Offset 0x0
        //     cmp       byte ptr ds:[BDA_PointHeightOfCharacterMatrix], al;Offset 0x485
        //     jne       Label0x685                ;Offset 0x685
        //     lea       si, [di + BDA_SACSO_ApplicableModeLst];Offset 0x7
        //     call      CheckModeList             ;Offset 0x6bb
        //     jne       Label0x685                ;Offset 0x685
        //     mov       ax, 1100h                 ;Text functions - load user specified patterns
        //     mov       bl, byte ptr es:[di + BDA_SACSO_RamBankIndex];Offset 0x1
        //     mov       bh, byte ptr es:[di + BDA_SACSO_CharDefLength]; Offset 0x0
        //     mov       cx, 0100h
        //     sub       dx, dx
        //     les       bp, es:[di + BDA_SACSO_FontData];Offset 0x3
        //     int       10h
        //     jmp       Label0x685                ;Offset 0x685
        // Label0x650:                             ;Offset 0x650
    }
    else
    {
        //     les       di, ds:[BDA_VideoParameterControlBlockPointer];Offset 0x4a8
        //     les       di, es:[di + BDA_VPCB_GrahicsCharSetOverride];Offset 0xc
        //     mov       dx, es
        //     or        dx, di
        //     je        Label0x67a                ;Offset 0x67a
        //     lea       si, [di + BDA_GCSO_ApplicableModeList];Offset 0x7
        //     call      CheckModeList             ;Offset 0x6bb
        //     jne       Label0x67a                ;Offset 0x67a
        //     mov       ax, 1121h                 ;Text functions - set user specified graphics characters
        //     sub       bl, bl
        //     mov       cx, word ptr es:[di + BDA_GCSO_CharDefLength];Offset 0x1
        //     mov       dl, byte ptr es:[di + BDA_GCSO_NumCharacters];Offset 0x0
        //     les       bp, es:[di + BDA_GCSO_FontData];Offset 0x3
        //     int       10h
        //     jmp       Label0x685                ;Offset 0x685
        // Label0x67a:                             ;Offset 0x67a
        //     call      GetFontAndCharHeight      ;Offset 0x1ec8
        uint8_t* font = nullptr;
        uint8_t charHeight = 0;
        GetFontAndCharHeight(font, charHeight);
        
        //     mov       word ptr ds:[INT_43_HandlerOfs], di;Offset 0x10c
        //     mov       word ptr ds:[INT_43_HandlerSeg], es;Offset 0x10e
        //TODO: Set proper font pointer.

        // Label0x685:                             ;Offset 0x685
    }
    //     pop       bp
    //     ret
}

bool ValidMode(Hag::VGA::VideoMode_t mode)//Offset 0x3f8d
{
    // pushaw
    // push   es
    // call   FindModeData                 ;Offset 0x40d9
    ModeData* modeData = nullptr;
    return FindModeData(mode, modeData);
    // lahf
    // test   ah, 01h
    // pop    es
    // popaw
    // ret
}

bool Func0x4152(Hag::VGA::VideoMode_t mode)//Offset 0x4152
{
    // push   ax
    // push   bx
    // push   es
    // and    al, 7fh
    // call   FindModeData                 ;Offset 0x40d9
    ModeData* modeData = nullptr;
    FindModeData(mode, modeData);

    // cmp    byte ptr es:[bx + 04h], 09h
    return modeData->Flags != 9;
    // pop    es
    // pop    bx
    // pop    ax
    // ret
}

bool Func0x3f99(Hag::VGA::VideoMode_t mode)//Offset 0x3f99
{
    //     push   bx
    //     push   es
    //     call   FindModeData                 ;Offset 0x40d9
    //     jb     Label0x3fac                  ;Offset 0x3fac
    ModeData* modeData = nullptr;
    if (FindModeData(mode, modeData))
    {
        //     cmp    byte ptr es:[bx + 04h], 01h
        //     je     Label0x3fac                  ;Offset 0x3fac
        if (modeData->Flags == 0x01)
            return true;
        //     cmp    byte ptr es:[bx + 04h], 03h
        if (modeData->Flags == 0x03)
            return true;
        // Label0x3fac:                            ;Offset 0x3fac
    }
    //     pop    es
    //     pop    bx
    //     ret
    return false;
}

bool SetupBDA(uint8_t mode)//Offset 0x2fc
{
    using namespace Hag;
    using namespace Hag::System;
    //     mov       ah, al
    //     and       ax, (BDA_DM_DONT_CLEAR_SCREEN SHL 8) OR (0ffh XOR BDA_DM_DONT_CLEAR_SCREEN);0x807f
    BDA::VideoModeOptions_t dontClearDisplay = mode & VGA::VideoMode::DontClearDisplay;
    mode &= ~VGA::VideoMode::DontClearDisplay;

    //     call      ValidMode                 ;Offset 0x3f8d
    //     jne       Label0x3cc                ;Offset 0x3cc
    if (ValidMode(mode))
    {
        //     mov       byte ptr ds:[BDA_DisplayMode], al ;Offset 0x449
        BDA::DisplayMode::Get() = mode;

        //     call      Func0x4152                ;Offset 0x4152
        //     je        Label0x3cc                ;Offset 0x3cc
        if (Func0x4152(mode))
        {
            //     mov       cl, byte ptr ds:[BDA_VideoModeOptions];Offset 0x487
            //     and       cl, NOT (BDA_VMO_Inactive OR BDA_VMO_DontClearDisplay);0x77
            //     or        cl, ah
            //     mov       byte ptr ds:[BDA_VideoModeOptions], cl;Offset 0x487
            BDA::VideoModeOptions::Get() =
                (BDA::VideoModeOptions::Get() &
                ~(BDA::VideoModeOptions::Inactive | BDA::VideoModeOptions::DontClearDisplay)) |
                dontClearDisplay;
            
            //     mov       bl, byte ptr ds:[BDA_DetectedHardware];Offset 0x410
            //     mov       bh, bl
            //     and       bx, ((NOT BDA_DH_InitialVideoModeMask) SHL 8) OR BDA_DH_InitialVideoModeMask;0xcf30
            BDA::DetectedHardware_t initialVideoMode = BDA::DetectedHardware::Get() & BDA::DetectedHardware::InitialVideoModeMask;
            BDA::DetectedHardware_t detectedHardware = BDA::DetectedHardware::Get() & ~BDA::DetectedHardware::InitialVideoModeMask;

            //     mov       dx, VGA_CRTControllerIndexB;Port 0x3b4
            VGA::Register_t crtControllerIndex = VGA::Register::CRTControllerIndexB;

            //     test      byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_VGA;Offset 0x489 0x1
            //     je        Label0x36a                ;Offset 0x36a
            if ((BDA::VideoDisplayDataArea::Get() & BDA::VideoDisplayDataArea::VGA) != 0)
            {
                //     or        bh, BDA_DH_80x25Monochrome;0x30
                detectedHardware |= BDA::DetectedHardware::Monochrome80x25;

                //     mov       bl, BDA_EFBS_CGAMono80x25_2;0xb
                BDA::EGAFeatureBitSwitches_t egaFeatureBitSwitches = BDA::EGAFeatureBitSwitches::CGAMono80x25_2;

                //     or        byte ptr ds:[BDA_VideoModeOptions], BDA_VMO_Monochrome;Offset 0x487 0x2
                BDA::VideoModeOptions::Get() |= BDA::VideoModeOptions::Monochrome;

                //     call      Func0x3f99                ;Offset 0x3f99
                //     je        Label0x357                ;Offset 0x357
                if (!Func0x3f99(mode))
                {
                    //     and       byte ptr ds:[BDA_VideoModeOptions], NOT BDA_VMO_Monochrome;Offset 0x487 0xfd
                    BDA::VideoModeOptions::Get() &= ~BDA::VideoModeOptions::Monochrome;

                    //     mov       dl, VGA_CRTControllerIndexD_lowbyte;Port 0x3d4
                    crtControllerIndex = VGA::Register::CRTControllerIndexD;

                    //     and       bh, NOT BDA_DH_40x25Color ;0xef
                    detectedHardware &= ~BDA::DetectedHardware::Color40x25;

                    //     mov       bl, BDA_EFBS_MDAHiRes80x25_2;0x8
                    egaFeatureBitSwitches = BDA::EGAFeatureBitSwitches::MDAHiRes80x25_2;

                    //     test      byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_LineMode200;Offset 0x489 0x80
                    //     jne       Label0x357                ;Offset 0x357
                    if ((BDA::VideoDisplayDataArea::Get() & BDA::VideoDisplayDataArea::LineMode200) == 0)
                    {
                        //     mov       bl, BDA_EFBS_MDAHiResEnhanced_2;0x9
                        egaFeatureBitSwitches = BDA::EGAFeatureBitSwitches::MDAHiResEnhanced_2;

                        // Label0x357:                             ;Offset 0x357
                    }
                }
                //     mov       word ptr ds:[BDA_VideoBaseIOPort], dx;Offset 0x463
                BDA::VideoBaseIOPort::Get() = crtControllerIndex;

                //     mov       byte ptr ds:[BDA_DetectedHardware], bh;Offset 0x410
                BDA::DetectedHardware::Get() = detectedHardware;

                //     and       byte ptr ds:[BDA_EGAFeatureBitSwitches], NOT BDA_EFBS_AdapterTypeMask;Offset 0x488 0xf0
                BDA::EGAFeatureBitSwitches::Get() &= BDA::EGAFeatureBitSwitches::FeatureConnectorMask;

                //     or        byte ptr ds:[BDA_EGAFeatureBitSwitches], bl;Offset 0x488
                BDA::EGAFeatureBitSwitches::Get() |= egaFeatureBitSwitches;

                //     jmp       Label0x3b1                ;Offset 0x3b1
                // Label0x36a:                             ;Offset 0x36a
            }
            else
            {
                //     call      Func0x3f99                ;Offset 0x3f99
                //     je        Label0x391                ;Offset 0x391
                if (!Func0x3f99(mode))
                {
                    //     cmp       bl, 30h
                    //     je        Label0x381                ;Offset 0x381
                    if (initialVideoMode != BDA::DetectedHardware::Monochrome80x25)
                    {
                        //     mov       dl, VGA_CRTControllerIndexD_lowbyte;Port 0x3d4
                        crtControllerIndex = VGA::Register::CRTControllerIndexD;

                        //     test      cl, 02h
                        //     jne       Label0x3b3                ;Offset 0x3b3
                        if ((BDA::VideoModeOptions::Get() & BDA::VideoModeOptions::Monochrome) == 0)
                        {
                            //     mov       word ptr ds:[BDA_VideoBaseIOPort], dx;Offset 0x463
                            BDA::VideoBaseIOPort::Get() = crtControllerIndex;

                            //     jmp       Label0x3b1                ;Offset 0x3b1
                            return true;
                        }
                        else
                        {
                            // Label0x3b3:                             ;Offset 0x3b3
                            //     cbw
                            //     mov       bl, 0eh
                            //     cmp       al, 07h
                            //     je        Label0x3bc                ;Offset 0x3bc
                            //     mov       bl, 08h
                            // Label0x3bc:                             ;Offset 0x3bc
                            //     mov       byte ptr ds:[BDA_RowsOnScreen], 18h;Offset 0x484 0x18
                            //     mov       byte ptr ds:[BDA_PointHeightOfCharacterMatrix], bl;Offset 0x485
                            //     or        byte ptr ds:[BDA_VideoModeOptions], BDA_VMO_Inactive;Offset 0x487 0x8
                            //     int       42h
                            return false;
                        }
                        // Label0x381:                             ;Offset 0x381
                    }
                    else
                    {
                        //     test      cl, 02h
                        //     je        Label0x3b3                ;Offset 0x3b3
                        if ((BDA::VideoModeOptions::Get() & BDA::VideoModeOptions::Monochrome) == 0)
                        {
                            //     mov       al, BDA_DM_80x25_Monochrome_Text;0x7
                            //     mov       byte ptr ds:[BDA_DisplayMode], al;Offset 0x449
                            BDA::DisplayMode::Get() = VGA::VideoMode::T80x25x1bppM;

                            //     mov       word ptr ds:[BDA_VideoBaseIOPort], dx;Offset 0x463
                            BDA::VideoBaseIOPort::Get() = crtControllerIndex;

                            //     jmp       Label0x3b1                ;Offset 0x3b1
                            return true;
                        }
                        else
                        {
                            // Label0x3b3:                             ;Offset 0x3b3
                            //     cbw
                            //     mov       bl, 0eh
                            //     cmp       al, 07h
                            //     je        Label0x3bc                ;Offset 0x3bc
                            //     mov       bl, 08h
                            // Label0x3bc:                             ;Offset 0x3bc
                            //     mov       byte ptr ds:[BDA_RowsOnScreen], 18h;Offset 0x484 0x18
                            //     mov       byte ptr ds:[BDA_PointHeightOfCharacterMatrix], bl;Offset 0x485
                            //     or        byte ptr ds:[BDA_VideoModeOptions], BDA_VMO_Inactive;Offset 0x487 0x8
                            //     int       42h
                            return false;
                        }
                        // Label0x391:                             ;Offset 0x391
                    }
                }
                //     cmp       bl, 30h
                //     jne       Label0x3a1                ;Offset 0x3a1
                if (initialVideoMode == BDA::DetectedHardware::Monochrome80x25)
                {
                    //     test      cl, 02h
                    //     je        Label0x3b3                ;Offset 0x3b3
                    //     mov       word ptr ds:[BDA_VideoBaseIOPort], dx;Offset 0x463
                    //     jmp       Label0x3b1                ;Offset 0x3b1
                    return true;
                    // Label0x3a1:                             ;Offset 0x3a1
                }

                //     test      cl, 02h
                //     jne       Label0x3b3                ;Offset 0x3b3
                if ((BDA::VideoModeOptions::Get() & BDA::VideoModeOptions::Monochrome) != 0)
                {
                    //     sub       al, al                    ;BDA_DM_40x25_BW_Text
                    //     mov       byte ptr ds:[BDA_DisplayMode], al;Offset 0x449
                    BDA::DisplayMode::Get() = VGA::VideoMode::T40x25x4bppG;

                    //     mov       word ptr ds:[BDA_VideoBaseIOPort], VGA_CRTControllerIndexD;Offset 0x463 Port 0x3d4
                    BDA::VideoBaseIOPort::Get() = VGA::Register::CRTControllerDataD;

                    // Label0x3b1:                             ;Offset 0x3b1
                }
                else
                {
                    // Label0x3b3:                             ;Offset 0x3b3
                    //     cbw
                    //     mov       bl, 0eh
                    //     cmp       al, 07h
                    //     je        Label0x3bc                ;Offset 0x3bc
                    //     mov       bl, 08h
                    // Label0x3bc:                             ;Offset 0x3bc
                    //     mov       byte ptr ds:[BDA_RowsOnScreen], 18h;Offset 0x484 0x18
                    //     mov       byte ptr ds:[BDA_PointHeightOfCharacterMatrix], bl;Offset 0x485
                    //     or        byte ptr ds:[BDA_VideoModeOptions], BDA_VMO_Inactive;Offset 0x487 0x8
                    //     int       42h
                    return false;
                }
            }
            //     clc
            //     ret
            return true;

            // Label0x3cc:                             ;Offset 0x3cc
        }
    }
    //     stc
    //     ret
    return false;
}

void OutputListOfIndexedRegisters()//Offset 0x40a0
{
    // Label0x40a0:                            ;Offset 0x40a0
    //     mov    ah, bl
    //     lodsb
    //     xchg   al, ah
    //     out    dx, ax
    //     inc    bx
    //     loop   Label0x40a0                  ;Offset 0x40a0
    //     ret
}

void ApplyModeSettingsToVGARegisters(Hag::System::BDA::VideoParameterTable& parameters)//Offset 0x431
{
    using namespace Hag;
    using namespace Hag::System;

    // push      di
    // push      ds
    // push      es
    // mov       si, di
    // push      es
    // pop       ds
    // mov       dx, VGA_SequenceIndex     ;Port 0x3c4
    // mov       ax, VGA_SEQIdx_Reset OR (VGA_SEQ0_AsyncReset SHL 8);0x100
    // out       dx, ax
    VGA::Sequencer::Reset::Write(VGA::Sequencer::Reset::AsynchronousReset);
    
    // mov       dl, VGA_MiscellaneousWrite_lowbyte;Port 0x3c2
    // mov       al, byte ptr [si + 09h]
    // out       dx, al
    VGA::MiscellaneousOutput::Write(parameters.MiscellaneousOutputRegister);

    // mov       dl, VGA_SequenceIndex_lowbyte;Port 0x3c4
    // push      si
    // mov       cx, 0004h
    // mov       bl, 01h
    // lea       si, [si + 05h]
    // call      OutputListOfIndexedRegisters;Offset 0x40a0
    VGA::SequencerData::Write(VGA::Sequencer::Register::ClockingMode, parameters.SequencerRegisters, sizeof(parameters.SequencerRegisters));

    // pop       si
    // mov       ax, VGA_SEQIdx_Reset OR ((VGA_SEQ0_AsyncReset OR VGA_SEQ0_SyncReset) SHL 8);0x300
    // out       dx, ax
    VGA::Sequencer::Reset::Write(VGA::Sequencer::Reset::AsynchronousReset | VGA::Sequencer::Reset::SynchronousReset);

    // push      ds
    // call      GetBIOSDataSelectorInDS   ;Offset 0x3f40
    // mov       dx, word ptr ds:[BDA_VideoBaseIOPort];Offset 0x463
    // pop       ds
    // mov       ax, VGA_CRTCIdx_VertRetraceEnd OR (20h SHL 8);0x2011 Unlock CRTC registers 0-7
    // out       dx, ax
    VGA::CRTController::VerticalRetraceEnd::Write(BDA::VideoBaseIOPort::Get(), VGA::CRTController::VerticalRetraceEnd::DisableVerticalInterrupt);
    
    // sub       bl, bl
    // mov       cx, 0019h
    // push      si
    // lea       si, [si + 0ah]
    // call      OutputListOfIndexedRegisters;Offset 0x40a0
    VGA::CRTControllerData::Write(BDA::VideoBaseIOPort::Get(), VGA::CRTController::Register::HorizontalTotal, parameters.CRTCRegisters, sizeof(parameters.CRTCRegisters));

    // pop       si
    // mov       dl, VGA_GraphicsControllerIndex_lowbyte;Port 0x3ce
    // sub       bl, bl
    // mov       cx, 0009h
    // push      si
    // lea       si, [si + 37h]
    // call      OutputListOfIndexedRegisters;Offset 0x40a0
    VGA::GraphicsControllerData::Write(VGA::GraphicsController::Register::SetResetData, parameters.GraphicsControllerRegisters, sizeof(parameters.GraphicsControllerRegisters));

    // pop       si
    // mov       dl, VGA_FeatureControlWD_lowbyte;Offset 0x3da
    // sub       al, al
    // out       dx, al
    VGA::FeatureControl::Write(VGA::Register::FeatureControlWD, 0);

    // pop       es
    // pop       ds
    // pop       di
    // ret
}

void SetVideoMode(uint8_t mode)//Offset 0x02C2
{
    using namespace Hag::System;

    //     pushaw
    //     push      es

    //     call      SetupBDA                  ;Offset 0x2fc
    //     jb        Label0x2f7                ;Offset 0x2f7
    if (SetupBDA(mode))
    {
        //     mov       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
        mode = BDA::DisplayMode::Get();

        //     call      GetVideoParameterTable                ;Offset 0x35a7
        BDA::VideoParameterTable& parameters = GetVideoParameterTable();

        //     call      ApplyModeSettingsToBDA    ;Offset 0x3d6
        ApplyModeSettingsToBDA(parameters);

        //     call      DisableAttributeControllerPaletteOutput;Offset 0x407d
        DisableAttributeControllerPaletteOutput();

        //     call      SetupExtensionsAndMemoryConfig                ;Offset 0x3615
        SetupExtensionsAndMemoryConfig();

        //     call      ApplyModeSettingsToVGARegisters;Offset 0x431
        ApplyModeSettingsToVGARegisters(parameters);

        //     call      TurnScreenOff             ;Offset 0x3f6a
        TurnScreenOff();

        //     call      PaletteSetup                 ;Offset 0x48a
        PaletteSetup(parameters);

        //     call      ConfigureExtensionRegisters                ;Offset 0x363c
        ConfigureExtensionRegisters();

        //     call      FontSetup                 ;Offset 0x5b8
        FontSetup();

        //     test      byte ptr ds:[BDA_VideoModeOptions], BDA_VMO_DontClearDisplay;Offset 0x487 0x80
        //     jne       Label0x2f1                ;Offset 0x2f1
        if ((BDA::VideoModeOptions::Get() & BDA::VideoModeOptions::DontClearDisplay) == 0)
        {
            //     call      ClearScreen               ;Offset 0x3740
            ClearScreen();

            // Label0x2f1:                             ;Offset 0x2f1
        }

        //     call      TurnScreenOn              ;Offset 0x3f77
        TurnScreenOn();

        //     call      EnableAttributeControllerPaletteOutput;Offset 0x408d
        EnableAttributeControllerPaletteOutput();

        // Label0x2f7:                             ;Offset 0x2f7
    }
    //     pop       es
    //     popaw
    //     pop       ds
    //     pop       si
    //     iret
}

// inputs:
//    ax = VESA mode

bool FindVESAModeData(Hag::Vesa::VideoMode_t mode, ModeData*& modeData)//Offset 0x41a9
{
    modeData = nullptr;

    //     call   FetchCustomDataPointer       ;Offset 0x40f6
    //     les    bx, es:[bx + 04h]
    // Find:                                   ;Offset 0x41b0
    //     cmp    byte ptr es:[bx], 0ffh
    //     je     NotFound                     ;Offset 0x41c3
    //     cmp    word ptr es:[bx + 02h], ax
    //     je     Found                        ;Offset 0x41c1
    //     add    bx, 000eh
    //     jmp    Find                         ;Offset 0x41b0
    // Found:                                  ;Offset 0x41c1
    //     clc
    //     ret
    for (uint32_t i = 0; i < sizeof(s_ModeData) / sizeof(ModeData); ++i)
    {
        if (mode == s_ModeData[i].VesaMode)
        {
            modeData = &s_ModeData[i];
            return true;
        }
    }

    // NotFound:                               ;Offset 0x41c3
    //     sub    bx, bx
    //     stc
    //     ret
    return false;

}


// inputs:
//    ax = mode

// outputs:
//    al = legacy mode (byte)
//    ah = extra data index

bool Func0x41ce(Hag::Vesa::VideoMode_t vesaMode, Hag::VGA::VideoMode_t& mode, uint8_t& extraDataIndex)//Offset 0x41ce
{
    bool ret = false;
    //     push   bx
    //     push   es
    mode = 0xff;
    extraDataIndex = 0xff;

    ModeData* modeData = nullptr;
    //     call   FindVESAModeData             ;Offset 0x41a9
    if (FindVESAModeData(vesaMode, modeData))
    {
        ret = true;

        //     mov    ax, 0ffffh
        //     jb     Label0x41df                  ;Offset 0x41df

        //     mov    al, byte ptr es:[bx]
        mode = modeData->LegacyMode;

        //     mov    ah, byte ptr es:[bx + 01h]
        extraDataIndex = modeData->OtherTableIndex;

        // Label0x41df:                            ;Offset 0x41df
    }
    //     pop    es
    //     pop    bx
    //     ret
    return ret;
}

//Check to see if there's enough memory for the mode.
bool Func0x3863(Hag::VGA::VideoMode_t mode)//Offset 0x3863
{
    //     pushaw
    //     push      es
    //     call      FindModeData              ;Offset 0x40d9
    //     jb        Label0x3886               ;Offset 0x3886
    ModeData* modeData = nullptr;
    if (FindModeData(mode, modeData))
    {
        //     mov       ax, word ptr es:[bx + 0bh];Bytes per scanline
        //     mul       word ptr es:[bx + 09h]    ;Height in pixels or chars
        //     mov       cx, 8000h
        //     div       cx
        //     add       dx, 0ffffh
        //     adc       ax, 0000h
        //     xchg      ax, dx
        uint16_t sizeIn32KBlocks = ((modeData->Stride * modeData->Height) + 32767) / 0x8000;

        //     call      GetMemorySizeIn256KBlocks ;Offset 0x37fc
        uint16_t systemMem = GetMemorySizeIn256KBlocks();

        //     shl       ax, 03h
        //     cmp       ax, dx
        return sizeIn32KBlocks < (systemMem << 3);

        // Label0x3886:                            ;Offset 0x3886
    }
    //     pop       es
    //     popaw
    //     ret
    return false;
}

void Func0x3824()//Offset 0x3824
{
    using namespace Hag::System;
    using namespace Hag::TDfx;
    // push      ax
    // push      dx
    // call      GetCRTControllerIndexPort ;Offset 0x40aa
    // mov       al, TDFX_CRTC_ExtensionByte1;0x1d
    // call      ReadIndexedRegister       ;Offset 0x3f84
    // or        ah, 80h
    // out       dx, ax
    Shared::CRTController::Extension1::Write(BDA::VideoBaseIOPort::Get(),
        Shared::CRTController::Extension1::Read(BDA::VideoBaseIOPort::Get()) |
        0x80);
    // pop       dx
    // pop       ax
    // ret
}

uint32_t CalculatePLLFrequency(uint8_t N, uint8_t M, uint8_t K)//Offset 0x3ee4
{//fout = 14.31818 * (N + 2) / (M + 2) / (2 ^ K)
    // push   bx
    // push   ecx
    // push   edx
    // add    bh, 02h
    //M + 2;

    // add    ch, 02h
    //N + 2;

    // mov    cl, bl
    // mov    bl, 01h
    // shl    bl, cl
    //2 << K;
    
    // mov    eax, 00da7a64h
    //14318180;

    // movzx  edx, ch
    // imul   edx
    //14318180 * (N + 2);

    // movzx  ecx, bh
    // idiv   ecx
    //(14318180 * (N + 2)) / (M + 2);

    // sub    edx, edx
    // movzx  ecx, bl
    // idiv   ecx
    //((14318180 * (N + 2)) / (M + 2)) / (2 << K);

    // pop    edx
    // pop    ecx
    // pop    bx
    // ret
    return uint32_t(((uint64_t(14318180) * (N + 2)) / (M + 2)) / (1 << K));
}

uint32_t Func0x3e83(uint32_t frequency)//Offset 0x3e83
{
    REGS r;
    memset(&r, 0, sizeof(r));
    r.d.eax = frequency;
    bool aboveOrEqual = false;

    //     mov    ebp, eax
    r.d.ebp = r.d.eax;

    //     mov    esi, 0ffffffffh
    r.d.esi = 0xffffffff;

    //     sub    ebx, ebx
    r.d.ebx = 0;

    //     mov    ecx, ebx
    r.d.ecx = 0;

    //     sub    bl, bl
    r.h.bl = 0; // not needed.

    // Label0x3e94:                            ;Offset 0x3e94
    Label0x3e94:

    //     cmp    bl, 04h
    //     jae    Label0x3ed2                  ;Offset 0x3ed2
    if (r.h.bl >= 0x04)
        goto Label0x3ed2;

    //     sub    bh, bh
    r.h.bh = 0;

    // Label0x3e9b:                            ;Offset 0x3e9b
    Label0x3e9b:

    //     cmp    bh, 40h
    //     jae    Label0x3ece                  ;Offset 0x3ece
    if (r.h.bh >= 0x40)
        goto Label0x3ece;

    //     sub    ch, ch
    r.h.ch = 0;

    // Label0x3ea2:                            ;Offset 0x3ea2
    Label0x3ea2:

    //     cmp    ch, 0fdh
    //     jae    Label0x3eca                  ;Offset 0x3eca
    if (r.h.ch >= 0xfd)
        goto Label0x3eca;

    //     call   CalculatePLLFrequency        ;Offset 0x3ee4
    r.d.eax = CalculatePLLFrequency(r.h.ch, r.h.bh, r.h.bl);

    //     sub    eax, ebp
    aboveOrEqual = r.d.eax >= r.d.ebp;
    r.d.eax -= r.d.ebp;

    //     jae    Label0x3eb2                  ;Offset 0x3eb2
    if (aboveOrEqual)
        goto Label0x3eb2;
    //     neg    eax
    r.d.eax = ~r.d.eax;

    // Label0x3eb2:                            ;Offset 0x3eb2
    Label0x3eb2:

    //     cmp    esi, eax
    //     jb     Label0x3ec6                  ;Offset 0x3ec6
    if (r.d.esi < r.d.eax)
        goto Label0x3ec6;

    //     mov    esi, eax
    r.d.esi = r.d.eax;

    //     push   bx
    //     shl    ebx, 10h
    //     pop    bx
    r.d.ebx = (r.d.ebx << 16) | r.w.bx;

    //     push   cx
    //     shl    ecx, 10h
    //     pop    cx
    r.d.ecx = (r.d.ecx << 16) | r.w.cx;

    // Label0x3ec6:                            ;Offset 0x3ec6
    Label0x3ec6:

    //     inc    ch
    ++r.h.ch;

    //     jmp    Label0x3ea2                  ;Offset 0x3ea2
    goto Label0x3ea2;

    // Label0x3eca:                            ;Offset 0x3eca
    Label0x3eca:

    //     inc    bh
    ++r.h.bh;

    //     jmp    Label0x3e9b                  ;Offset 0x3e9b
    goto Label0x3e9b;

    // Label0x3ece:                            ;Offset 0x3ece
    Label0x3ece:

    //     inc    bl
    ++r.h.bl;
    //     jmp    Label0x3e94                  ;Offset 0x3e94
    goto Label0x3e94;

    // Label0x3ed2:                            ;Offset 0x3ed2
    Label0x3ed2:

    //     shr    ebx, 10h
    r.d.ebx >>= 16;

    //     shr    ecx, 10h
    r.d.ecx >>= 16;

    //     mov    al, bl
    r.h.al = r.h.bl;

    //     shl    bh, 02h
    r.h.bh <<= 2;

    //     or     al, bh
    r.h.al |= r.h.bh;

    //     mov    ah, ch
    r.h.ah = r.h.ch;

    //     ret
    return r.d.eax;
}

void SetAndSelectVideoPLL(uint32_t frequency)//Offset 0x3e64
{
    using namespace Hag;
    using namespace Hag::TDfx;
    // pushad
    // call   Func0x3e83                   ;Offset 0x3e83
    uint32_t pllControl0 = Func0x3e83(frequency);

    // call   GetIOBaseAddress             ;Offset 0x3d69
    uint16_t baseAddress = GetIOBaseAddress();

    // add    dx, TDFX_IO_PLLControl0      ;0x40
    // and    eax, 0000ffffh
    // out    dx, eax
    Shared::IO::PLLControl0::Write(baseAddress, pllControl0 & 0xffff);

    // mov    dx, VGA_MiscellaneousRead    ;Port 0x3cc
    // in     al, dx
    // or     al, VGA_MISC_ClockSelectMask ;0xc
    // mov    dl, VGA_MiscellaneousWrite_lowbyte;Port 0x3c2
    // out    dx, al
    VGA::MiscellaneousOutput::Write(
        VGA::MiscellaneousOutput::Read() |
        VGA::MiscellaneousOutput::ClockSelect);

    // popad
    // ret
}

uint8_t GetBitsPerPixel(Hag::VGA::VideoMode_t mode)//Offset 0x417c
{
    //     push   bx
    //     push   es
    //     call   FindModeData                 ;Offset 0x40d9
    uint8_t bpp = 0;
    ModeData* modeData = nullptr;
    if (FindModeData(mode, modeData))
    {
        //     mov    al, 00h
        //     jb     Label0x4189                  ;Offset 0x4189
        //     mov    al, byte ptr es:[bx + 06h]
        bpp = modeData->BitsPerPixel;
        // Label0x4189:                            ;Offset 0x4189
    }
    //     pop    es
    //     pop    bx
    //     ret
    return bpp;
}

void Func0x39cd()//Offset 0x39cd
{
    using namespace Hag;
    using namespace Hag::System;

    //     pushad
    //     mov    dx, word ptr ds:[BDA_VideoBaseIOPort];Offset 0x463
    //     mov    ax, VGA_CRTCIdx_VertRetraceEnd OR (VGA_VRE_DisableVertRetrIntr SHL 8);0x2011
    //     out    dx, ax
    VGA::CRTController::VerticalRetraceEnd::Write(BDA::VideoBaseIOPort::Get(), VGA::CRTController::VerticalRetraceEnd::DisableVerticalInterrupt);

    //     mov    al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    //     call   GetBitsPerPixel              ;Offset 0x417c
    //     cmp    al, 8                        ;0x8 //bits per pixel
    //     jb     Label0x3af4                  ;Offset 0x3af4
    if (GetBitsPerPixel(BDA::DisplayMode::Get()) >= 8)
    {
        //     mov    eax, dword ptr es:[di + 0dh]
        //     call   SetAndSelectVideoPLL         ;Offset 0x3e64
        //     mov    ax, word ptr es:[di]
        //     shr    ax, 03h
        //     sub    ax, 05h
        //     mov    ch, ah
        //     and    ch, 01h
        //     shl    ax, 08h
        //     out    dx, ax
        //     mov    bh, ah
        //     add    bh, 03h
        //     mov    al, 03h
        //     call   ReadIndexedRegister          ;Offset 0x3f84
        //     push   bx
        //     and    bh, 1fh
        //     and    ah, 0e0h
        //     or     ah, bh
        //     out    dx, ax
        //     mov    ax, word ptr es:[di + 02h]
        //     shr    ax, 03h
        //     bt     ax, 08h
        //     setb   cl
        //     shl    cl, 06h
        //     or     ch, cl
        //     mov    ah, al
        //     mov    al, 04h
        //     out    dx, ax
        //     mov    bx, word ptr es:[di + 04h]
        //     shr    bx, 03h
        //     mov    al, 05h
        //     call   ReadIndexedRegister          ;Offset 0x3f84
        //     and    ah, 60h
        //     and    bl, 1fh
        //     or     ah, bl
        //     pop    bx
        //     and    bh, 20h
        //     shl    bh, 02h
        //     or     ah, bh
        //     out    dx, ax
        //     mov    al, 1ah
        //     call   ReadIndexedRegister          ;Offset 0x3f84
        //     and    ah, 3ch
        //     or     ah, ch
        //     out    dx, ax
        //     mov    ax, word ptr es:[di + 06h]
        //     dec    ax
        //     dec    ax
        //     mov    ch, ah
        //     and    ch, 01h
        //     bt     ax, 09h
        //     setb   cl
        //     shl    cl, 05h
        //     or     ch, cl
        //     mov    bh, ah
        //     and    bh, 04h
        //     shr    bh, 02h
        //     mov    ah, al
        //     mov    al, 06h
        //     out    dx, ax
        //     mov    al, 16h
        //     sub    ah, 02h
        //     out    dx, ax
        //     mov    ax, word ptr es:[di + 08h]
        //     bt     ax, 08h
        //     setb   cl
        //     shl    cl, 02h
        //     or     ch, cl
        //     bt     ax, 09h
        //     setb   cl
        //     shl    cl, 07h
        //     or     ch, cl
        //     bt     ax, 0ah
        //     setb   cl
        //     shl    cl, 06h
        //     or     bh, cl
        //     mov    ah, al
        //     mov    al, 10h
        //     out    dx, ax
        //     mov    al, 07h
        //     call   ReadIndexedRegister          ;Offset 0x3f84
        //     and    ah, 5ah
        //     or     ah, ch
        //     out    dx, ax
        //     mov    al, 1bh
        //     call   ReadIndexedRegister          ;Offset 0x3f84
        //     and    ah, 3ch
        //     or     ah, bh
        //     out    dx, ax
        //     mov    ah, byte ptr es:[di + 0ah]
        //     and    ah, 0fh
        //     or     ah, 20h
        //     mov    al, 11h
        //     out    dx, ax
        //     mov    ah, byte ptr es:[di + 0ch]
        //     and    ah, 0ch
        //     shl    ah, 04h
        //     mov    dl, 0cch
        //     in     al, dx
        //     and    al, 3fh
        //     or     al, ah
        //     mov    dl, 0c2h
        //     out    dx, al
        //     call   GetIOBaseAddress             ;Offset 0x3d69
        //     add    dx, TDFX_IO_VideoProcessorConfig;0x5c
        //     in     eax, dx
        //     mov    bl, byte ptr es:[di + 0ch]
        //     and    bl, 02h
        //     shl    bl, 02h
        //     out    dx, eax
        // Label0x3af4:                            ;Offset 0x3af4
    }
    //     popad
    //     ret
}

bool SetSuperVGAVideoMode(Hag::Vesa::VideoMode_t vesaMode)//Offset 0x2d4c
{
    using namespace Hag;
    using namespace Hag::System;

    REGS r;
    memset(&r, 0, sizeof(r));

    bool ret = false;
    VGA::VideoMode_t legacyMode = 0;
    uint8_t extraIndex = 0;
    
    r.w.bx = vesaMode;

    //     push      bx
    //     push      cx
    //     push      dx
    //     mov       ax, bx
    r.w.ax = r.w.bx;

    //     and       ah, 07h
    r.h.ah &= 0x7;

    //     cmp       ax, 0100h
    //     jb        Label0x2d5e               ;Offset 0x2d5e
    if (r.w.ax < 0x100)
        goto Label0x2d5e;

    //     call      Func0x41ce                ;Offset 0x41ce
    //     jb        Label0x2d8d               ;Offset 0x2d8d
    if (!Func0x41ce(vesaMode, legacyMode, extraIndex))
        goto Label0x2d8d;
    
    r.h.al = legacyMode;
    r.h.ah = extraIndex;

    // Label0x2d5e:                            ;Offset 0x2d5e
    Label0x2d5e:

    //     call      Func0x3863                ;Offset 0x3863
    //     jb        Label0x2d8d               ;Offset 0x2d8d
    if (!Func0x3863(legacyMode))
        goto Label0x2d8d;

    //     push      ax
    //     push      bx
    //     and       bh, 80h
    //     or        al, bh
    //     sub       ah, ah
    //     int       10h
    //     pop       bx
    //     pop       ax
    SetVideoMode(r.h.al | (r.h.bh & 0x80));

    //     cmp       byte ptr ds:[BDA_DisplayMode], al;Offset 0x449
    //     jne       Label0x2d8d               ;Offset 0x2d8d
    if (BDA::DisplayMode::Get() != r.h.al)
        goto Label0x2d8d;

    //     test      bh, 40h
    //     je        Label0x2d7e               ;Offset 0x2d7e
    if ((r.h.bh & 0x40) == 0)
        goto Label0x2d7e;

    //     call      Func0x3824                ;Offset 0x3824
    Func0x3824();

    // Label0x2d7e:                            ;Offset 0x2d7e
    Label0x2d7e:

    //     test      bh, 08h
    //     je        Label0x2d86               ;Offset 0x2d86
    //if ((r.h.bh & 0x8) == 0)
        //goto Label0x2d86;

    //     call      Func0x39cd                ;Offset 0x39cd
    //Func0x39cd();

    // Label0x2d86:                            ;Offset 0x2d86
    //Label0x2d86:

    //     mov       ax, 004fh
    ret = true;

    // Label0x2d89:                            ;Offset 0x2d89
    Label0x2d89:
    //     pop       dx
    //     pop       cx
    //     pop       bx
    //     ret
    return ret;

    // Label0x2d8d:                            ;Offset 0x2d8d
    Label0x2d8d:
    ret = false;
    //     mov       ax, 014fh
    //     jmp       Label0x2d89               ;Offset 0x2d89
    goto Label0x2d89;
}


namespace CPP
{

void ConfigureExtensionRegisters(Hag::System::PCI::Device_t device, ModeData* modeData, ExtraModeData* extraModeData)//Offset 0x363c
{
    using namespace Hag::System;
    using namespace Hag::TDfx;

    PCI::Write16(device, PCI::PreHeader::Command,
    PCI::Read16(device, PCI::PreHeader::Command) & ~PCI::Command::VGAPaletteSnoop);
    
    Shared::CRTController::HorizontalExtension::Write(BDA::VideoBaseIOPort::Get(), 0);
    Shared::CRTController::VerticalExtension::Write(BDA::VideoBaseIOPort::Get(), extraModeData->VerticalExtension);

    Shared::CRTController::Extension1::Write(BDA::VideoBaseIOPort::Get(),
        Shared::CRTController::Extension1::Read(BDA::VideoBaseIOPort::Get()) & 0x7f);

    uint16_t baseAddress = GetIOBaseAddress();

    if (extraModeData->PLLControl0 != 0)
        Shared::IO::PLLControl0::Write(baseAddress, extraModeData->PLLControl0);

    Shared::IO::DACMode::Write(baseAddress, 0);
    Shared::IO::VideoDesktopStartAddress::Write(baseAddress, 0);
    Shared::IO::VideoScreenSize::Write(baseAddress,
        modeData->Height << (((extraModeData->Unknown0 & 0x4) != 0) ? 13 : 12) |
        (modeData->Width & Shared::VideoScreenSize::Width));
    Shared::IO::VideoDesktopOverlayStride::Write(baseAddress, modeData->Stride);

    Shared::IO::VGAInit0::Write(baseAddress,
        (Shared::IO::VGAInit0::Read(baseAddress) & Shared::VGAInit0::WakeUpSelect) |
        (uint32_t(extraModeData->Unknown0 & 1) << 12) | //Extended video shift out
        Shared::VGAInit0::ExtensionsEnabled);

    Shared::IO::VGAInit1::Write(baseAddress, uint32_t(extraModeData->Unknown0 & 1) << 20);

    uint32_t val = (extraModeData->Unknown0 & 0x38) << 0xf;//Pixel format

    if ((extraModeData->Unknown0 & 1) != 0)
    {
        val |= 0x81;//Video processor on, fetch desktop surface.

        if ((extraModeData->Unknown0 & 0x38) != 0)//If other than 8bit palettized
            val |= 0x0c00;  //bypass clut for desktop and overlay

        val |= (extraModeData->Unknown0 & 0x06) << 2;//interlace and half mode
    }

    Shared::IO::VideoProcessorConfiguration::Write(baseAddress, val);

    Shared::IO::DRAMInit1::Write(baseAddress,
        Shared::IO::DRAMInit1::Read(baseAddress) |
        Shared::DRAMInit1::SGRAMRefreshEnable);
}

}

#ifdef MOCK

uint16_t ignorePorts[] = 
{
    0x3CE,
    0x3CF
};

uint16_t ignorePortsLegacy[] = 
{
    0x3C8,
    0x3CE,
    0x3CF,
    0xD81C,
    0xD81D,
    0xD81E,
    0xD81F,
    0xD828,
    0xD84C,
    0xD84D,
    0xD84E,
    0xD84F,
    0xD898,
    0xD899,
    0xD89A,
    0xD89B,
    0xD8E4,
    0xD8E5,
    0xD8E6,
    0xD8E7,
    0xD8E8,
    0xD8E9,
    0xD8EA,
    0xD8EB
};

uint32_t ignoreMemory[] =
{
    (0x0000 << 4) + 0x007c,
    (0x0000 << 4) + 0x007d,
    (0x0000 << 4) + 0x007e,
    (0x0000 << 4) + 0x007f,
    (0x0000 << 4) + 0x010c,
    (0x0000 << 4) + 0x010d,
    (0x0000 << 4) + 0x010e,
    (0x0000 << 4) + 0x010f,
    (0x0000 << 4) + 0x04a8,
    (0x0000 << 4) + 0x04a9,
    (0x0000 << 4) + 0x04aa,
    (0x0000 << 4) + 0x04ab,
};

int Diff(const char* name, uint16_t* ignorePorts, uint16_t ignorePortsCount)
{
    int ret = -1;
    if (Hag::Testing::Mock::HasDifferences(ignoreMemory, sizeof(ignoreMemory) / sizeof(uint32_t)))
    {
        printf("\n%s >----------------\n", name);
        Hag::Testing::Mock::Report(ignorePorts, ignorePortsCount, ignoreMemory, sizeof(ignoreMemory) / sizeof(uint32_t));
        printf("\n\n\n");
        ret = 0;
    }
    Hag::Testing::Mock::Snapshot();
    return ret;
}

class MockBanshee : public Hag::Testing::Mock::PCI::Device
{
public:
    inline MockBanshee(Hag::IAllocator& allocator)
        : Device("Banshee")
        , m_allocator(allocator)
        , m_Config(nullptr)
        , m_ConfigSnapshot(nullptr)
    {
        m_Config = allocator.AllocateAs<uint8_t>(sizeof(s_Config));

        m_ConfigSnapshot = allocator.AllocateAs<uint8_t>(sizeof(s_Config));
        Reset();
    }

    virtual ~MockBanshee()
    {
        m_allocator.Free(m_ConfigSnapshot);
        m_ConfigSnapshot = nullptr;

        m_allocator.Free(m_Config);
        m_Config = nullptr;
    }

    virtual void Report(Device* instance1)
    {
        MockBanshee* banshee1 = (MockBanshee*)instance1;

        if (memcmp(m_Config, banshee1->m_Config, sizeof(s_Config)) != 0)
        {
            printf("PCI Config space differences:\n");
            uint32_t* config0 = (uint32_t*)m_Config;
            uint32_t* config1 = (uint32_t*)banshee1->m_Config;
            for (uint16_t idx = 0; idx < sizeof(s_Config) / sizeof(uint32_t); ++idx)
            {
                if (config0[idx] != config1[idx])
                {
                    printf("0x%02X : 0x%08lX != 0x%08lX\n", idx * 4, config0[idx], config1[idx]);
                }
            }
            printf("\n");
        }
    }

    virtual bool HasDifferences(Device* instance1)
    {
        MockBanshee* banshee1 = (MockBanshee*)instance1;

        if (memcmp(m_Config, banshee1->m_Config, sizeof(s_Config)) != 0)
            return true;

        return false;
    }

    virtual void Reset()
    {
        memcpy(m_Config, s_Config, sizeof(s_Config));
        memcpy(m_ConfigSnapshot, s_Config, sizeof(s_Config));
    }

    virtual void Snapshot()
    {
        memcpy(m_ConfigSnapshot, m_Config, sizeof(s_Config));
    }

    virtual void Rollback()
    {
        memcpy(m_Config, m_ConfigSnapshot, sizeof(s_Config));
    }

    virtual uint32_t Read32(uint8_t offset)
    {
        uint32_t val = *(uint32_t*)(m_Config + offset);
        return val;
    }

    virtual void Write8(uint8_t offset, uint8_t value)
    {
        m_Config[offset] = value;
    }

    virtual void Write16(uint8_t offset, uint16_t value)
    {
        ((uint16_t*)m_Config)[offset >> 1] = value;
    }

    virtual void Write32(uint8_t offset, uint32_t value)
    {
        ((uint32_t*)m_Config)[offset >> 2] = value;
    }

    virtual void Snoop8(uint16_t port, uint8_t value)
    {

    }

    virtual void Snoop16(uint16_t port, uint16_t value)
    {

    }

private:
    Hag::IAllocator& m_allocator;

    uint8_t* m_Config;

    uint8_t* m_ConfigSnapshot;

    static uint8_t s_Config[256];
};

uint8_t MockBanshee::s_Config[256] = 
{
    0x1A, 0x12, 0x03, 0x00, 0x03, 0x00, 0xB0, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xDE, 0x08, 0x00, 0x00, 0xE2, 0x01, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x11, 0x17, 0x10,
    0x00, 0x00, 0xFF, 0xE1, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x01, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x60, 0x10, 0x00, 0x21, 0x02, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

Hag::Testing::Mock::PortAndValue TDfx_Banshee_DefaultPortValues [] =
{
    { 0x0062, 0x00 },
    { 0x0061, 0x00 },
    { 0x03C2, 0x70 },
    { 0x03C4, 0xFF },
    { 0x03C5, 0xFF },
    { 0x03CA, 0x00 },
    { 0x03CC, 0x67 },
    { 0x03BA, 0xFF },
    { 0x03DA, 0x01 },
    { 0x03C3, 0xFF },
    { 0x03C6, 0xFF },
    { 0x03C7, 0x00 },
    { 0x03C8, 0x00 },
    { 0x03C9, 0x00 },
    { 0x03D4, 0xFF },
    { 0x03D5, 0xFF },
    { 0x0102, 0xFF },
    { 0x46E8, 0xFF },

    { 0xD800, 0x1F },
    { 0xD801, 0x00 },
    { 0xD802, 0x00 },
    { 0xD803, 0x00 },
    { 0xD804, 0x40 },
    { 0xD805, 0xFB },
    { 0xD806, 0x80 },
    { 0xD807, 0x01 },
    { 0xD808, 0x00 },
    { 0xD809, 0x00 },
    { 0xD80A, 0x00 },
    { 0xD80B, 0x00 },
    { 0xD80C, 0xFF },
    { 0xD80D, 0x3F },
    { 0xD80E, 0x00 },
    { 0xD80F, 0x00 },
    { 0xD810, 0x00 },
    { 0xD811, 0x00 },
    { 0xD812, 0x00 },
    { 0xD813, 0x00 },
    { 0xD814, 0x01 },
    { 0xD815, 0x00 },
    { 0xD816, 0x00 },
    { 0xD817, 0x0F },
    { 0xD818, 0x6A },
    { 0xD819, 0xA1 },
    { 0xD81A, 0x17 },
    { 0xD81B, 0x0C },
    { 0xD81C, 0x31 },
    { 0xD81D, 0x80 },
    { 0xD81E, 0x54 },
    { 0xD81F, 0x00 },
    { 0xD820, 0x9E },
    { 0xD821, 0x04 },
    { 0xD822, 0x00 },
    { 0xD823, 0x00 },
    { 0xD824, 0xFB },
    { 0xD825, 0x0F },
    { 0xD826, 0x00 },
    { 0xD827, 0x00 },
    { 0xD828, 0x40 },
    { 0xD829, 0x01 },
    { 0xD82A, 0x00 },
    { 0xD82B, 0x00 },
    { 0xD82C, 0x00 },
    { 0xD82D, 0x00 },
    { 0xD82E, 0x00 },
    { 0xD82F, 0x00 },
    { 0xD830, 0x00 },
    { 0xD831, 0x00 },
    { 0xD832, 0x00 },
    { 0xD833, 0x00 },
    { 0xD834, 0x00 },
    { 0xD835, 0x00 },
    { 0xD836, 0x00 },
    { 0xD837, 0x00 },
    { 0xD838, 0x6F },
    { 0xD839, 0x01 },
    { 0xD83A, 0x00 },
    { 0xD83B, 0x00 },
    { 0xD83C, 0x1F },
    { 0xD83D, 0x00 },
    { 0xD83E, 0x00 },
    { 0xD83F, 0x00 },
    { 0xD840, 0x01 },
    { 0xD841, 0x0C },
    { 0xD842, 0x00 },
    { 0xD843, 0x00 },
    { 0xD844, 0x05 },
    { 0xD845, 0x28 },
    { 0xD846, 0x00 },
    { 0xD847, 0x00 },
    { 0xD848, 0x19 },
    { 0xD849, 0x79 },
    { 0xD84A, 0x00 },
    { 0xD84B, 0x00 },
    { 0xD84C, 0x00 },
    { 0xD84D, 0x00 },
    { 0xD84E, 0x00 },
    { 0xD84F, 0x00 },
    { 0xD850, 0x36 },
    { 0xD851, 0x00 },
    { 0xD852, 0x00 },
    { 0xD853, 0x00 },
    { 0xD854, 0x00 },
    { 0xD855, 0x00 },
    { 0xD856, 0x00 },
    { 0xD857, 0x00 },
    { 0xD858, 0x00 },
    { 0xD859, 0x00 },
    { 0xD85A, 0x00 },
    { 0xD85B, 0x00 },
    { 0xD85C, 0x00 },
    { 0xD85D, 0x00 },
    { 0xD85E, 0x00 },
    { 0xD85F, 0x00 },
    { 0xD860, 0x53 },
    { 0xD861, 0x51 },
    { 0xD862, 0x52 },
    { 0xD863, 0x9F },
    { 0xD864, 0x24 },
    { 0xD865, 0x31 },
    { 0xD866, 0xEE },
    { 0xD867, 0x4E },
    { 0xD868, 0x6E },
    { 0xD869, 0xA6 },
    { 0xD86A, 0x8F },
    { 0xD86B, 0xEE },
    { 0xD86C, 0xD3 },
    { 0xD86D, 0xB0 },
    { 0xD86E, 0x8D },
    { 0xD86F, 0x43 },
    { 0xD870, 0x00 },
    { 0xD871, 0x00 },
    { 0xD872, 0x00 },
    { 0xD873, 0x00 },
    { 0xD874, 0x07 },
    { 0xD875, 0x00 },
    { 0xD876, 0x00 },
    { 0xD877, 0x00 },
    { 0xD878, 0xE0 },
    { 0xD879, 0x1B },
    { 0xD87A, 0x78 },
    { 0xD87B, 0x4F },
    { 0xD87C, 0x00 },
    { 0xD87D, 0x00 },
    { 0xD87E, 0x00 },
    { 0xD87F, 0x00 },
    { 0xD880, 0x00 },
    { 0xD881, 0x00 },
    { 0xD882, 0x00 },
    { 0xD883, 0x00 },
    { 0xD884, 0x00 },
    { 0xD885, 0x00 },
    { 0xD886, 0x00 },
    { 0xD887, 0x00 },
    { 0xD888, 0x00 },
    { 0xD889, 0x00 },
    { 0xD88A, 0x00 },
    { 0xD88B, 0x00 },
    { 0xD88C, 0x00 },
    { 0xD88D, 0x00 },
    { 0xD88E, 0x00 },
    { 0xD88F, 0x00 },
    { 0xD890, 0x00 },
    { 0xD891, 0x00 },
    { 0xD892, 0x00 },
    { 0xD893, 0x00 },
    { 0xD894, 0x00 },
    { 0xD895, 0x00 },
    { 0xD896, 0x00 },
    { 0xD897, 0x00 },
    { 0xD898, 0x50 },
    { 0xD899, 0x90 },
    { 0xD89A, 0x01 },
    { 0xD89B, 0x00 },
    { 0xD89C, 0x00 },
    { 0xD89D, 0x00 },
    { 0xD89E, 0x00 },
    { 0xD89F, 0x00 },
    { 0xD8A0, 0x00 },
    { 0xD8A1, 0x00 },
    { 0xD8A2, 0x00 },
    { 0xD8A3, 0x00 },
    { 0xD8A4, 0x00 },
    { 0xD8A5, 0x00 },
    { 0xD8A6, 0x00 },
    { 0xD8A7, 0x00 },
    { 0xD8A8, 0x00 },
    { 0xD8A9, 0x00 },
    { 0xD8AA, 0x00 },
    { 0xD8AB, 0x00 },
    { 0xD8AC, 0x00 },
    { 0xD8AD, 0x00 },
    { 0xD8AE, 0x00 },
    { 0xD8AF, 0x00 },
    { 0xD8B0, 0x1F },
    { 0xD8B1, 0x00 },
    { 0xD8B2, 0x00 },
    { 0xD8B3, 0x00 },
    { 0xD8B4, 0x1F },
    { 0xD8B5, 0x00 },
    { 0xD8B6, 0x00 },
    { 0xD8B7, 0x00 },
    { 0xD8B8, 0x1F },
    { 0xD8B9, 0x00 },
    { 0xD8BA, 0x00 },
    { 0xD8BB, 0x00 },
    { 0xD8BC, 0x1F },
    { 0xD8BD, 0x00 },
    { 0xD8BE, 0x00 },
    { 0xD8BF, 0x00 },
    { 0xD8C0, 0x20 },
    { 0xD8C1, 0xFF },
    { 0xD8C2, 0x70 },
    { 0xD8C3, 0xFF },
    { 0xD8C4, 0x04 },
    { 0xD8C5, 0x02 },
    { 0xD8C6, 0xFF },
    { 0xD8C7, 0x03 },
    { 0xD8C8, 0x01 },
    { 0xD8C9, 0x00 },
    { 0xD8CA, 0x00 },
    { 0xD8CB, 0xFF },
    { 0xD8CC, 0x67 },
    { 0xD8CD, 0xFF },
    { 0xD8CE, 0x08 },
    { 0xD8CF, 0xFF },
    { 0xD8D0, 0x1F },
    { 0xD8D1, 0x00 },
    { 0xD8D2, 0x00 },
    { 0xD8D3, 0x00 },
    { 0xD8D4, 0x1C },
    { 0xD8D5, 0xD8 },
    { 0xD8D6, 0xFF },
    { 0xD8D7, 0xFF },
    { 0xD8D8, 0xFF },
    { 0xD8D9, 0xFF },
    { 0xD8DA, 0x05 },
    { 0xD8DB, 0xFF },
    { 0xD8DC, 0x1F },
    { 0xD8DD, 0x00 },
    { 0xD8DE, 0x00 },
    { 0xD8DF, 0x00 },
    { 0xD8E0, 0x00 },
    { 0xD8E1, 0x00 },
    { 0xD8E2, 0x00 },
    { 0xD8E3, 0x00 },
    { 0xD8E4, 0x00 },
    { 0xD8E5, 0x00 },
    { 0xD8E6, 0x00 },
    { 0xD8E7, 0x00 },
    { 0xD8E8, 0xA0 },
    { 0xD8E9, 0x00 },
    { 0xD8EA, 0x00 },
    { 0xD8EB, 0x00 },
    { 0xD8EC, 0x00 },
    { 0xD8ED, 0x00 },
    { 0xD8EE, 0x00 },
    { 0xD8EF, 0x00 },
    { 0xD8F0, 0x00 },
    { 0xD8F1, 0x00 },
    { 0xD8F2, 0x00 },
    { 0xD8F3, 0x00 },
    { 0xD8F4, 0x00 },
    { 0xD8F5, 0x00 },
    { 0xD8F6, 0x00 },
    { 0xD8F7, 0x00 },
    { 0xD8F8, 0x00 },
    { 0xD8F9, 0x00 },
    { 0xD8FA, 0x00 },
    { 0xD8FB, 0x00 },
    { 0xD8FC, 0xA2 },
    { 0xD8FD, 0xD6 },
    { 0xD8FE, 0x57 },
    { 0xD8FF, 0x00 }
};

uint8_t TDfx_Banshee_AttributeControllerRegisters[] =
{
    0x00,
    0x01,
    0x02,
    0x03,
    0x04,
    0x05,
    0x14,
    0x07,
    0x38,
    0x39,
    0x3A,
    0x3B,
    0x3C,
    0x3D,
    0x3E,
    0x3F,
    0x0C,
    0x00,
    0x0F,
    0x08,
    0x00
};

uint8_t TDfx_Banshee_RamdacControllerRegisters[] =
{
    0x00, 0x00, 0x00, //0
    0x00, 0x00, 0x2A, //1
    0x00, 0x2A, 0x00, //2
    0x00, 0x2A, 0x2A, //3
    0x2A, 0x00, 0x00, //4
    0x2A, 0x00, 0x2A, //5
    0x2A, 0x2A, 0x00, //6
    0x2A, 0x2A, 0x2A, //7
    0x00, 0x00, 0x15, //8
    0x00, 0x00, 0x3F, //9
    0x00, 0x2A, 0x15, //10
    0x00, 0x2A, 0x3F, //11
    0x2A, 0x00, 0x15, //12
    0x2A, 0x00, 0x3F, //13
    0x2A, 0x2A, 0x15, //14
    0x2A, 0x2A, 0x3F, //15
    0x00, 0x15, 0x00, //16
    0x00, 0x15, 0x2A, //17
    0x00, 0x3F, 0x00, //18
    0x00, 0x3F, 0x2A, //19
    0x2A, 0x15, 0x00, //20
    0x2A, 0x15, 0x2A, //21
    0x2A, 0x3F, 0x00, //22
    0x2A, 0x3F, 0x2A, //23
    0x00, 0x15, 0x15, //24
    0x00, 0x15, 0x3F, //25
    0x00, 0x3F, 0x15, //26
    0x00, 0x3F, 0x3F, //27
    0x2A, 0x15, 0x15, //28
    0x2A, 0x15, 0x3F, //29
    0x2A, 0x3F, 0x15, //30
    0x2A, 0x3F, 0x3F, //31
    0x15, 0x00, 0x00, //32
    0x15, 0x00, 0x2A, //33
    0x15, 0x2A, 0x00, //34
    0x15, 0x2A, 0x2A, //35
    0x3F, 0x00, 0x00, //36
    0x3F, 0x00, 0x2A, //37
    0x3F, 0x2A, 0x00, //38
    0x3F, 0x2A, 0x2A, //39
    0x15, 0x00, 0x15, //40
    0x15, 0x00, 0x3F, //41
    0x15, 0x2A, 0x15, //42
    0x15, 0x2A, 0x3F, //43
    0x3F, 0x00, 0x15, //44
    0x3F, 0x00, 0x3F, //45
    0x3F, 0x2A, 0x15, //46
    0x3F, 0x2A, 0x3F, //47
    0x15, 0x15, 0x00, //48
    0x15, 0x15, 0x2A, //49
    0x15, 0x3F, 0x00, //50
    0x15, 0x3F, 0x2A, //51
    0x3F, 0x15, 0x00, //52
    0x3F, 0x15, 0x2A, //53
    0x3F, 0x3F, 0x00, //54
    0x3F, 0x3F, 0x2A, //55
    0x15, 0x15, 0x15, //56
    0x15, 0x15, 0x3F, //57
    0x15, 0x3F, 0x15, //58
    0x15, 0x3F, 0x3F, //59
    0x3F, 0x15, 0x15, //60
    0x3F, 0x15, 0x3F, //61
    0x3F, 0x3F, 0x15, //62
    0x3F, 0x3F, 0x3F, //63
    0x00, 0x00, 0x00, //64
    0x00, 0x00, 0x00, //65
    0x00, 0x00, 0x00, //66
    0x00, 0x00, 0x00, //67
    0x00, 0x00, 0x00, //68
    0x00, 0x00, 0x00, //69
    0x00, 0x00, 0x00, //70
    0x00, 0x00, 0x00, //71
    0x00, 0x00, 0x00, //72
    0x00, 0x00, 0x00, //73
    0x00, 0x00, 0x00, //74
    0x00, 0x00, 0x00, //75
    0x00, 0x00, 0x00, //76
    0x00, 0x00, 0x00, //77
    0x00, 0x00, 0x00, //78
    0x00, 0x00, 0x00, //79
    0x00, 0x00, 0x00, //80
    0x00, 0x00, 0x00, //81
    0x00, 0x00, 0x00, //82
    0x00, 0x00, 0x00, //83
    0x00, 0x00, 0x00, //84
    0x00, 0x00, 0x00, //85
    0x00, 0x00, 0x00, //86
    0x00, 0x00, 0x00, //87
    0x00, 0x00, 0x00, //88
    0x00, 0x00, 0x00, //89
    0x00, 0x00, 0x00, //90
    0x00, 0x00, 0x00, //91
    0x00, 0x00, 0x00, //92
    0x00, 0x00, 0x00, //93
    0x00, 0x00, 0x00, //94
    0x00, 0x00, 0x00, //95
    0x00, 0x00, 0x00, //96
    0x00, 0x00, 0x00, //97
    0x00, 0x00, 0x00, //98
    0x00, 0x00, 0x00, //99
    0x00, 0x00, 0x00, //100
    0x00, 0x00, 0x00, //101
    0x00, 0x00, 0x00, //102
    0x00, 0x00, 0x00, //103
    0x00, 0x00, 0x00, //104
    0x00, 0x00, 0x00, //105
    0x00, 0x00, 0x00, //106
    0x00, 0x00, 0x00, //107
    0x00, 0x00, 0x00, //108
    0x00, 0x00, 0x00, //109
    0x00, 0x00, 0x00, //110
    0x00, 0x00, 0x00, //111
    0x00, 0x00, 0x00, //112
    0x00, 0x00, 0x00, //113
    0x00, 0x00, 0x00, //114
    0x00, 0x00, 0x00, //115
    0x00, 0x00, 0x00, //116
    0x00, 0x00, 0x00, //117
    0x00, 0x00, 0x00, //118
    0x00, 0x00, 0x00, //119
    0x00, 0x00, 0x00, //120
    0x00, 0x00, 0x00, //121
    0x00, 0x00, 0x00, //122
    0x00, 0x00, 0x00, //123
    0x00, 0x00, 0x00, //124
    0x00, 0x00, 0x00, //125
    0x00, 0x00, 0x00, //126
    0x00, 0x00, 0x00, //127
    0x00, 0x00, 0x00, //128
    0x00, 0x00, 0x00, //129
    0x00, 0x00, 0x00, //130
    0x00, 0x00, 0x00, //131
    0x00, 0x00, 0x00, //132
    0x00, 0x00, 0x00, //133
    0x00, 0x00, 0x00, //134
    0x00, 0x00, 0x00, //135
    0x00, 0x00, 0x00, //136
    0x00, 0x00, 0x00, //137
    0x00, 0x00, 0x00, //138
    0x00, 0x00, 0x00, //139
    0x00, 0x00, 0x00, //140
    0x00, 0x00, 0x00, //141
    0x00, 0x00, 0x00, //142
    0x00, 0x00, 0x00, //143
    0x00, 0x00, 0x00, //144
    0x00, 0x00, 0x00, //145
    0x00, 0x00, 0x00, //146
    0x00, 0x00, 0x00, //147
    0x00, 0x00, 0x00, //148
    0x00, 0x00, 0x00, //149
    0x00, 0x00, 0x00, //150
    0x00, 0x00, 0x00, //151
    0x00, 0x00, 0x00, //152
    0x00, 0x00, 0x00, //153
    0x00, 0x00, 0x00, //154
    0x00, 0x00, 0x00, //155
    0x00, 0x00, 0x00, //156
    0x00, 0x00, 0x00, //157
    0x00, 0x00, 0x00, //158
    0x00, 0x00, 0x00, //159
    0x00, 0x00, 0x00, //160
    0x00, 0x00, 0x00, //161
    0x00, 0x00, 0x00, //162
    0x00, 0x00, 0x00, //163
    0x00, 0x00, 0x00, //164
    0x00, 0x00, 0x00, //165
    0x00, 0x00, 0x00, //166
    0x00, 0x00, 0x00, //167
    0x00, 0x00, 0x00, //168
    0x00, 0x00, 0x00, //169
    0x00, 0x00, 0x00, //170
    0x00, 0x00, 0x00, //171
    0x00, 0x00, 0x00, //172
    0x00, 0x00, 0x00, //173
    0x00, 0x00, 0x00, //174
    0x00, 0x00, 0x00, //175
    0x00, 0x00, 0x00, //176
    0x00, 0x00, 0x00, //177
    0x00, 0x00, 0x00, //178
    0x00, 0x00, 0x00, //179
    0x00, 0x00, 0x00, //180
    0x00, 0x00, 0x00, //181
    0x00, 0x00, 0x00, //182
    0x00, 0x00, 0x00, //183
    0x00, 0x00, 0x00, //184
    0x00, 0x00, 0x00, //185
    0x00, 0x00, 0x00, //186
    0x00, 0x00, 0x00, //187
    0x00, 0x00, 0x00, //188
    0x00, 0x00, 0x00, //189
    0x00, 0x00, 0x00, //190
    0x00, 0x00, 0x00, //191
    0x00, 0x00, 0x00, //192
    0x00, 0x00, 0x00, //193
    0x00, 0x00, 0x00, //194
    0x00, 0x00, 0x00, //195
    0x00, 0x00, 0x00, //196
    0x00, 0x00, 0x00, //197
    0x00, 0x00, 0x00, //198
    0x00, 0x00, 0x00, //199
    0x00, 0x00, 0x00, //200
    0x00, 0x00, 0x00, //201
    0x00, 0x00, 0x00, //202
    0x00, 0x00, 0x00, //203
    0x00, 0x00, 0x00, //204
    0x00, 0x00, 0x00, //205
    0x00, 0x00, 0x00, //206
    0x00, 0x00, 0x00, //207
    0x00, 0x00, 0x00, //208
    0x00, 0x00, 0x00, //209
    0x00, 0x00, 0x00, //210
    0x00, 0x00, 0x00, //211
    0x00, 0x00, 0x00, //212
    0x00, 0x00, 0x00, //213
    0x00, 0x00, 0x00, //214
    0x00, 0x00, 0x00, //215
    0x00, 0x00, 0x00, //216
    0x00, 0x00, 0x00, //217
    0x00, 0x00, 0x00, //218
    0x00, 0x00, 0x00, //219
    0x00, 0x00, 0x00, //220
    0x00, 0x00, 0x00, //221
    0x00, 0x00, 0x00, //222
    0x00, 0x00, 0x00, //223
    0x00, 0x00, 0x00, //224
    0x00, 0x00, 0x00, //225
    0x00, 0x00, 0x00, //226
    0x00, 0x00, 0x00, //227
    0x00, 0x00, 0x00, //228
    0x00, 0x00, 0x00, //229
    0x00, 0x00, 0x00, //230
    0x00, 0x00, 0x00, //231
    0x00, 0x00, 0x00, //232
    0x00, 0x00, 0x00, //233
    0x00, 0x00, 0x00, //234
    0x00, 0x00, 0x00, //235
    0x00, 0x00, 0x00, //236
    0x00, 0x00, 0x00, //237
    0x00, 0x00, 0x00, //238
    0x00, 0x00, 0x00, //239
    0x00, 0x00, 0x00, //240
    0x00, 0x00, 0x00, //241
    0x00, 0x00, 0x00, //242
    0x00, 0x00, 0x00, //243
    0x00, 0x00, 0x00, //244
    0x00, 0x00, 0x00, //245
    0x00, 0x00, 0x00, //246
    0x00, 0x00, 0x00, //247
    0x00, 0x00, 0x00, //248
    0x00, 0x00, 0x00, //249
    0x00, 0x00, 0x00, //250
    0x00, 0x00, 0x00, //251
    0x00, 0x00, 0x00, //252
    0x00, 0x00, 0x00, //253
    0x00, 0x00, 0x00, //254
    0x00, 0x00, 0x00  //255
};

uint8_t TDfx_Banshee_CRTControllerRegisters[] =
{
    0x5F,
    0x4F,
    0x50,
    0x82,
    0x55,
    0x81,
    0xBF,
    0x1F,
    0x00,
    0x4F,
    0x0D,
    0x0E,
    0x00,
    0x00,
    0x00,
    0x00,
    0x9C,
    0x8E,
    0x8F,
    0x28,
    0x1F,
    0x96,
    0xB9,
    0xA3,
    0xFF,
    0x00,
    0x00,
    0x00,
    0xD8,
    0x00,
    0x00,
    0x00
};

uint8_t TDfx_Banshee_CRTControllerRegisters_AndMask[] =
{
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0x7F,
    0xFF,
    0x3F,
    0x7F,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0x7F,
    0xFF,
    0xFF,
    0xEF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
};

uint8_t TDfx_Banshee_CRTControllerRegisters_OrMask[] =
{
    0x00,
    0x00,
    0x00,
    0x80,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00
};

uint8_t TDfx_Banshee_GraphicsControllerRegisters[] =
{
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x10,
    0x0E,
    0x00,
    0xFF
};

uint8_t TDfx_Banshee_GraphicsControllerRegisters_AndMask[] =
{
    0x0F,
    0x0F,
    0x0F,
    0x1F,
    0x03,
    0x7B,
    0x0F,
    0x0F,
    0xFF
};

uint8_t TDfx_Banshee_SequencerControllerRegisters[] =
{
    0x03,
    0x00,
    0x03,
    0x00,
    0x02
};

uint8_t TDfx_Banshee_SequencerControllerRegisters_AndMask[] =
{
    0x03,
    0x3D,
    0x0F,
    0x3F,
    0x0E
};

void TDfxBansheeMockConfigSetup(Hag::IAllocator& allocator)
{
    using namespace Hag;
    using namespace Hag::System;
    using namespace Hag::Testing;
    
    //printf("Mock initialization...\n");

    Hag::Testing::Mock::Initialize(allocator,
        TDfx_Banshee_DefaultPortValues,
        sizeof(TDfx_Banshee_DefaultPortValues) / sizeof(Mock::PortAndValue),
        TDfx_Banshee_AttributeControllerRegisters,
        TDfx_Banshee_RamdacControllerRegisters);

    Mock::AddIndexedPort("CRT Controller B", Hag::VGA::Register::CRTControllerIndexB, 0xff, Hag::VGA::Register::CRTControllerDataB, sizeof(TDfx_Banshee_CRTControllerRegisters) / sizeof(uint8_t), TDfx_Banshee_CRTControllerRegisters, TDfx_Banshee_CRTControllerRegisters_OrMask, TDfx_Banshee_CRTControllerRegisters_AndMask);
    Mock::AddIndexedPort("CRT Controller D", Hag::VGA::Register::CRTControllerIndexD, 0xff, Hag::VGA::Register::CRTControllerDataD, sizeof(TDfx_Banshee_CRTControllerRegisters) / sizeof(uint8_t), TDfx_Banshee_CRTControllerRegisters, TDfx_Banshee_CRTControllerRegisters_OrMask, TDfx_Banshee_CRTControllerRegisters_AndMask);
    Mock::AddIndexedPort("Graphics Controller", Hag::VGA::Register::GraphicsControllerIndex, 0x0f, Hag::VGA::Register::GraphicsControllerData, 0x09, TDfx_Banshee_GraphicsControllerRegisters, nullptr, TDfx_Banshee_GraphicsControllerRegisters_AndMask);
    Mock::AddIndexedPort("Sequence Controller", Hag::VGA::Register::SequencerIndex, 0x1f, Hag::VGA::Register::SequencerData, 0x05, TDfx_Banshee_SequencerControllerRegisters, nullptr, TDfx_Banshee_SequencerControllerRegisters_AndMask);
    BDA::SystemBDA().DetectedHardware = 0x26; //Hack
    BDA::SystemBDA().VideoBaseIOPort = 0x3d4;
    BDA::SystemBDA().EGAFeatureBitSwitches = 0x09;
    BDA::SystemBDA().VideoDisplayDataArea = 0x11;
    BDA::SystemBDA().VideoModeOptions = 0x60;
    BDA::SystemBDA().DisplayCombinationCodeTableIndex = 0x0B;

    Mock::SetDefaultMemory((uint8_t*)&BDA::SystemBDA(), 0x0400, 0x100);//TODO: Should use something more static.

    Mock::AddDualPortRegister("Miscellaneous Output", VGA::Register::MiscellaneousR, VGA::Register::MiscellaneousW);
    Mock::AddDualPortRegister("Feature Control", VGA::Register::FeatureControlR, VGA::Register::FeatureControlWB, VGA::Register::FeatureControlWD);
    Mock::PCI::RegisterDevice(0, ::new(allocator.Allocate(sizeof(MockBanshee))) MockBanshee(allocator));
    Mock::PCI::RegisterDevice(1, ::new(allocator.Allocate(sizeof(MockBanshee))) MockBanshee(allocator));
}
#endif

struct TestMode
{
    uint16_t LegacyMode;
    uint16_t Width;
    uint16_t Height;
    Hag::VGA::ModeSetting::BitsPerPixel_t Bpp;
    Hag::VGA::ModeSetting::Flags_t Flags;
    Hag::VGA::ModeSetting::RefreshRate_t RefreshRate;
};

TestMode TestModes[] =
{
    {//1
        Hag::VGA::VideoMode::T40x25x4bppC,
        40,
        25,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Text |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz
    },
    {//3
        Hag::VGA::VideoMode::T80x25x4bppC,
        80,
        25,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Text |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz
    },
    {//7
        Hag::VGA::VideoMode::T80x25x1bppM,
        80,
        25,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp1,
        Hag::VGA::ModeSetting::Flags::Text |
        Hag::VGA::ModeSetting::Flags::Monochrome |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz
    },
    {//6
        Hag::VGA::VideoMode::G640x200x1bppM,
        640,
        200,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp1,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Monochrome |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz
    },
    {//4
        Hag::VGA::VideoMode::G320x200x2bppC,
        320,
        200,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp2,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz,
    },
    {//13
        Hag::VGA::VideoMode::G320x200x8bppC,
        320,
        200,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp8,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz
    },
    {//D
        Hag::VGA::VideoMode::G320x200x4bppC,
        320,
        200,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Planar,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz
    },
    {//E
        Hag::VGA::VideoMode::G640x200x4bppC,
        640,
        200,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Planar,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz
    },
    {//F
        Hag::VGA::VideoMode::G640x350x1bppM,
        640,
        350,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp2,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Monochrome |
        Hag::VGA::ModeSetting::Flags::Planar,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz
    },
    {//10
        Hag::VGA::VideoMode::G640x350x4bppC,
        640,
        350,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Planar,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz
    },
    {//11
        Hag::VGA::VideoMode::G640x480x1bppM,
        640,
        480,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp1,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Monochrome |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz
    },
    {//12
        Hag::VGA::VideoMode::G640x480x4bppC,
        640,
        480,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Planar,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz
    },
    {//100
        Hag::Vesa::VideoMode::G640x400x8bpp,
        640,
        400,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp8,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz
    },
    {//101
        Hag::Vesa::VideoMode::G640x480x8bpp,
        640,
        480,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp8,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//102
        Hag::Vesa::VideoMode::G800x600x4bpp,
        800,
        600,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Planar,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//103
        Hag::Vesa::VideoMode::G800x600x8bpp,
        800,
        600,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp8,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//105
        Hag::Vesa::VideoMode::G1024x768x8bpp,
        1024,
        768,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp8,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//107
        Hag::Vesa::VideoMode::G1280x1024x8bpp,
        1280,
        1024,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp8,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//108
        Hag::Vesa::VideoMode::T80x60x4bpp,
        80,
        60,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Text |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz
    },
    {//109
        Hag::Vesa::VideoMode::T132x25x4bpp,
        132,
        25,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Text |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz,
    },
    {//10A
        Hag::Vesa::VideoMode::T132x43x4bpp,
        132,
        43,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Text |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz,
    },
    {//10B
        Hag::Vesa::VideoMode::T132x50x4bpp,
        132,
        50,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Text |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz,
    },
    {//10C
        Hag::Vesa::VideoMode::T132x60x4bpp,
        132,
        60,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp4,
        Hag::VGA::ModeSetting::Flags::Text |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//111
        Hag::Vesa::VideoMode::G640x480x16bpp,
        640,
        480,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp16,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//112
        Hag::Vesa::VideoMode::G640x480x32bpp,
        640,
        480,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp24,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//114
        Hag::Vesa::VideoMode::G800x600x16bpp,
        800,
        600,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp16,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//115
        Hag::Vesa::VideoMode::G800x600x32bpp,
        800,
        600,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp24,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//117
        Hag::Vesa::VideoMode::G1024x768x16bpp,
        1024,
        768,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp16,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//118
        Hag::Vesa::VideoMode::G1024x768x32bpp,
        1024,
        768,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp24,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//11A
        Hag::Vesa::VideoMode::G1280x1024x16bpp,
        1280,
        1024,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp16,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//11B
        Hag::Vesa::VideoMode::G1280x1024x32bpp,
        1280,
        1024,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp24,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer |
        Hag::VGA::ModeSetting::Flags::Sequential,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    {//180
        0x78,
        320,
        200,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp8,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz,
    },
    { // Mode 181 parameter: 0x22
        0x20,
        320,
        240,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp8,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    { // Mode 184 parameter: 0x23
        0x23,
        400,
        300,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp8,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    { // Mode 187 parameter: 0x24
        0x26,
        512,
        384,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp8,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    { // Mode 10E parameter: 0x21
        0x79,//Hag::Vesa::VideoMode::G320x200x16bpp
        320,
        200,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp16,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz,
    },
    { // Mode 10F parameter: 0x21
        0x7A,//Hag::Vesa::VideoMode::G320x200x32bpp
        320,
        200,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp24,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R70Hz,
    },
    { // Mode 182 parameter: 0x22
        0x21,
        320,
        240,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp16,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    { // Mode 183 parameter: 0x22
        0x22,
        320,
        240,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp24,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    { // Mode 185 parameter: 0x23
        0x24,
        400,
        300,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp16,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    { // Mode 186 parameter: 0x23
        0x25,
        400,
        300,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp24,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    { // Mode 188 parameter: 0x24
        0x27,
        512,
        384,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp16,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
    { // Mode 189 parameter: 0x24
        0x28,
        512,
        384,
        Hag::VGA::ModeSetting::BitsPerPixel::Bpp24,
        Hag::VGA::ModeSetting::Flags::Graphics |
        Hag::VGA::ModeSetting::Flags::Color |
        Hag::VGA::ModeSetting::Flags::Sequential |
        Hag::VGA::ModeSetting::Flags::LinearFramebuffer,
        Hag::VGA::ModeSetting::RefreshRate::R60Hz,
    },
};

Support::Device PCIDevices[] =
{
    { 0x0001, "3Dfx Voodoo Graphics" },
    { 0x0002, "3Dfx Voodoo 2" },
    { 0x0003, "3Dfx Voodoo Banshee" },
    { 0x0004, "3Dfx Velocity 100" },
    { 0x0005, "3Dfx Voodoo 3" },
    { 0x0009, "3Dfx Voodoo 4/5" },
    { 0x0057, "3Dfx Voodoo 3/3000" }
};

struct RegName
{
    uint8_t reg;
    const char* name;
};

RegName RegisterNames[] =
{
    { 0x00, "status Register" },
    { 0x04, "pciInit0 register" },
    { 0x08, "sipMonitor register" },
    { 0x0c, "lfbMemoryConfig register" },
    { 0x10, "miscInit0 register" },
    { 0x14, "miscInit1 register" },
    { 0x18, "dramInit0 register (set)" },
    { 0x1c, "dramInit1 register (set)" },
    { 0x20, "agpInit register" },
    { 0x24, "tmuGbeInit register" },
    { 0x28, "vgaInit0 register (set)" },
    { 0x2c, "vgaInit1 register (set)" },
    { 0x30, "dramCommand register (see 2D offset 0x70)" },
    { 0x34, "dramData register (see 2D offset 0x064)" },
    { 0x38, "reserved" },
    { 0x40, "pllCtrl0 (set)" },
    { 0x44, "pllCtrl1" },
    { 0x48, "pllCtrl2" },
    { 0x4c, "dacMode register. (set)" },
    { 0x50, "dacAddr register." },
    { 0x54, "dacData register." },
    { 0x58, "rgbMaxDelta register" },
    { 0x5c, "vidProcCfg register. (set)" },
    { 0x60, "hwCurPatAddr register." },
    { 0x64, "hwCurLoc register." },
    { 0x68, "hwCurC0 register" },
    { 0x6c, "hwCurC1 register." },
    { 0x70, "vidInFormat register" },
    { 0x74, "vidInStatus register" },
    { 0x78, "vidSerialParallelPort register" },
    { 0x7c, "vidInXDecimDeltas register." },
    { 0x80, "vidInDecimInitErrs register." },
    { 0x84, "vidInYDecimDeltas register." },
    { 0x88, "vidPixelBufThold register" },
    { 0x8c, "vidChromaMin register." },
    { 0x90, "vidChromaMax register." },
    { 0x94, "vidCurrentLine register." },
    { 0x98, "vidScreenSize register. (set)" },
    { 0x9c, "vidOverlayStartCoords register." },
    { 0xa0, "vidOverlayEndScreenCoord register." },
    { 0xa4, "vidOverlayDudx register" },
    { 0xa8, "vidOverlayDudxOffsetSrcWidth register." },
    { 0xac, "vidOverlayDvdy register." },
    { 0xb0, "vga registers" },
    { 0xb4, "vga registers" },
    { 0xb8, "vga registers" },
    { 0xbc, "vga registers" },
    { 0xe0, "vidOverlayDvdyOffset register." },
    { 0xe4, "vidDesktopStartAddr register. (set)" },
    { 0xe8, "vidDesktopOverlayStride register. (set)" },
    { 0xec, "vidInAddr0 register" },
    { 0xf0, "vidInAddr1 register." },
    { 0xf4, "vidInAddr2 register." },
    { 0xf8, "vidInStride register." },
    { 0xfc, "vidCurrOverlayStartAddr register." }
};

const char* GetRegName(uint8_t reg)
{
    for (uint16_t i = 0; i < sizeof(RegisterNames) / sizeof(RegName); ++i)
    {
        if (RegisterNames[i].reg == reg)
            return RegisterNames[i].name;
    }
    return "";
}

void BansheeDump(FILE* fptext, FILE* fpbin, Hag::VGA::Register_t baseIOPort)
{
    using namespace Hag;
    using namespace Hag::TDfx::Shared;

    if (fptext != nullptr) fprintf(fptext, "\nBanshee CRTC Registers:\n");

    CRTController::HorizontalExtension_t horizontalExtension = CRTController::HorizontalExtension::Read(baseIOPort);
    if (fptext != nullptr) fprintf(fptext, "Horizontal extension    : 0x%02X\n", horizontalExtension);
    if (fpbin != nullptr) fwrite(&horizontalExtension, sizeof(horizontalExtension), 1, fpbin);

    CRTController::VerticalExtension_t verticalExtension = CRTController::VerticalExtension::Read(baseIOPort);
    if (fptext != nullptr) fprintf(fptext, "Vertical extension      : 0x%02X\n", verticalExtension);
    if (fpbin != nullptr) fwrite(&verticalExtension, sizeof(verticalExtension), 1, fpbin);

    CRTController::Extension0_t extension0 = CRTController::Extension0::Read(baseIOPort);
    if (fptext != nullptr) fprintf(fptext, "Extension 0             : 0x%02X\n", extension0);
    if (fpbin != nullptr) fwrite(&extension0, sizeof(extension0), 1, fpbin);

    CRTController::Extension0_t extension1 = CRTController::Extension1::Read(baseIOPort);
    if (fptext != nullptr) fprintf(fptext, "Extension 1             : 0x%02X\n", extension1);
    if (fpbin != nullptr) fwrite(&extension1, sizeof(extension1), 1, fpbin);

    CRTController::Extension0_t extension2 = CRTController::Extension2::Read(baseIOPort);
    if (fptext != nullptr) fprintf(fptext, "Extension 2             : 0x%02X\n", extension2);
    if (fpbin != nullptr) fwrite(&extension2, sizeof(extension2), 1, fpbin);

    CRTController::Extension0_t extension3 = CRTController::Extension3::Read(baseIOPort);
    if (fptext != nullptr) fprintf(fptext, "Extension 3             : 0x%02X\n", extension3);
    if (fpbin != nullptr) fwrite(&extension3, sizeof(extension3), 1, fpbin);

    if (fptext != nullptr) fprintf(fptext, "\nBanshee IO Range Registers:\n");

    System::PCI::Device_t device = 0;
    System::PCI::FindDevice(0x121a, 0x0003, device);
    PCI::IOBaseAddress_t baseAddress = PCI::IOBaseAddress::GetBaseAddress(device);
    if (fptext != nullptr) fprintf(fptext, "Base address offset     : 0x%04X\n", uint16_t(baseAddress));
    if (fpbin != nullptr) fwrite(&baseAddress, sizeof(baseAddress), 1, fpbin);
    for (uint8_t i = 0; i < 64; ++i)
    {
        uint32_t regValue = SYS_ReadPortDouble(baseAddress + (i << 2));
        if (fptext != nullptr) fprintf(fptext, "Reg 0x%02X            : 0x%08lX %s\n", i, regValue, GetRegName(i << 2));
        if (fpbin != nullptr) fwrite(&regValue, sizeof(regValue), 1, fpbin);
    }
    if (fptext != nullptr) fprintf(fptext, "\n");

    for (uint16_t i = 0; i < 256; ++i)
    {
        uint8_t regValue = SYS_ReadPortByte(baseAddress + i);
        if (fptext != nullptr) fprintf(fptext, "{ 0x%04X, 0x%02X },\n", uint16_t(baseAddress + i), regValue);
    }
}

uint8_t GetCorrectTableIndex(Hag::VGA::VideoMode_t mode)
{
    using namespace Hag;
    using namespace Hag::System;
    Hag::VGA::VideoMode_t originalMode = mode;

    ModeData* modeData = nullptr;
    ExtraModeData* extraModeData = nullptr;

    if (mode <= VGA::VideoMode::G320x200x8bppC)
        goto Label0x35c1;

    FindModeData(mode, modeData);

    extraModeData = GetExtraModeData(*modeData);
    mode = extraModeData->Unknown3;

    if (mode != 0)
        goto Label0x35c4;

    mode = originalMode;

Label0x35c1:

    mode = GetVideoParameterTableIndex(mode);

Label0x35c4:

    return mode;
}

void FindModes(Hag::VGA::VideoMode_t mode)
{
    using namespace Hag::System;
    BDA::VideoDisplayDataArea_t vdda = BDA::VideoDisplayDataArea::Get();

    BDA::VideoDisplayDataArea::Get() = BDA::VideoDisplayDataArea::LineMode350;
    uint8_t modeSL350 = GetCorrectTableIndex(mode);

    BDA::VideoDisplayDataArea::Get() = BDA::VideoDisplayDataArea::LineMode200;
    uint8_t modeSL200 = GetCorrectTableIndex(mode);

    BDA::VideoDisplayDataArea::Get() = BDA::VideoDisplayDataArea::LineMode400;
    uint8_t modeSL400 = GetCorrectTableIndex(mode);

    BDA::VideoDisplayDataArea::Get() = BDA::VideoDisplayDataArea::LineMode400 | BDA::VideoDisplayDataArea::LineMode200;
    uint8_t modeSL480 = GetCorrectTableIndex(mode);
    if ((modeSL200 == modeSL350) &&
        (modeSL200 == modeSL400) &&
        (modeSL200 == modeSL480))
        printf("All scanlines: 0x%02X\n", modeSL200);
    else
        printf("SL200: 0x%02X, SL350: 0x%02X, SL400: 0x%02X, SL480 0x%02X\n", modeSL200, modeSL350, modeSL400, modeSL480);

    BDA::VideoDisplayDataArea::Get() = vdda;
}

uint32_t GetParameterIndices(Hag::VGA::VideoMode_t mode, uint16_t* parameterIndices)
{
    using namespace Hag;
    using namespace Hag::System;

    uint32_t ret = 1;
    BDA::VideoDisplayDataArea_t vdda = BDA::VideoDisplayDataArea::Get();

    parameterIndices[0] =
    parameterIndices[1] =
    parameterIndices[2] =
    parameterIndices[3] = 0xFFFF;

    BDA::VideoDisplayDataArea::Get() = BDA::VideoDisplayDataArea::LineMode350;
    uint8_t modeSL350 = GetCorrectTableIndex(mode);

    BDA::VideoDisplayDataArea::Get() = BDA::VideoDisplayDataArea::LineMode200;
    uint8_t modeSL200 = GetCorrectTableIndex(mode);

    BDA::VideoDisplayDataArea::Get() = BDA::VideoDisplayDataArea::LineMode400;
    uint8_t modeSL400 = GetCorrectTableIndex(mode);

    BDA::VideoDisplayDataArea::Get() = BDA::VideoDisplayDataArea::LineMode400 | BDA::VideoDisplayDataArea::LineMode200;
    uint8_t modeSL480 = GetCorrectTableIndex(mode);


    if (((modeSL200 == modeSL350) &&
        (modeSL200 == modeSL400) &&
        (modeSL200 == modeSL480)))
    {
        parameterIndices[0] = modeSL200;
    }
    else
    {
        parameterIndices[0] = modeSL200;
        parameterIndices[1] = modeSL350;
        parameterIndices[2] = modeSL400;
        parameterIndices[3] = modeSL480;
        ret = 4;
    }

    BDA::VideoDisplayDataArea::Get() = vdda;

    return ret;
}

typedef std::string String_t;
typedef std::vector<std::string> StringVector_t;

StringVector_t s_HorizontalTimings;
StringVector_t s_HorizontalTimingNames;

uint8_t CharacterClockInPixels(Hag::System::BDA::VideoParameterTable& table)
{
    using namespace Hag;
    //Dot clock select bit is in bit 0.
    uint8_t dotClockSelect = table.SequencerRegisters[VGA::Sequencer::Register::ClockingMode - 1] & VGA::Sequencer::ClockingMode::DotClockSelect;
    //dotClockSelect == 0 -> 9 pixels, 1 -> 8 pixels.
    return dotClockSelect == 0 ? 9 : 8;
}

uint32_t HorizontalDisplayEnableEndChars(Hag::System::BDA::VideoParameterTable& table)
{
    using namespace Hag;
    return table.CRTCRegisters[VGA::CRTController::Register::HorizontalDisplayEnd] + 1;
}

uint32_t HorizontalDisplayEnableEndPixels(Hag::System::BDA::VideoParameterTable& table)
{
    return HorizontalDisplayEnableEndChars(table) * CharacterClockInPixels(table);
}

bool IsExtendedMode(ModeData& modeData)
{
    return modeData.VesaMode >= 0x100;
}

uint8_t ScanlineDouble(Hag::System::BDA::VideoParameterTable& table)//Returns 0 if no doubling, 1 if there is.
{
    using namespace Hag;
    return (table.CRTCRegisters[VGA::CRTController::Register::CRTCModeControl] & VGA::CRTController::CRTCModeControl::VerticalTotalDouble) >> 2;
}

uint32_t VerticalDisplayEnableEndLines(ModeData& modeData, Hag::System::BDA::VideoParameterTable& table)
{
    using namespace Hag;
    using namespace Hag::TDfx;

    uint32_t verticalDisplayEnd = table.CRTCRegisters[VGA::CRTController::Register::VerticalDisplayEnd];
    //Extension bit 8 is in bit 1.
    uint32_t verticalDisplayEndBit8 = table.CRTCRegisters[VGA::CRTController::Register::CRTCOverflow] & VGA::CRTController::CRTCOverflow::VerticalDisplayEndHigh1;
    //Move to bit 8.
    verticalDisplayEndBit8 <<= 7;
    //Move bit in to place.
    verticalDisplayEnd |= verticalDisplayEndBit8;
    //Extension bit 9 is in bit 6.
    uint32_t verticalDisplayEndBit9 = table.CRTCRegisters[VGA::CRTController::Register::CRTCOverflow] & VGA::CRTController::CRTCOverflow::VerticalDisplayEndHigh2;
    //Move to bit 9.
    verticalDisplayEndBit9 <<= 3;
    //Move bit in to place.
    verticalDisplayEnd |= verticalDisplayEndBit9;
    if (IsExtendedMode(modeData))
    {
        ExtraModeData& extraModeData = *GetExtraModeData(modeData);
        //Extension bit 10 is in bit 2.
        uint32_t verticalDisplayEndBit10 = extraModeData.VerticalExtension & Shared::CRTController::VerticalExtension::VerticalDisplayEnableEnd10;
        //Move to bit 10.
        verticalDisplayEndBit10 <<= 8;
        //Move bit in to place.
        verticalDisplayEnd |= verticalDisplayEndBit10;
    }
    return (verticalDisplayEnd + 1) << ScanlineDouble(table);
}

String_t GenerateHorizontalName(uint16_t count, Hag::System::BDA::VideoParameterTable& table)
{
    using namespace Hag;

    char buf[20];
    if (table.AttributeControllerRegisters[VGA::AttributeController::Register::AttributeMode] & 
        VGA::AttributeController::AttributeMode::SelectGraphicsMode)
    {
        uint32_t width = HorizontalDisplayEnableEndPixels(table);
        sprintf(buf, "H%02upix%lu", count, width);
    }
    else
    {
        uint32_t width = HorizontalDisplayEnableEndChars(table);
        sprintf(buf, "H%02uchar%lu", count, width);
    }
    return String_t(buf);
}

String_t GenerateVerticalName(uint16_t count, ModeData& modeData, Hag::System::BDA::VideoParameterTable& table)
{
    using namespace Hag;
    char buf[20];
    if (table.AttributeControllerRegisters[VGA::AttributeController::Register::AttributeMode] & 
        VGA::AttributeController::AttributeMode::SelectGraphicsMode)
    {
        uint32_t height = VerticalDisplayEnableEndLines(modeData, table);
        sprintf(buf, "V%02uline%lu", count, height);
    }
    else
    {
        uint16_t charHeight = table.CRTCRegisters[VGA::CRTController::Register::MaximumScanLine] & VGA::CRTController::MaximumScanLine::MaximumScanLineCount;
        uint32_t height = VerticalDisplayEnableEndLines(modeData, table) / (charHeight + 1);
        sprintf(buf, "V%02uchar%lu", count, height);
    }
    return String_t(buf);
}
String_t GenerateGraphicName(uint16_t count)
{
    char buf[10];

    sprintf(buf, "G%02u", count);

    return String_t(buf);
}

String_t GenerateConfigurationName(uint16_t count)
{
    char buf[10];

    sprintf(buf, "C%02u", count);

    return String_t(buf);
}

String_t GenerateAttributeName(uint16_t count)
{
    char buf[10];

    sprintf(buf, "A%02u", count);

    return String_t(buf);
}

String_t GenerateFontConfigName(uint16_t count)
{
    char buf[10];

    sprintf(buf, "F%02u", count);

    return String_t(buf);
}

String_t GenerateParameterName(uint16_t count)
{
    char buf[10];

    sprintf(buf, "P%02u", count);

    return String_t(buf);
}

String_t GenerateParameterArrayName(uint16_t count)
{
    char buf[10];

    sprintf(buf, "PA%02u", count);

    return String_t(buf);
}

String_t GenerateResolutionName(uint16_t count, ModeData& modeData, Hag::System::BDA::VideoParameterTable& table)
{
    using namespace Hag;
    char buf[20];
    if (table.AttributeControllerRegisters[VGA::AttributeController::Register::AttributeMode] & 
        VGA::AttributeController::AttributeMode::SelectGraphicsMode)
    {
        uint32_t width = HorizontalDisplayEnableEndPixels(table);
        uint32_t height = VerticalDisplayEnableEndLines(modeData, table);
        sprintf(buf, "T%02upix%lux%lu", count, width, height);
    }
    else
    {
        uint32_t width = HorizontalDisplayEnableEndChars(table);
        uint16_t charHeight = table.CRTCRegisters[VGA::CRTController::Register::MaximumScanLine] & VGA::CRTController::MaximumScanLine::MaximumScanLineCount;
        uint32_t height = VerticalDisplayEnableEndLines(modeData, table) / (charHeight + 1);
        sprintf(buf, "T%02uchar%lux%lu", count, width, height);
    }

    return String_t(buf);
}

uint16_t PrintHorizontalTimings(ModeData& modeData, Hag::System::BDA::VideoParameterTable& table, const char* name)
{
    char buf[100];
    sprintf(buf, "{ 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X }",
        table.CRTCRegisters[0x00],
        table.CRTCRegisters[0x01],
        table.CRTCRegisters[0x02],
        table.CRTCRegisters[0x03] | 0x80,
        table.CRTCRegisters[0x04],
        table.CRTCRegisters[0x05]);

    for (uint16_t idx = 0; idx < s_HorizontalTimings.size(); ++idx)
    {
        if (s_HorizontalTimings[idx] == buf)
            return idx;
    }

    s_HorizontalTimings.push_back(buf);
    s_HorizontalTimingNames.push_back(GenerateHorizontalName(s_HorizontalTimingNames.size(), table));

    return s_HorizontalTimings.size() - 1;
}

StringVector_t s_VerticalTimings;
StringVector_t s_VerticalTimingNames;

uint16_t PrintVerticalTimings(ModeData& modeData, Hag::System::BDA::VideoParameterTable& table, const char* name)
{
    using namespace Hag;
    char buf[100];
    sprintf(buf, "{ 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X }",
        table.CRTCRegisters[0x06],
        table.CRTCRegisters[0x07],
        table.CRTCRegisters[0x09] & VGA::CRTController::MaximumScanLine::StartVerticalBlankHigh,
        table.CRTCRegisters[0x10],
        table.CRTCRegisters[0x11] & VGA::CRTController::VerticalRetraceEnd::VerticalRetraceEndCount,
        table.CRTCRegisters[0x12],
        table.CRTCRegisters[0x15],
        table.CRTCRegisters[0x16]);

    for (uint16_t idx = 0; idx < s_VerticalTimings.size(); ++idx)
    {
        if (s_VerticalTimings[idx] == buf)
            return idx;
    }

    s_VerticalTimings.push_back(buf);
    s_VerticalTimingNames.push_back(GenerateVerticalName(s_VerticalTimingNames.size(), modeData, table));

    return s_VerticalTimings.size() - 1;
}

StringVector_t s_ResolutionTimings;
StringVector_t s_ResolutionTimingNames;

uint16_t PrintResolutionTimings(ModeData& modeData, Hag::System::BDA::VideoParameterTable& table, const char* name, uint16_t horNameIdx, uint16_t verNameIdx)
{
    using namespace Hag;

    char buf[150];

    ExtraModeData& extraModeData = *GetExtraModeData(modeData);

    uint8_t config = extraModeData.Unknown0 & 0x07;

    sprintf(buf, "{ %s, %s, 0x%02X, 0x%02X, 0x%04X, 0x%02X, 0x%02X, 0x%02X }",
        s_HorizontalTimingNames[horNameIdx].c_str(),
        s_VerticalTimingNames[verNameIdx].c_str(),
        table.MiscellaneousOutputRegister & (VGA::MiscellaneousOutput::SelectNegativeHorizontalSyncPulse | VGA::MiscellaneousOutput::SelectNegativeVerticalSyncPulse),
        table.CRTCRegisters[0x09] & VGA::CRTController::MaximumScanLine::DoubleScan,
        uint16_t(extraModeData.PLLControl0),
        config,
        0,//Horizontal extension...
        extraModeData.VerticalExtension);

    for (uint16_t idx = 0; idx < s_ResolutionTimings.size(); ++idx)
    {
        if (s_ResolutionTimings[idx] == buf)
            return idx;
    }

    s_ResolutionTimings.push_back(buf);
    s_ResolutionTimingNames.push_back(GenerateResolutionName(s_ResolutionTimings.size(), modeData, table));

    return s_ResolutionTimings.size() - 1;
}

StringVector_t s_Graphics;
StringVector_t s_GraphicNames;

uint16_t PrintGraphicsData(Hag::System::BDA::VideoParameterTable& table, const char* name)
{
    char buf[100];
    sprintf(buf, "{ 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X }",
        table.GraphicsControllerRegisters[0x00],
        table.GraphicsControllerRegisters[0x01],
        table.GraphicsControllerRegisters[0x02],
        table.GraphicsControllerRegisters[0x03],
        table.GraphicsControllerRegisters[0x04],
        table.GraphicsControllerRegisters[0x05],
        table.GraphicsControllerRegisters[0x06],
        table.GraphicsControllerRegisters[0x07],
        table.GraphicsControllerRegisters[0x08]);

    for (uint16_t idx = 0; idx < s_Graphics.size(); ++idx)
    {
        if (s_Graphics[idx] == buf)
            return idx;
    }

    s_Graphics.push_back(buf);
    s_GraphicNames.push_back(GenerateGraphicName(s_GraphicNames.size()));

    return s_Graphics.size() - 1;
}

StringVector_t s_Configurations;
StringVector_t s_ConfigurationNames;

uint16_t PrintConfiguration(ModeData& modeData, Hag::System::BDA::VideoParameterTable& table, const char* name, uint16_t gfxNameIdx)
{
    using namespace Hag;

    char buf[200];

    sprintf(buf, "{ 0x%02X, 0x%02X, 0x%02X, 0x%04X, 0x%02X, { 0x%02X, 0x%02X, 0x%02X, 0x%02X, }, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, %s, 0x%02X, 0x%02X, 0x%02X, 0x%02X }",
        table.NumCharacterColumns,
        table.NumScreenRowsMinus1,
        table.CharacterMatrixHeightInPoints,
        table.VideoBufferSize,
        table.MiscellaneousOutputRegister & ~(VGA::MiscellaneousOutput::SelectNegativeHorizontalSyncPulse | VGA::MiscellaneousOutput::SelectNegativeVerticalSyncPulse),
        table.SequencerRegisters[0],
        table.SequencerRegisters[1],
        table.SequencerRegisters[2],
        table.SequencerRegisters[3],
        table.CRTCRegisters[0x08],
        table.CRTCRegisters[0x09] & VGA::CRTController::MaximumScanLine::LineCompareHigh,
        table.CRTCRegisters[0x11] & ~VGA::CRTController::VerticalRetraceEnd::VerticalRetraceEndCount,
        table.CRTCRegisters[0x14],
        table.CRTCRegisters[0x17],
        table.CRTCRegisters[0x18],
        s_GraphicNames[gfxNameIdx].c_str(),
        table.AttributeControllerRegisters[0x10],
        table.AttributeControllerRegisters[0x11],
        table.AttributeControllerRegisters[0x12],
        table.AttributeControllerRegisters[0x13]);

    for (uint16_t idx = 0; idx < s_Configurations.size(); ++idx)
    {
        if (s_Configurations[idx] == buf)
            return idx;
    }

    s_Configurations.push_back(buf);
    s_ConfigurationNames.push_back(GenerateConfigurationName(s_ConfigurationNames.size()));

    return s_Configurations.size() - 1;
}

StringVector_t s_Attributes;
StringVector_t s_AttributeNames;

uint16_t PrintAttributeData(Hag::System::BDA::VideoParameterTable& table, const char* name)
{
    char buf[150];
    sprintf(buf, "{ 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X }",
        table.AttributeControllerRegisters[0x00],
        table.AttributeControllerRegisters[0x01],
        table.AttributeControllerRegisters[0x02],
        table.AttributeControllerRegisters[0x03],
        table.AttributeControllerRegisters[0x04],
        table.AttributeControllerRegisters[0x05],
        table.AttributeControllerRegisters[0x06],
        table.AttributeControllerRegisters[0x07],
        table.AttributeControllerRegisters[0x08],
        table.AttributeControllerRegisters[0x09],
        table.AttributeControllerRegisters[0x0A],
        table.AttributeControllerRegisters[0x0B],
        table.AttributeControllerRegisters[0x0C],
        table.AttributeControllerRegisters[0x0D],
        table.AttributeControllerRegisters[0x0E],
        table.AttributeControllerRegisters[0x0F]);

    for (uint16_t idx = 0; idx < s_Attributes.size(); ++idx)
    {
        if (s_Attributes[idx] == buf)
            return idx;
    }

    s_Attributes.push_back(buf);
    s_AttributeNames.push_back(GenerateAttributeName(s_AttributeNames.size()));

    return s_Attributes.size() - 1;
}

StringVector_t s_FontConfigs;
StringVector_t s_FontConfigNames;

uint16_t PrintFontConfig(ModeData& modeData, const char* name, Hag::System::BDA::VideoParameterTable& table)
{
    using namespace Hag;

    uint8_t charHeight = table.CharacterMatrixHeightInPoints;

    const char* fontName = "Font8x8";
    if (charHeight > 8)
        fontName = "Font8x14";
    if (charHeight > 15)
        fontName = "Font8x16";

    char buf[100];

    uint8_t renderHeight = table.CRTCRegisters[0x09] & VGA::CRTController::MaximumScanLine::MaximumScanLineCount;
    uint8_t start = table.CRTCRegisters[0x0A];
    uint8_t end = table.CRTCRegisters[0x0B];

    sprintf(buf, "{ VGA::Data::%s, 0xFF, 0x%02X, 0x%02X, %s, 0x%02X, 0x%02X, 0x%02X }",
        fontName,
        charHeight,
        0,
        !Is8Dot() ? "true" : "false",
        renderHeight,
        start,
        end);

    for (uint16_t idx = 0; idx < s_FontConfigs.size(); ++idx)
    {
        if (s_FontConfigs[idx] == buf)
            return idx;
    }

    s_FontConfigs.push_back(buf);
    s_FontConfigNames.push_back(GenerateFontConfigName(s_FontConfigNames.size()));

    return s_FontConfigs.size() - 1;
}

StringVector_t s_Parameters;
StringVector_t s_ParameterNames;

uint16_t PrintVideoParameters(const char* name, uint16_t resNameIdx, uint16_t cfgNameIdx, uint16_t atrNameIdx, uint16_t fntNameIdx)
{
    char buf[100];
    sprintf(buf, "{ %s, %s, %s, %s }",
        s_ResolutionTimingNames[resNameIdx].c_str(),
        s_ConfigurationNames[cfgNameIdx].c_str(),
        s_AttributeNames[atrNameIdx].c_str(),
        s_FontConfigNames[fntNameIdx].c_str());

    for (uint16_t idx = 0; idx < s_Parameters.size(); ++idx)
    {
        if (s_Parameters[idx] == buf)
            return idx;
    }

    s_Parameters.push_back(buf);
    s_ParameterNames.push_back(GenerateParameterName(s_ParameterNames.size()));

    return s_Parameters.size() - 1;
}

StringVector_t s_ParameterArrays;
StringVector_t s_ParameterArrayNames;

uint16_t PrintVideoParametersArray(const char* name, bool multi, uint16_t* parameterNameIndices)
{
    char buf[100];
    if (multi)
    {
        sprintf(buf, "{ &%s, &%s, &%s, &%s }",
            s_ParameterNames[parameterNameIndices[0]].c_str(),
            s_ParameterNames[parameterNameIndices[1]].c_str(),
            s_ParameterNames[parameterNameIndices[2]].c_str(),
            s_ParameterNames[parameterNameIndices[3]].c_str());
    }
    else
    {
        sprintf(buf, "{ &%s }",
            s_ParameterNames[parameterNameIndices[0]].c_str());
    }

    for (uint16_t idx = 0; idx < s_ParameterArrays.size(); ++idx)
    {
        if (s_ParameterArrays[idx] == buf)
            return idx;
    }

    s_ParameterArrays.push_back(buf);
    s_ParameterArrayNames.push_back(GenerateParameterArrayName(s_ParameterArrayNames.size()));

    return s_ParameterArrays.size() - 1;
}

struct ModeToName
{
    uint16_t mode;
    const char* name;
};

ModeToName modeToName[] = 
{
    { 0x00, "T40x25x4bppG" },
    { 0x01, "T40x25x4bppC" },
    { 0x02, "T80x25x4bppG" },
    { 0x03, "T80x25x4bppC" },
    { 0x04, "G320x200x2bppC" },
    { 0x05, "G320x200x2bppG" },
    { 0x06, "G640x200x1bppM" },
    { 0x07, "T80x25x1bppM" },
    { 0x0D, "G320x200x4bppC" },
    { 0x0E, "G640x200x4bppC" },
    { 0x0F, "G640x350x1bppM" },
    { 0x10, "G640x350x4bppC" },
    { 0x11, "G640x480x1bppM" },
    { 0x12, "G640x480x4bppC" },
    { 0x13, "G320x200x8bppC" },
    { 0x100, "G640x400x8bpp" },
    { 0x101, "G640x480x8bpp" },
    { 0x102, "G800x600x4bpp" },
    { 0x103, "G800x600x8bpp" },
    { 0x104, "G1024x768x4bpp" },
    { 0x105, "G1024x768x8bpp" },
    { 0x106, "G1280x1024x4bpp" },
    { 0x107, "G1280x1024x8bpp" },
    { 0x108, "T80x60x4bpp" },
    { 0x109, "T132x25x4bpp" },
    { 0x10A, "T132x43x4bpp" },
    { 0x10B, "T132x50x4bpp" },
    { 0x10C, "T132x60x4bpp" },
    { 0x10D, "G320x200x15bpp" },
    { 0x10E, "G320x200x16bpp" },
    { 0x10F, "G320x200x32bpp" },
    { 0x110, "G640x480x15bpp" },
    { 0x111, "G640x480x16bpp" },
    { 0x112, "G640x480x32bpp" },
    { 0x113, "G800x600x15bpp" },
    { 0x114, "G800x600x16bpp" },
    { 0x115, "G800x600x32bpp" },
    { 0x116, "G1024x768x15bpp" },
    { 0x117, "G1024x768x16bpp" },
    { 0x118, "G1024x768x32bpp" },
    { 0x119, "G1280x1024x15bpp" },
    { 0x11A, "G1280x1024x16bpp" },
    { 0x11B, "G1280x1024x32bpp" },
    { 0x11C, "G1600x1200x8bpp" },
    { 0x11D, "G1600x1200x15bpp" },
    { 0x11E, "G1600x1200x16bpp" },
    { 0x11F, "G1600x1200x32bpp" },
    { 0x121, "G640x400x15bpp" },
    { 0x122, "G640x400x16bpp" },
    { 0x124, "G640x400x32bpp" },
    { 0x123, "G640x400x24bpp" },
    { 0x1B3, "G512x384x32bpp" },
    { 0x1B5, "G400x300x32bpp" },
    { 0x1B8, "G320x240x32bpp" },
    { 0x1D4, "G512x384x16bpp" },
    { 0x1D6, "G400x300x16bpp" },
    { 0x1D9, "G320x240x16bpp" },
    { 0x1E4, "G512x384x15bpp" },
    { 0x1E6, "G400x300x15bpp" },
    { 0x1E9, "G320x240x15bpp" },
    { 0x1F3, "G512x384x8bpp" },
    { 0x1F5, "G400x300x8bpp" },
    { 0x1F8, "G320x240x8bpp" },
    { 0x1F9, "G320x200x8bpp" },
};

uint32_t GetFrequencyKHz(ModeData& modeData, Hag::System::BDA::VideoParameterTable& table)
{
    using namespace Hag;
    using namespace Hag::TDfx;
    uint8_t clockSelect = table.MiscellaneousOutputRegister & VGA::MiscellaneousOutput::ClockSelect;
    if (clockSelect == VGA::MiscellaneousOutput::ClockSelect25p175MHz)
    {
        return 25175;
    }
    else if (clockSelect == VGA::MiscellaneousOutput::ClockSelect28p322MHz)
    {
        return 28322;
    }
    else
    {
        ExtraModeData& extraModeData = *GetExtraModeData(modeData);
        uint8_t N = uint8_t((extraModeData.PLLControl0 & Shared::PLLControl0::NMultiplier) >> Shared::PLLControl0::Shift::NMultiplier);
        uint8_t M = uint8_t((extraModeData.PLLControl0 & Shared::PLLControl0::MInputDivider) >> Shared::PLLControl0::Shift::MInputDivider);
        uint8_t K = uint8_t((extraModeData.PLLControl0 & Shared::PLLControl0::KPostDivider) >> Shared::PLLControl0::Shift::KPostDivider);
        return CalculatePLLFrequency(N, M, K) / 1000;
    }
}

uint32_t HorizontalTotalChars(ModeData& modeData, Hag::System::BDA::VideoParameterTable& table)
{
    using namespace Hag;
    uint32_t horizontalTotal = table.CRTCRegisters[VGA::CRTController::Register::HorizontalTotal];
    if (IsExtendedMode(modeData))
    {
        //Extension bit 8 is in bit 0.
        uint32_t horizontalTotalBit8 = 0;
        //Move to bit 8.
        horizontalTotalBit8 <<= 8;
        //Move bit in to place.
        horizontalTotal |= horizontalTotalBit8;
    }
    return horizontalTotal + 5;
}

uint32_t HorizontalTotalPixels(ModeData& modeData, Hag::System::BDA::VideoParameterTable& table)
{
    return HorizontalTotalChars(modeData, table) * CharacterClockInPixels(table);
}

uint32_t VerticalTotalLines(ModeData& modeData, Hag::System::BDA::VideoParameterTable& table)
{
    using namespace Hag;
    using namespace Hag::TDfx;

    uint32_t verticalTotal = table.CRTCRegisters[VGA::CRTController::Register::VerticalTotal];
    //Extension bit 8 is in bit 0.
    uint32_t verticalTotalBit8 = table.CRTCRegisters[VGA::CRTController::Register::CRTCOverflow] & VGA::CRTController::CRTCOverflow::VerticalTotalHigh1;
    //Move to bit 8.
    verticalTotalBit8 <<= 8;
    //Move bit in to place.
    verticalTotal |= verticalTotalBit8;
    //Extension bit 9 is in bit 5.
    uint32_t verticalTotalBit9 = table.CRTCRegisters[VGA::CRTController::Register::CRTCOverflow] & VGA::CRTController::CRTCOverflow::VerticalTotalHigh2;
    //Move to bit 9.
    verticalTotalBit9 <<= 4;
    //Move bit in to place.
    verticalTotal |= verticalTotalBit9;
    if (IsExtendedMode(modeData))
    {
        ExtraModeData& extraModeData = *GetExtraModeData(modeData);

        //Extension bit 10 is in bit 0.
        uint32_t verticalTotalBit10 = extraModeData.VerticalExtension & Shared::CRTController::VerticalExtension::VerticalTotal10;
        //Move to bit 10.
        verticalTotalBit10 <<= 10;
        //Move bit in to place.
        verticalTotal |= verticalTotalBit10;
    }
    return (verticalTotal + 2) << ScanlineDouble(table);
}

float RefreshRateHz(ModeData& modeData, Hag::System::BDA::VideoParameterTable& table)
{
    uint32_t horizontalTotalPixels = HorizontalTotalPixels(modeData, table);
    uint32_t verticalTotalLines = VerticalTotalLines(modeData, table);
    float refreshRate = (float(GetFrequencyKHz(modeData, table)) / (horizontalTotalPixels * verticalTotalLines)) * 1000.0f;

    return refreshRate;
}

uint16_t GetSegment(ModeData& modeData)//Offset 0x3740
{
    switch (modeData.Flags)
    {
    case 0x00:
    case 0x02:
        return 0xb800;
    case 0x01:
        return 0xb000;
    default:
        return 0xa000;
    }
}

void PrintDescriptor2(ModeData& modeData, Hag::System::BDA::VideoParameterTable& table, const char* name, const char* parameterArrayName)
{
    using namespace Hag;

    uint16_t bpp = modeData.BitsPerPixel;
    if (bpp == 0)
        bpp = 1;
    if (modeData.LegacyMode == 0x0F)
        bpp = 2;
    bool text = ((table.AttributeControllerRegisters[VGA::AttributeController::Register::AttributeMode] &
        VGA::AttributeController::AttributeMode::SelectGraphicsMode) == 0) && (modeData.Width < 200);
    bool color = (table.AttributeControllerRegisters[VGA::AttributeController::Register::AttributeMode] &
        VGA::AttributeController::AttributeMode::SelectMonochromeAttributes) == 0;
        // Modes: 0x0F, 0x0D, 0x0E, 0x10, 0x12, (Y, X)
        //        0x0102 0x0108 0x0109 0x010A 0x010B 0x010C
    bool sequential = (modeData.LegacyMode != 0x0F) &&
                      (modeData.LegacyMode != 0x0D) &&
                      (modeData.LegacyMode != 0x0E) &&
                      (modeData.LegacyMode != 0x10) &&
                      (modeData.LegacyMode != 0x12) &&
                      (modeData.VesaMode != 0x102) &&
                      (modeData.VesaMode != 0x108) &&
                      (modeData.VesaMode != 0x109) &&
                      (modeData.VesaMode != 0x10A) &&
                      (modeData.VesaMode != 0x10B) &&
                      (modeData.VesaMode != 0x10C);
    bool linearFrameBuffer = (modeData.VesaMode >= 0x100) &&
                             (modeData.VesaMode != 0x102) &&
                             (modeData.VesaMode != 0x108) &&
                             (modeData.VesaMode != 0x109) &&
                             (modeData.VesaMode != 0x10A) &&
                             (modeData.VesaMode != 0x10B) &&
                             (modeData.VesaMode != 0x10C);

    uint16_t parameterIndices[4] = {0,0,0,0};
    uint16_t parametercount = GetParameterIndices(modeData.LegacyMode, parameterIndices);
    float refreshFreq = RefreshRateHz(modeData, table);
    uint16_t refreshRate = uint16_t(refreshFreq + 0.5f);
    if (refreshRate == 59)
        refreshRate = 60;
    if (refreshRate == 71)
        refreshRate = 72;

    static uint8_t CRTControlRegValues[]=
    {
        0x2C,
        0x28,
        0x2D,
        0x29,
        0x2A,
        0x2E,
        0x1E,
        0x29
    };

    uint8_t crtModeControlRegValue = 0xFF;
    uint8_t cgaColorPaletteMaskSetting = 0xFF;
    if (modeData.LegacyMode <= VGA::VideoMode::T80x25x1bppM)
    {
        crtModeControlRegValue = CRTControlRegValues[modeData.LegacyMode];
        cgaColorPaletteMaskSetting = 0x3f;

        if (modeData.LegacyMode != VGA::VideoMode::G640x200x1bppM)
            cgaColorPaletteMaskSetting = 0x30;
    }
    char params[75];
    if (parametercount == 1)
        sprintf(params, "parameter: 0x%02X", parameterIndices[0]);
    else
        sprintf(params, "parameter: 0x%02X, 0x%02X, 0x%02X, 0x%02X", parameterIndices[0], parameterIndices[1], parameterIndices[2], parameterIndices[3]);

    printf("    { // Mode %s %s\n", name, params);
    printf("        %i,\n", modeData.Width);
    printf("        %i,\n", modeData.Height);
    printf("        VGA::ModeSetting::BitsPerPixel::Bpp%i,\n", modeData.BitsPerPixel);
    printf("        ");
    printf(text ? "VGA::ModeSetting::Flags::Text | " : "VGA::ModeSetting::Flags::Graphics | ");
    printf(color ? "VGA::ModeSetting::Flags::Color | " : "VGA::ModeSetting::Flags::Monochrome | ");
    printf(sequential ? "VGA::ModeSetting::Flags::Sequential | " : "VGA::ModeSetting::Flags::Planar | ");
    printf(linearFrameBuffer ? "VGA::ModeSetting::Flags::LinearFramebuffer | " : "");
    printf((parametercount == 1) ? "VGA::ModeSetting::Flags::SingleParameter" : "VGA::ModeSetting::Flags::MultiParameter");
    if (modeData.VesaMode >= 0x100) printf(" | Function::ModeSetting::Flags::TDfx,\n"); else printf(",\n");
    printf("        VGA::ModeSetting::RefreshRate::R%iHz,\n", refreshRate);
    printf("        ");
    bool videoModeFound = false;
    for (uint32_t i = 0; i < sizeof(modeToName) / sizeof(ModeToName); ++i)
    {
        if (modeData.VesaMode == modeToName[i].mode)
        {
            videoModeFound = true;
            if (modeData.VesaMode < 0x100)
            {
                printf("Hag::VGA::VideoMode::%s,\n", modeToName[i].name);
            }
            else
            {
                printf("0x%02X,//Hag::Vesa::VideoMode::%s\n", modeData.LegacyMode, modeToName[i].name);
            }

            break;
        }
    }

    if (!videoModeFound)
    {
        printf("0x%02X,\n", modeData.LegacyMode);
    }

    printf("        0x%04X,\n", GetSegment(modeData));

    if (color)
    {
        printf("        VGA::Register::CRTControllerIndexD,\n");
    }
    else
    {
        printf("        VGA::Register::CRTControllerIndexB,\n");
    }

    if (color)
    {
        printf("        Hag::System::BDA::DetectedHardware::Color80x25,\n");
    }
    else
    {
        printf("        Hag::System::BDA::DetectedHardware::Monochrome80x25,\n");
    }
    uint16_t sl = (parametercount == 1) ? 0 : VerticalDisplayEnableEndLines(modeData, table) >> ScanlineDouble(table);
    switch(sl)
    {
    case 200:
        printf("        VGA::ModeSetting::Scanlines::S200,\n");
        break;
    case 350:
        printf("        VGA::ModeSetting::Scanlines::S350,\n");
        break;
    case 400:
        printf("        VGA::ModeSetting::Scanlines::S400,\n");
        break;
    case 480:
        printf("        VGA::ModeSetting::Scanlines::S480,\n");
        break;
    default:
        printf("        VGA::ModeSetting::Scanlines::Invalid,\n");
        break;
    }

    if (crtModeControlRegValue == 0xFF)
    {
        printf("        0xFF");
    }
    else
    {
        bool firstPrinted = false;
        printf("        ");
        if ((crtModeControlRegValue & Hag::System::BDA::CRTModeControlRegValue::Mode2Or3Text) != 0)
        {
            printf("Hag::System::BDA::CRTModeControlRegValue::Mode2Or3Text");
            firstPrinted = true;
        }
        if ((crtModeControlRegValue & Hag::System::BDA::CRTModeControlRegValue::Mode4Or5Graphics) != 0)
        {
            if (firstPrinted)
            {
                printf(" | ");
            }
            printf("Hag::System::BDA::CRTModeControlRegValue::Mode4Or5Graphics");
            firstPrinted = true;
        }
        if ((crtModeControlRegValue & Hag::System::BDA::CRTModeControlRegValue::Monochrome) != 0)
        {
            if (firstPrinted)
            {
                printf(" | ");
            }
            printf("Hag::System::BDA::CRTModeControlRegValue::Monochrome");
            firstPrinted = true;
        }
        if ((crtModeControlRegValue & Hag::System::BDA::CRTModeControlRegValue::VideoEnabled) != 0)
        {
            if (firstPrinted)
            {
                printf(" | ");
            }
            printf("Hag::System::BDA::CRTModeControlRegValue::VideoEnabled");
            firstPrinted = true;
        }
        if ((crtModeControlRegValue & Hag::System::BDA::CRTModeControlRegValue::GraphicsOperation) != 0)
        {
            if (firstPrinted)
            {
                printf(" | ");
            }
            printf("Hag::System::BDA::CRTModeControlRegValue::GraphicsOperation");
            firstPrinted = true;
        }
        if ((crtModeControlRegValue & Hag::System::BDA::CRTModeControlRegValue::Blinking) != 0)
        {
            if (firstPrinted)
            {
                printf(" | ");
            }
            printf("Hag::System::BDA::CRTModeControlRegValue::Blinking");
            firstPrinted = true;
        }
        if (!firstPrinted)
        {
            printf("0x00");
        }
    }
    printf(",\n");

    printf("        0x%02X,\n", cgaColorPaletteMaskSetting);

    printf("        ");

    uint16_t index = modeData.Flags;
    if (index > 9)
        index = 9;
        
    switch(index)
    {
    case 0:         // Text 4bpp    EGA
        printf("VGA::Data::EGAPair,\n");
        break;
    case 1:         // hercules
        printf("VGA::Data::HerculesPair,\n");
        break;
    case 2:         // CGA
        printf("VGA::Data::CGAPair,\n");
        break;
    case 3:         // hercules
        printf("VGA::Data::HerculesPair,\n");
        break;
    case 4:         // EGA
        printf("VGA::Data::EGAPair,\n");
        break;
    case 5:         // Graphics 4bpp    CGA
        printf("VGA::Data::CGAPair,\n");
        break;
    case 6:         // Graphics 8bpp    MCGA
        printf("VGA::Data::MCGAPairs,\n");
        break;
    default:
        printf("nullptr,\n");
        break;
    }
    printf("        %s,\n", parameterArrayName);
    printf("        0x%02X\n", table.CRTCRegisters[VGA::CRTController::Register::ScreenOffset]);
    printf("    },\n");
}

void PrintNewModeSettings()
{
    using namespace Hag::System;

    char name[100];
    char subname[50];
    std::vector<uint16_t> parameterArrayNameIndices;

    for (uint32_t i = 0; i < sizeof(s_ModeData) / sizeof(ModeData); ++i)
    {
        ModeData& mode = s_ModeData[i];

        uint16_t parameterIndices[4] = {0,0,0,0};
        uint32_t loopCount = GetParameterIndices(mode.LegacyMode, parameterIndices);

        uint16_t parameterNameIndices[4] = {0,0,0,0};
        for (uint32_t tableIdx = 0; tableIdx < loopCount; ++tableIdx)
        {
            if (parameterIndices[tableIdx] >= (sizeof(s_VideoParameters) / sizeof(Hag::System::BDA::VideoParameterTable)))
                printf("OUT OF BOUNDS: 0x%04X\n", parameterIndices[tableIdx]);
            BDA::VideoParameterTable& table = s_VideoParameters[parameterIndices[tableIdx]];

            sprintf(subname, "%X", mode.VesaMode);

            if (loopCount > 1)
            {
                const char* sl = "200";
                if (tableIdx == 1)
                    sl = "350";
                if (tableIdx == 2)
                    sl = "400";
                if (tableIdx == 3)
                    sl = "480";
                
                sprintf(name, "Mode%sSL%s", subname, sl);
            }
            else
            {
                sprintf(name, "Mode%s", subname);
            }
            uint16_t horNameIdx = PrintHorizontalTimings(mode, table, name);
            uint16_t verNameIdx = PrintVerticalTimings(mode, table, name);
            uint16_t resNameIdx = PrintResolutionTimings(mode, table, name, horNameIdx, verNameIdx);
            uint16_t gfxNameIdx = PrintGraphicsData(table, name);
            uint16_t cfgNameIdx = PrintConfiguration(mode, table, name, gfxNameIdx);
            uint16_t atrNameIdx = PrintAttributeData(table, name);
            uint16_t fntNameIdx = PrintFontConfig(mode, name, table);
            uint16_t parNameIdx = PrintVideoParameters(name, resNameIdx, cfgNameIdx, atrNameIdx, fntNameIdx);
            parameterNameIndices[tableIdx] = parNameIdx;
            sprintf(name, "Mode%s", subname);
        }
        parameterArrayNameIndices.push_back(PrintVideoParametersArray(name, loopCount > 1, parameterNameIndices));
    }

    printf("\n\n\n//Horizontal timings:\n\n");
    for (StringVector_t::iterator
         itr = s_HorizontalTimings.begin(),
         nitr = s_HorizontalTimingNames.begin();
         (itr != s_HorizontalTimings.end()) &&
         (nitr != s_HorizontalTimingNames.end());
         ++itr, ++nitr)
    {
        printf("VGA::ModeSetting::HorizontalTimings %s = %s;\n", nitr->c_str(), itr->c_str());
    }

    printf("\n//Vertical timings:\n\n");
    for (StringVector_t::iterator
        itr = s_VerticalTimings.begin(),
        nitr = s_VerticalTimingNames.begin();
        (itr != s_VerticalTimings.end()) &&
        (nitr != s_VerticalTimingNames.end());
        ++itr, ++nitr)
    {
        printf("VGA::ModeSetting::VerticalTimings %s = %s;\n", nitr->c_str(), itr->c_str());
    }

    printf("\n//Resolution timings:\n\n");
    for (StringVector_t::iterator
        itr = s_ResolutionTimings.begin(),
        nitr = s_ResolutionTimingNames.begin();
        (itr != s_ResolutionTimings.end()) &&
        (nitr != s_ResolutionTimingNames.end());
        ++itr, ++nitr)
    {
        printf("Function::ModeSetting::ResolutionTimings %s = %s;\n", nitr->c_str(), itr->c_str());
    }

    printf("\n//Graphics:\n\n");
    for (StringVector_t::iterator
        itr = s_Graphics.begin(),
        nitr = s_GraphicNames.begin();
        (itr != s_Graphics.end()) &&
        (nitr != s_GraphicNames.end());
        ++itr, ++nitr)
    {
        printf("VGA::GraphicsControllerData_t %s[] = %s;\n", nitr->c_str(), itr->c_str());
    }

    printf("\n//Attributes:\n\n");
    for (StringVector_t::iterator
        itr = s_Attributes.begin(),
        nitr = s_AttributeNames.begin();
        (itr != s_Attributes.end()) &&
        (nitr != s_AttributeNames.end());
        ++itr, ++nitr)
    {
        printf("VGA::AttributeControllerData_t %s[] = %s;\n", nitr->c_str(), itr->c_str());
    }

    printf("\n//Configurations:\n\n");
    for (StringVector_t::iterator
        itr = s_Configurations.begin(),
        nitr = s_ConfigurationNames.begin();
        (itr != s_Configurations.end()) &&
        (nitr != s_ConfigurationNames.end());
        ++itr, ++nitr)
    {
        printf("VGA::ModeSetting::Configuration %s = %s;\n", nitr->c_str(), itr->c_str());
    }

    printf("\n//Font Configurations:\n\n");
    for (StringVector_t::iterator
        itr = s_FontConfigs.begin(),
        nitr = s_FontConfigNames.begin();
        (itr != s_FontConfigs.end()) &&
        (nitr != s_FontConfigNames.end());
        ++itr, ++nitr)
    {
        printf("VGA::Data::FontConfiguration %s = %s;\n", nitr->c_str(), itr->c_str());
    }

    printf("\n//Video Parameters:\n\n");
    for (StringVector_t::iterator
        itr = s_Parameters.begin(),
        nitr = s_ParameterNames.begin();
        (itr != s_Parameters.end()) &&
        (nitr != s_ParameterNames.end());
        ++itr, ++nitr)
    {
        printf("VGA::ModeSetting::VideoParameters %s = %s;\n", nitr->c_str(), itr->c_str());
    }

    printf("\n//Video Parameter Arrays:\n\n");
    for (StringVector_t::iterator
        itr = s_ParameterArrays.begin(),
        nitr = s_ParameterArrayNames.begin();
        (itr != s_ParameterArrays.end()) &&
        (nitr != s_ParameterArrayNames.end());
        ++itr, ++nitr)
    {
        printf("const VGA::ModeSetting::VideoParameters* %s[] = %s;\n", nitr->c_str(), itr->c_str());
    }

    printf("\nFunction::ModeSetting::ModeDescriptor s_Descriptors[] =\n{\n");
    for (uint32_t i = 0; i < sizeof(s_ModeData) / sizeof(ModeData); ++i)
    {
        ModeData& mode = s_ModeData[i];

        sprintf(name, "%X", mode.VesaMode);
            
        uint16_t parameterIndices[4] = {0,0,0,0};
        GetParameterIndices(mode.LegacyMode, parameterIndices);

        BDA::VideoParameterTable& table = s_VideoParameters[parameterIndices[0]];

        PrintDescriptor2(mode, table, name, s_ParameterArrayNames[parameterArrayNameIndices[i]].c_str());
    }
    printf("};\n");

}

int main(void)
{
    using namespace Hag;
    using namespace Hag::System;

    if (!__djgpp_nearptr_enable())
    {
        printf("Please remove any DPMI hosts (like EMM386).\n");
        return -1;
    }

    Support::Allocator allocator;

#ifndef MOCK

    //PrintNewModeSettings();

    VGA::ModeSetting::Initialize(allocator);

    Testing::TestPatterns::TestVideoModes();

    /*
    SetVideoMode(0x03);
    //SetVideoMode(0x07);
    VGA::ModeSetting::SetVideoMode(80, 25, VGA::ModeSetting::BitsPerPixel::Bpp1, VGA::ModeSetting::Flags::Text | VGA::ModeSetting::Flags::Monochrome);
    Testing::TestPatterns::DrawTextPattern(80, 25, FARPointer(uint16_t(0xb000), 0x0000).ToPointer<uint8_t>());
    getchar();

    SetVideoMode(0x03);
    //SetVideoMode(0x01);
    VGA::ModeSetting::SetVideoMode(40, 25, VGA::ModeSetting::BitsPerPixel::Bpp4, VGA::ModeSetting::Flags::Text);
    Testing::TestPatterns::DrawTextPattern(40, 25, FARPointer(uint16_t(0xb800), 0x0000).ToPointer<uint8_t>());
    getchar();

    SetVideoMode(0x07);
    //SetVideoMode(0x03);
    VGA::ModeSetting::SetVideoMode(80, 25, VGA::ModeSetting::BitsPerPixel::Bpp4, VGA::ModeSetting::Flags::Text);
    Testing::TestPatterns::DrawTextPattern(80, 25, FARPointer(uint16_t(0xb800), 0x0000).ToPointer<uint8_t>());
    getchar();

    SetVideoMode(0x03);
    //SetVideoMode(0x06);
    VGA::ModeSetting::SetVideoMode(640, 200, VGA::ModeSetting::BitsPerPixel::Bpp1, VGA::ModeSetting::Flags::Monochrome);
    Testing::TestPatterns::Draw1BppPattern2(640, 200, FARPointer(uint16_t(0xb800), 0x0000).ToPointer<uint8_t>());
    getchar();

    SetVideoMode(0x03);
    //SetVideoMode(0x0f);
    VGA::ModeSetting::SetVideoMode(640, 350, VGA::ModeSetting::BitsPerPixel::Bpp2, VGA::ModeSetting::Flags::Monochrome | VGA::ModeSetting::Flags::Planar);
    Testing::TestPatterns::Draw2BppPlanarPattern(640, 350, FARPointer(uint16_t(0xa000), 0x0000).ToPointer<uint8_t>());
    getchar();
   
    SetVideoMode(0x03);
    //SetVideoMode(0x11);
    VGA::ModeSetting::SetVideoMode(640, 480, VGA::ModeSetting::BitsPerPixel::Bpp1, VGA::ModeSetting::Flags::Monochrome);
    Testing::TestPatterns::Draw1BppPattern(640, 480, FARPointer(uint16_t(0xa000), 0x0000).ToPointer<uint8_t>());
    getchar();

    SetVideoMode(0x03);
    //SetVideoMode(0x04);
    VGA::ModeSetting::SetVideoMode(320, 200, VGA::ModeSetting::BitsPerPixel::Bpp2);
    Testing::TestPatterns::Draw2BppPattern(320, 200, FARPointer(uint16_t(0xb800), 0x0000).ToPointer<uint8_t>());
    getchar();

    SetVideoMode(0x03);
    //SetVideoMode(0x0d);
    VGA::ModeSetting::SetVideoMode(320, 200, VGA::ModeSetting::BitsPerPixel::Bpp4, VGA::ModeSetting::Flags::Planar);
    Testing::TestPatterns::Draw4BppPattern(320, 200, FARPointer(uint16_t(0xa000), 0x0000).ToPointer<uint8_t>());
    getchar();
   
    SetVideoMode(0x03);
    //SetVideoMode(0x0e);
    VGA::ModeSetting::SetVideoMode(640, 200, VGA::ModeSetting::BitsPerPixel::Bpp4, VGA::ModeSetting::Flags::Planar);
    Testing::TestPatterns::Draw4BppPattern(640, 200, FARPointer(uint16_t(0xa000), 0x0000).ToPointer<uint8_t>());
    getchar();

    SetVideoMode(0x03);
    //SetVideoMode(0x10);
    VGA::ModeSetting::SetVideoMode(640, 350, VGA::ModeSetting::BitsPerPixel::Bpp4, VGA::ModeSetting::Flags::Planar);
    Testing::TestPatterns::Draw4BppPattern(640, 350, FARPointer(uint16_t(0xa000), 0x0000).ToPointer<uint8_t>());
    getchar();

    SetVideoMode(0x03);
    //SetVideoMode(0x12);
    VGA::ModeSetting::SetVideoMode(640, 480, VGA::ModeSetting::BitsPerPixel::Bpp4, VGA::ModeSetting::Flags::Planar);
    Testing::TestPatterns::Draw4BppPattern(640, 480, FARPointer(uint16_t(0xa000), 0x0000).ToPointer<uint8_t>());
    getchar();

    SetVideoMode(0x03);
    //SetVideoMode(0x13);
    VGA::ModeSetting::SetVideoMode(320, 200, VGA::ModeSetting::BitsPerPixel::Bpp8);
    Testing::TestPatterns::Draw8BppPattern(320, 200, FARPointer(uint16_t(0xa000), 0x0000).ToPointer<uint8_t>());
    getchar();

    REGS r;
    memset(&r, 0, sizeof(r));

    r.w.ax = 0x03;
    int86(0x10, &r, &r);

    */

    VGA::ModeSetting::Shutdown();

    /*
    Hag::System::PCI::Device_t device = 0;
    uint8_t* fb = nullptr;
    bool success = false;
    ModeData* modeData = nullptr;

    if (Hag::System::PCI::FindDevice(0x121a, 0x0003, device))
    {
        if (FindVESAModeData(0x0115, modeData))
        {
            SetSuperVGAVideoMode(0x0115);

            __dpmi_meminfo mapping;
            mapping.address = Hag::TDfx::Shared::PCI::FrameBufferBaseAddress::Read(device) &
                              Hag::TDfx::Shared::PCI::FrameBufferBaseAddress::Address;

            mapping.size = 16 * 1024 * 1024;//TODO...
            if (__dpmi_physical_address_mapping(&mapping) == 0)
            {
                success = true;
                fb = (uint8_t*)(mapping.address + __djgpp_conventional_base);
            }
        }
    }

    if (success)
    {
        Hag::Testing::TestPatterns::Draw24BppPattern(modeData->Width, modeData->Height, modeData->Stride, fb);
        getchar();
    }

    SetVideoMode(0x03);
    */

    /*
    REGS r;
    memset(&r, 0, sizeof(r));

    for (uint16_t modesIdx = 0; modesIdx < sizeof(TestModes) / sizeof(Hag::VGA::VideoMode_t); ++modesIdx)
    {
        VGA::VideoMode_t mode = TestModes[modesIdx];

        r.w.ax = 3;
        int86(0x10, &r, &r);

        r.w.ax = mode;
        int86(0x10, &r, &r);

        char name[15];
        sprintf(name, "mode%04X.txt", mode);
        FILE* fp = fopen(name, "w");
        Support::PCIDump(fp, nullptr, 0x121a, "3Dfx", PCIDevices, sizeof(PCIDevices) / sizeof(Support::Device));
        Support::BDADump(fp, nullptr);
        Support::VGADump(fp, nullptr, BDA::VideoBaseIOPort::Get());
        BansheeDump(fp, nullptr, BDA::VideoBaseIOPort::Get());
        fclose(fp);
    }

    r.w.ax = 3;
    int86(0x10, &r, &r);
*/
#endif

#ifdef MOCK
    TDfxBansheeMockConfigSetup(allocator);
    VGA::ModeSetting::Initialize(allocator);

    for (uint16_t modesIdx = 0; modesIdx < sizeof(TestModes) / sizeof(TestMode); ++modesIdx)
    {
        Hag::Testing::Mock::Reset();
        
        TestMode& testMode = TestModes[modesIdx];
        if (testMode.LegacyMode == 0xFFFF)
            continue;

        VGA::ModeSetting::SetVideoError_t error = VGA::ModeSetting::HasVideoMode(testMode.Width,
            testMode.Height,
            testMode.Bpp,
            testMode.Flags,
            testMode.RefreshRate);

        if (error != VGA::ModeSetting::SetVideoError::Success)
        {
            printf("Mode 0x%02X skipped, ", testMode.LegacyMode);
            switch(error)
            {
            case VGA::ModeSetting::SetVideoError::SystemNotInitialized:
                printf("system not initialized.\n");
                break;
            case VGA::ModeSetting::SetVideoError::UnknownMode:
                printf("unknown mode.\n");
                break;
            case VGA::ModeSetting::SetVideoError::InsufficientVideoMemory:
                printf("insufficient video memory.\n");
                break;
            case VGA::ModeSetting::SetVideoError::NotSupportedByRamdac:
                printf("not supported by ramdac.\n");
                break;
            case VGA::ModeSetting::SetVideoError::NotSupportedByMonitor:
                printf("not supported by monitor.\n");
                break;
            }
            continue;
        }

        ModeData* modeData = nullptr;
        if (testMode.LegacyMode < 0x100)
        {
            FindModeData(testMode.LegacyMode, modeData);
        }
        else
        {
            FindVESAModeData(testMode.LegacyMode, modeData);
        }

        uint16_t* ignore = nullptr;
        uint16_t ignoreCount = 0;
        if (testMode.LegacyMode < 0x14)
        {
            printf("Setting video mode 0x%02X %ix%ix%i...\n", testMode.LegacyMode, modeData->Width, modeData->Height, modeData->BitsPerPixel);
            SetVideoMode(testMode.LegacyMode);
            ignore = ignorePortsLegacy;
            ignoreCount = sizeof(ignorePortsLegacy) / sizeof(uint16_t);
        }
        else
        {
            printf("Setting vesa mode 0x%02X %ix%ix%i...\n", testMode.LegacyMode, modeData->Width, modeData->Height, modeData->BitsPerPixel);
            SetSuperVGAVideoMode(modeData->VesaMode);
            ignore = ignorePorts;
            ignoreCount = sizeof(ignorePorts) / sizeof(uint16_t);
        }
        //FindModes(modeData->LegacyMode);
        PIT::Sleep(1);
        memset(FARPointer(uint16_t(0xa000), 0x0000).ToPointer<uint8_t>(0x10000), 0, 0x10000);
        memset(FARPointer(uint16_t(0xb000), 0x0000).ToPointer<uint8_t>(0x10000), 0, 0x10000);

        // bool patch = !Is8Dot();
        // uint8_t* font = nullptr;
        // uint8_t charHeight = 0;
        // GetFontAndCharHeight(font, charHeight);
        // const char* fontName = "8x8";
        // if (font == Font8x14)
        //     fontName = "8x14";
        // if (font == Font8x16)
        //     fontName = "8x16";
        // printf("Font: %s, char height: %i, patched: %s\n", fontName, charHeight, patch ? "yes" : "no");
        // printf("Maximum scanline: 0x%02X\n", VGA::CRTController::MaximumScanLine::Read(BDA::VideoBaseIOPort::Get()) & VGA::CRTController::MaximumScanLine::MaximumScanLineCount);
        // printf("Cursor start: 0x%02X\n", VGA::CRTController::CursorStartScanLine::Read(BDA::VideoBaseIOPort::Get()));
        // printf("Cursor end: 0x%02X\n", VGA::CRTController::CursorEndScanLine::Read(BDA::VideoBaseIOPort::Get()));
        // printf("\n");

        Hag::Testing::Mock::SelectInstance(1);
        VGA::ModeSetting::SetVideoMode(testMode.Width, testMode.Height, testMode.Bpp, testMode.Flags, testMode.RefreshRate);
        memset(FARPointer(uint16_t(0xa000), 0x0000).ToPointer<uint8_t>(0x10000), 0, 0x10000);
        memset(FARPointer(uint16_t(0xb000), 0x0000).ToPointer<uint8_t>(0x10000), 0, 0x10000);
        GetMemorySizeIn256KBlocks();
        TDfx::Shared::CRTController::Extension1::Write(BDA::VideoBaseIOPort::Get(), 0);
        VGA::DACWriteIndex::Write(0);
        BDA::EGAFeatureBitSwitches::Get();

        if (testMode.Bpp > 15)
        {
            Func0x1d6d(Data0x740f, 0x00, 0xf8);//0x2E8
        }

        Diff("SetMode", ignore, ignoreCount);
    }

    VGA::ModeSetting::Shutdown();

    Hag::Testing::Mock::Shutdown();
#endif    
	__djgpp_nearptr_disable();
    return 0;
}
