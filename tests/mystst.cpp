//Copyright 2025-Present riplin

#include <i86.h>
#include <stdio.h>
#include <string.h>

#include <support/allocatr.h>
#include <hag/testing/mock.h>

#include <hag/system/bda.h>
#include <hag/system/pci.h>
#include <hag/vesa/vidmodes.h>
#include <hag/drivers/vga/vga.h>

#include <hag/drivers/matrox/shared/crtc/cpudata.h>         //CR22
#include <hag/drivers/matrox/shared/crtc/atadrdat.h>        //CR24
#include <hag/drivers/matrox/shared/crtc/attraddr.h>        //CR26

#include <hag/drivers/matrox/shared/miscout.h>              //0x3C2, 0x3CC

#include <hag/drivers/matrox/shared/sqrc/memodctl.h>        //SR4

#include <hag/drivers/matrox/shared/crtcext/index.h>        //CRTCE Index 0x3DE
#include <hag/drivers/matrox/shared/crtcext/data.h>         //CRTCE Data  0x3DF
#include <hag/drivers/matrox/shared/crtcext/adgenext.h>     //CER0
#include <hag/drivers/matrox/shared/crtcext/hrcntext.h>     //CER1
#include <hag/drivers/matrox/shared/crtcext/vrcntext.h>     //CER2
#include <hag/drivers/matrox/shared/crtcext/misc.h>         //CER3
#include <hag/drivers/matrox/shared/crtcext/mempg.h>        //CER4
#include <hag/drivers/matrox/shared/crtcext/hrhlfcnt.h>     //CER5

#include <hag/drivers/matrox/shared/pci/devid.h>            //PCI00
#include <hag/drivers/matrox/shared/pci/devctl.h>           //PCI04
#include <hag/drivers/matrox/shared/pci/clsscod.h>          //PCI08
#include <hag/drivers/matrox/shared/pci/hdr.h>              //PCI0C
#include <hag/drivers/matrox/shared/pci/ctrlap.h>           //PCI10
#include <hag/drivers/matrox/shared/pci/fbap.h>             //PCI14
#include <hag/drivers/matrox/shared/pci/iloadap.h>          //PCI18
#include <hag/drivers/matrox/shared/pci/subsysid.h>         //PCI2C, PCI4C
#include <hag/drivers/matrox/shared/pci/rombase.h>          //PCI30
#include <hag/drivers/matrox/shared/pci/intctrl.h>          //PCI3C
#include <hag/drivers/matrox/shared/pci/opt.h>              //PCI40

#include <hag/drivers/matrox/shared/idx/curbadl.h>          //IDX04
#include <hag/drivers/matrox/shared/idx/curbadh.h>          //IDX05
#include <hag/drivers/matrox/shared/idx/curctrl.h>          //IDX06
#include <hag/drivers/matrox/shared/idx/curcols.h>          //IDX08, IDX09, IDX0A, IDX0C, IDX0D, IDX0E, IDX10, IDX11, IDX12
#include <hag/drivers/matrox/shared/idx/vrefctrl.h>         //IDX18
#include <hag/drivers/matrox/shared/idx/muxctrl.h>          //IDX19
#include <hag/drivers/matrox/shared/idx/pclkctrl.h>         //IDX1A
#include <hag/drivers/matrox/shared/idx/genctrl.h>          //IDX1D
#include <hag/drivers/matrox/shared/idx/miscctrl.h>         //IDX1E
#include <hag/drivers/matrox/shared/idx/gpioctrl.h>         //IDX2A
#include <hag/drivers/matrox/shared/idx/gpiodata.h>         //IDX2B
#include <hag/drivers/matrox/shared/idx/syspllm.h>          //IDX2C
#include <hag/drivers/matrox/shared/idx/sysplln.h>          //IDX2D
#include <hag/drivers/matrox/shared/idx/syspllp.h>          //IDX2E
#include <hag/drivers/matrox/shared/idx/syspllst.h>         //IDX2F
#include <hag/drivers/matrox/shared/idx/zoomctrl.h>         //IDX38
#include <hag/drivers/matrox/shared/idx/sensetst.h>         //IDX3A
#include <hag/drivers/matrox/shared/idx/crcreml.h>          //IDX3C
#include <hag/drivers/matrox/shared/idx/crcremh.h>          //IDX3D
#include <hag/drivers/matrox/shared/idx/crcbitsl.h>         //IDX3E
#include <hag/drivers/matrox/shared/idx/colkeyml.h>         //IDX40
#include <hag/drivers/matrox/shared/idx/colkeymh.h>         //IDX41
#include <hag/drivers/matrox/shared/idx/colkeyl.h>          //IDX42
#include <hag/drivers/matrox/shared/idx/colkeyh.h>          //IDX43
#include <hag/drivers/matrox/shared/idx/pixpllm.h>          //IDX44, IDX48, IDX4C
#include <hag/drivers/matrox/shared/idx/pixplln.h>          //IDX45, IDX49, IDX4D
#include <hag/drivers/matrox/shared/idx/pixpllp.h>          //IDX46, IDX4A, IDX4E
#include <hag/drivers/matrox/shared/idx/pixpllst.h>         //IDX4F


#include <hag/drivers/matrox/shared/pci/ind/indidx.h>       //PCI44
#include <hag/drivers/matrox/shared/pci/ind/inddat.h>       //PCI48

#include <hag/drivers/matrox/shared/pci/idx/curbadl.h>      //IDX04
#include <hag/drivers/matrox/shared/pci/idx/curbadh.h>      //IDX05
#include <hag/drivers/matrox/shared/pci/idx/curctrl.h>      //IDX06
#include <hag/drivers/matrox/shared/pci/idx/curcols.h>      //IDX08, IDX09, IDX0A, IDX0C, IDX0D, IDX0E, IDX10, IDX11, IDX12
#include <hag/drivers/matrox/shared/pci/idx/vrefctrl.h>     //IDX18
#include <hag/drivers/matrox/shared/pci/idx/muxctrl.h>      //IDX19
#include <hag/drivers/matrox/shared/pci/idx/pclkctrl.h>     //IDX1A
#include <hag/drivers/matrox/shared/pci/idx/genctrl.h>      //IDX1D
#include <hag/drivers/matrox/shared/pci/idx/miscctrl.h>     //IDX1E
#include <hag/drivers/matrox/shared/pci/idx/gpioctrl.h>     //IDX2A
#include <hag/drivers/matrox/shared/pci/idx/gpiodata.h>     //IDX2B
#include <hag/drivers/matrox/shared/pci/idx/syspllm.h>      //IDX2C
#include <hag/drivers/matrox/shared/pci/idx/sysplln.h>      //IDX2D
#include <hag/drivers/matrox/shared/pci/idx/syspllp.h>      //IDX2E
#include <hag/drivers/matrox/shared/pci/idx/syspllst.h>     //IDX2F
#include <hag/drivers/matrox/shared/pci/idx/zoomctrl.h>     //IDX38
#include <hag/drivers/matrox/shared/pci/idx/sensetst.h>     //IDX3A
#include <hag/drivers/matrox/shared/pci/idx/crcreml.h>      //IDX3C
#include <hag/drivers/matrox/shared/pci/idx/crcremh.h>      //IDX3D
#include <hag/drivers/matrox/shared/pci/idx/crcbitsl.h>     //IDX3E
#include <hag/drivers/matrox/shared/pci/idx/colkeyml.h>     //IDX40
#include <hag/drivers/matrox/shared/pci/idx/colkeymh.h>     //IDX41
#include <hag/drivers/matrox/shared/pci/idx/colkeyl.h>      //IDX42
#include <hag/drivers/matrox/shared/pci/idx/colkeyh.h>      //IDX43
#include <hag/drivers/matrox/shared/pci/idx/pixpllm.h>      //IDX44, IDX48, IDX4C
#include <hag/drivers/matrox/shared/pci/idx/pixplln.h>      //IDX45, IDX49, IDX4D
#include <hag/drivers/matrox/shared/pci/idx/pixpllp.h>      //IDX46, IDX4A, IDX4E
#include <hag/drivers/matrox/shared/pci/idx/pixpllst.h>     //IDX4F

extern uint8_t Font8x8[];
extern uint8_t* GraphicsFont8x8;
extern uint8_t Font8x16[];

class MockMystique : public Hag::Testing::Mock::PCI::Device
{
public:
    inline MockMystique(Hag::IAllocator& allocator)
        : Device("Mystique")
        , m_allocator(allocator)
        , m_Config(NULL)
        , m_Indexed(NULL)
        , m_ControlAperture(NULL)
        , m_ConfigSnapshot(NULL)
        , m_IndexedSnapshot(NULL)
        , m_ControlApertureSnapshot(NULL)
    {
        m_Config = allocator.AllocateAs<uint8_t>(sizeof(s_Config));
        m_Indexed = allocator.AllocateAs<uint8_t>(sizeof(s_Indexed));
        m_ControlAperture = allocator.AllocateAs<uint8_t>(16 * 1024);

        m_ConfigSnapshot = allocator.AllocateAs<uint8_t>(sizeof(s_Config));
        m_IndexedSnapshot = allocator.AllocateAs<uint8_t>(sizeof(s_Indexed));
        m_ControlApertureSnapshot = allocator.AllocateAs<uint8_t>(16 * 1024);
    }

    virtual ~MockMystique()
    {
        m_allocator.Free(m_ControlApertureSnapshot);
        m_ControlApertureSnapshot = NULL;

        m_allocator.Free(m_IndexedSnapshot);
        m_IndexedSnapshot = NULL;

        m_allocator.Free(m_ConfigSnapshot);
        m_ConfigSnapshot = NULL;

        m_allocator.Free(m_ControlAperture);
        m_ControlAperture = NULL;

        m_allocator.Free(m_Indexed);
        m_Indexed = NULL;

        m_allocator.Free(m_Config);
        m_Config = NULL;
    }

    virtual void Report(Device* instance1)
    {

    }

    virtual bool HasDifferences(Device* instance1)
    {
        return false;
    }

    virtual void Reset()
    {
        memcpy(m_Config, s_Config, sizeof(s_Config));
        memcpy(m_ConfigSnapshot, s_Config, sizeof(s_Config));

        memcpy(m_Indexed, s_Indexed, sizeof(s_Indexed));
        memcpy(m_IndexedSnapshot, s_Indexed, sizeof(s_Indexed));

        //TODO: properly reset to sane values
        memset(m_ControlAperture, 0, 16 * 1024);
        memset(m_ControlApertureSnapshot, 0, 16 * 1024);
    }

    virtual void Snapshot()
    {
        memcpy(m_ConfigSnapshot, m_Config, sizeof(s_Config));
        memcpy(m_IndexedSnapshot, m_Indexed, sizeof(s_Indexed));
        memcpy(m_ControlApertureSnapshot, m_ControlAperture, 16 * 1024);
    }

    virtual void Rollback()
    {
        memcpy(m_Config, m_ConfigSnapshot, sizeof(s_Config));
        memcpy(m_Indexed, m_IndexedSnapshot, sizeof(s_Indexed));
        memcpy(m_ControlAperture, m_ControlApertureSnapshot, 16 * 1024);
    }

    virtual uint32_t Read32(uint8_t offset)
    {
        uint32_t val = *(uint32_t*)(m_Config + offset);
        return val;
    }

    virtual void Write8(uint8_t offset, uint8_t value)
    {
        if (offset == 0x44)
        {
            value &= 0xFC;
        }

        if (offset == 0x45)
        {
            value &= 0x3F;
        }

        if (offset == 0x46)
        {
            value = 0x00;
        }

        if (offset == 0x47)
        {
            value = 0x00;
        }

        m_Config[offset] = value;
        
        if (offset >= 0x48 && offset <= 0x4B)
        {
            uint32_t index = *(uint32_t*)(m_Config + 0x44);
            if (index < 16 * 1024)
            {
                *(uint32_t*)(m_ControlAperture + index) = *(uint32_t*)(m_Config + 0x48);
                if (index == 0x3C08)
                {
                    m_Indexed[m_Config[0x3C00]] = m_Config[0x3C0A];
                }
            }
        }
    }

    virtual void Write16(uint8_t offset, uint16_t value)
    {
        if (offset == 0x44)
        {
            value &= 0x3FFC;
        }

        if (offset == 0x46)
        {
            value = 0x0000;
        }

        ((uint16_t*)m_Config)[offset >> 1] = value;

        if (offset >= 0x48 && offset <= 0x4B)
        {
            uint32_t index = *(uint32_t*)(m_Config + 0x44);
            if (index < 16 * 1024)
            {
                *(uint32_t*)(m_ControlAperture + index) = *(uint32_t*)(m_Config + 0x48);
                if (index == 0x3C08)
                {
                    m_Indexed[m_Config[0x3C00]] = m_Config[0x3C0A];
                }
            }
        }
    }

    virtual void Write32(uint8_t offset, uint32_t value)
    {
        if (offset == 0x44)
        {
            value &= 0x3FFC;
        }

        ((uint32_t*)m_Config)[offset >> 2] = value;
        
        if (offset >= 0x48 && offset <= 0x4B)
        {
            uint32_t index = *(uint32_t*)(m_Config + 0x44);
            if (index < 16 * 1024)
            {
                *(uint32_t*)(m_ControlAperture + index) = *(uint32_t*)(m_Config + 0x48);
                if (index == 0x3C08)
                {
                    m_Indexed[m_Config[0x3c00]] = m_Config[0x3C0A];
                }
            }
        }
    }

    virtual void Snoop8(uint16_t port, uint8_t value)
    {
        if (port == 0x3C8)
        {
            m_ControlAperture[0x3C00] = value;

            if (value < 80)
            {
                m_ControlAperture[0x3C0A] = m_Indexed[value];

                uint32_t index = *(uint32_t*)(m_Config + 0x44);
                if (index == 0x3C08)
                {
                    m_Config[0x48 + 0x02] = m_Indexed[value];
                }
            }
        }
    }

    virtual void Snoop16(uint16_t port, uint16_t value)
    {

    }

private:
    Hag::IAllocator& m_allocator;

    uint8_t* m_Config;
    uint8_t* m_Indexed;
    uint8_t* m_ControlAperture;

    uint8_t* m_ConfigSnapshot;
    uint8_t* m_IndexedSnapshot;
    uint8_t* m_ControlApertureSnapshot;

    static uint8_t s_Config[256];
    static uint8_t s_Indexed[80];
    //static uint8_t s_ControlAperture[16 * 1024];
};

uint8_t MockMystique::s_Config[256] = 
{
    0x2B, 0x10, 0x1A, 0x05, 0x87, 0x00, 0x80, 0x02, 0x02, 0x00, 0x00, 0x03, 0x00, 0x20, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xE0, 0x08, 0x00, 0x80, 0xE1, 0x00, 0x00, 0x80, 0xDF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x01, 0x00, 0x00,
    0x21, 0x4F, 0x0F, 0x5F, 0x08, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

uint8_t MockMystique::s_Indexed[80] =
{
    0x00, 0x00, 0x00, 0x00, 0xAF, 0x0D, 0x00, 0x00, 0x1B, 0x99, 0xFB, 0x00, 0xE7, 0x8D, 0x9F, 0x00,
    0x7D, 0x3F, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x20, 0x11, 0x11,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x08, 0x70, 0x10, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0D, 0x00,
    0x14, 0xB2, 0xD1, 0xAA, 0x1E, 0x6C, 0x01, 0x00, 0x0C, 0x66, 0x0B, 0x00, 0x0A, 0x75, 0x1E, 0x40
};


#if 0

#define RETURN(L)           \
    printf("%s\n", L);      \
    return;

#define RETURN_ARG(L, A)  \
    printf("%s\n", L);      \
    return A;

#else

#define RETURN(Label)           \
    return;

#define RETURN_ARG(Label, Arg)  \
    return Arg;

#endif

#if 0
#define LABEL(F, L)         \
L:                          \
printf("%s.%s\n", #F, #L);
#else
#define LABEL(F, L)         \
L:
#endif


Hag::VGA::Sequencer::ClockingMode_t ToggleScreenOnOff(Hag::VGA::Sequencer::ClockingMode_t screenToggle)
{
    using namespace Hag::VGA;
//    mov   dx, VGA_SequenceIndex         ;Port 0x3c4
//    mov   al, VGA_SEQIdx_ClockingMode   ;0x1
//    out   dx, al                        ;Write Index
//    inc   dx                            ;Move to sequence data port
//    in    al, dx                        ;read data port
    Sequencer::ClockingMode_t originalClockingMode = Sequencer::ClockingMode::Read();

//    mov   dh, al                        ;store original value
//    and   ax, 20dfh                     ;Filter ah to only VGA_SEQ1_ScreenOff, and filter out screen off in original value
    screenToggle &= Sequencer::ClockingMode::ScreenOff;

//    or    al, ah                        ;set screen off bit in original value
    Sequencer::ClockingMode_t newClockingMode = (originalClockingMode & ~Sequencer::ClockingMode::ScreenOff) | screenToggle;
//    mov   ah, dh                        ;ah = original register value
//    mov   dh, 03h                       ;Restore port high byte
//    out   dx, al                        ;write updated register value
    Sequencer::ClockingMode::Write(newClockingMode);
//    ret
    return originalClockingMode;
}

Hag::VGA::Sequencer::ClockingMode_t TurnScreenOn()
{
    return ToggleScreenOnOff(Hag::VGA::Sequencer::ClockingMode::ScreenOn);
}

Hag::VGA::Sequencer::ClockingMode_t TurnScreenOff()
{
    //mov   ah, 20h
    return ToggleScreenOnOff(Hag::VGA::Sequencer::ClockingMode::ScreenOff);
}

bool IsMDAHiResEnhanced()//Offset 0x3094
{
    using namespace Hag::System;
    //     push  ax
    //     mov   al, byte ptr ds:[BDA_EGAFeatureBitSwitches];Offset 0x488
    //     and   al, BDA_EFBS_AdapterTypeMask  ;0xf
    //     cmp   al, BDA_EFBS_MDAHiResEnhanced ;0x3
    //     je    Found                         ;Offset 0x30a0
    //     cmp   al, BDA_EFBS_MDAHiResEnhanced_2;0x9 Also check the other one
    // Found:                                  ;Offset 0x30a0
    //     pop   ax
    //     ret
    BDA::EGAFeatureBitSwitches_t adapterType = BDA::EGAFeatureBitSwitches::Get() & BDA::EGAFeatureBitSwitches::AdapterTypeMask;
    bool ret = (adapterType == BDA::EGAFeatureBitSwitches::MDAHiResEnhanced) ||
           (adapterType == BDA::EGAFeatureBitSwitches::MDAHiResEnhanced_2);
    
    return ret;
}

uint8_t GetNumberOfActiveScanlines()//Offset 0x3054
{
    using namespace Hag;
    using namespace Hag::System;

    REGPACK r;
    memset(&r, 0, sizeof(r));

    //;
    //;
    //;                                               000h means it's determined another way
    //;                                               All others are decremented by one and returned.
    //;Offset 0x3080                                    Display mode:
    static uint8_t NumberOfActiveScanlinesPerModePlusOne[] =
    {
        0x00,   // 0x00
        0x00,   // 0x01
        0x00,   // 0x02
        0x00,   // 0x03
        0x01,   // 0x04
        0x01,   // 0x05
        0x01,   // 0x06
        0x00,   // 0x07
        0x03,   // 0x08
        0x01,   // 0x09
        0x01,   // 0x0a
        0x01,   // 0x0b
        0x01,   // 0x0c
        0x01,   // 0x0d
        0x01,   // 0x0e
        0x02,   // 0x0f
        0x02,   // 0x10
        0x04,   // 0x11
        0x04,   // 0x12
        0x01    // 0x13
    };

    // ;
    // ;outputs:
    // ;   al = number of active scan lines
    // ;        0 = 200
    // ;        1 = 350
    // ;        2 = 400
    // ;        3 = 480
    // ;
    //     mov   al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    //     push  bx
    //     lea   bx, [NumberOfActiveScanlinesPerModePlusOne];Offset 0x3080
    //     cmp   al, BDA_DM_320x200_256_Color_Graphics;0x13
    //     ja    Label0x3066                   ;Offset 0x3066
    if (BDA::DisplayMode::Get() > VGA::VideoMode::G320x200x8bppC)
        goto Label0x3066;

    r.h.al = NumberOfActiveScanlinesPerModePlusOne[BDA::DisplayMode::Get()];
    //     xlatb cs:[bx]
    //     dec   al                            ;Subtract one to see if it turns negative (and thus, not set)
    r.h.al--;
    //     jns   Label0x307d                   ;Offset 0x307d
    if (r.h.al != 0xFF)
        goto Label0x307d;

    // Label0x3066:                            ;Offset 0x3066
LABEL(GetNumberOfActiveScanlines, Label0x3066);

    //     mov   al, 02h                       ;400 Scan lines
    r.h.al = 0x02;

    //     test  byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_LineMode400;Offset 0x489 0x10
    //     jne   Label0x307d                   ;Offset 0x307d
    if ((BDA::VideoDisplayDataArea::Get() & BDA::VideoDisplayDataArea::LineMode400) != 0)
        goto Label0x307d;

    //     dec   ax                            ;350 Scan lines
    r.w.ax--;

    //     call  IsMDAHiResEnhanced            ;Offset 0x3094
    //     je    Label0x307d                   ;Offset 0x307d
    if (IsMDAHiResEnhanced())
        goto Label0x307d;

    //     cmp   byte ptr ds:[BDA_DisplayMode], BDA_DM_80x25_Monochrome_Text;Offset 0x449 0x7
    //     je    Label0x307d                   ;Offset 0x307d
    if (BDA::DisplayMode::Get() == VGA::VideoMode::T80x25x1bppM)
        goto Label0x307d;
    //     dec   ax                            ;200 Scan lines
    r.w.ax--;

    // Label0x307d:                            ;Offset 0x307d
LABEL(GetNumberOfActiveScanlines, Label0x307d);
    //     pop   bx
    //     ret   
    return r.h.al;
}

extern Hag::System::BDA::VideoParameterTable VideoParameters[];

Hag::System::BDA::VideoParameterTable* GetVideoParameterTable()//Offset 0x2fe4
{
    using namespace Hag;
    using namespace Hag::System;

    REGPACK r;
    memset(&r, 0, sizeof(r));

//        +------------------------ 200 Scan lines
//        |
//        |     +------------------ 350 Scan lines
//        |     |
//        |     |     +------------ 400 Scan lines
//        |     |     |
//        |     |     |     +------ 480 Scan lines
//        |     |     |     |
//        |     |     |     |       Display mode:
    static uint8_t Data0x3004[] =                   //Offset 0x3004
    {
        0x00, 0x13, 0x17, 0x00,   // 0x00
        0x01, 0x14, 0x17, 0x00,   // 0x01
        0x02, 0x15, 0x18, 0x00,   // 0x02
        0x03, 0x16, 0x18, 0x00,   // 0x03
        0x04, 0x00, 0x00, 0x00,   // 0x04
        0x05, 0x00, 0x00, 0x00,   // 0x05
        0x06, 0x00, 0x00, 0x00,   // 0x06
        0x00, 0x07, 0x19, 0x00,   // 0x07
        0x00, 0x00, 0x08, 0x00,   // 0x08
        0x09, 0x00, 0x00, 0x00,   // 0x09
        0x0A, 0x00, 0x00, 0x00,   // 0x0a
        0x0B, 0x00, 0x00, 0x00,   // 0x0b
        0x0C, 0x00, 0x00, 0x00,   // 0x0c
        0x0D, 0x00, 0x00, 0x00,   // 0x0d
        0x0E, 0x00, 0x00, 0x00,   // 0x0e
        0x00, 0x11, 0x00, 0x00,   // 0x0f
        0x00, 0x12, 0x00, 0x00,   // 0x10
        0x00, 0x00, 0x00, 0x1A,   // 0x11
        0x00, 0x00, 0x00, 0x1B,   // 0x12
        0x1C, 0x00, 0x00, 0x00    // 0x13
    };

    // mov       al, BDA_VPCB_VideoParameterTable;0x0
    // call      LookupVideoParameterControlBlockPointer;Offset 0x317d
    //We have a direct pointer

    // mov       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    r.h.al = BDA::DisplayMode::Get();
    // cbw
    r.h.ah = 0;

    // shl       ax, 01h
    r.w.ax <<= 1;

    // shl       ax, 01h
    r.w.ax <<= 1;

    // mov       di, ax
    r.w.di = r.w.ax;

    // call      GetNumberOfActiveScanlines;Offset 0x3054
    r.h.al = GetNumberOfActiveScanlines();

    // add       di, ax
    r.w.di += r.w.ax;

    // mov       al, byte ptr cs:[di + Data0x3004];Offset 0x3004
    r.h.al = Data0x3004[r.w.di];


    // mov       ah, 40h
    // mul       ah
    // add       si, ax
    // ret
    return &VideoParameters[r.h.al];
}

void Func0x2ea3()//Offset 0x2ea3
{
    //Check alternate implementation
    // Label0x2ea3:                            ;Offset 0x2ea3
    // mov       ah, byte ptr es:[si]
    // inc       si
    // out       dx, ax
    // inc       ax
    // loop      Label0x2ea3               ;Offset 0x2ea3
    // ret
}

void LoadAttributeControllerRegs(uint8_t cl, uint8_t ah)//Offset 0x2ebb
{
    //Check alternate implementation
    using namespace Hag;
    using namespace Hag::System;

    REGPACK r;
    memset(&r, 0, sizeof(r));

    //     mov       dx, VGA_AttributeControllerIndex;Port 0x3c0
    // Label0x2ebe:                            ;Offset 0x2ebe
    //     cmp       al, ah
    //     jb        Label0x2ec7               ;Offset 0x2ec7
    //     ja        Label0x2ed0               ;Offset 0x2ed0
    //     inc       ax
    //     mov       cl, 01h
    // Label0x2ec7:                            ;Offset 0x2ec7
    //     out       dx, al
    //     push      ax
    //     lodsb     byte ptr es:[si]
    //     out       dx, al
    //     pop       ax
    //     inc       ax
    //     loop      Label0x2ebe               ;Offset 0x2ebe
    // Label0x2ed0:                            ;Offset 0x2ed0
    //     ret
}

void Func0x2eb9(uint8_t cl)//Offset 0x2eb9
{
    //Check alternate implementation
    //mov       ah, 0ffh
    LoadAttributeControllerRegs(cl, 0xFF);
}


void Func0x2e45(Hag::System::BDA::VideoParameterTable& videoParameterTable, Hag::VGA::Register_t baseVideoIOPort)//Offset 0x2e45
{
    using namespace Hag;
    using namespace Hag::System;

    REGPACK r;
    memset(&r, 0, sizeof(r));
    r.w.dx = baseVideoIOPort;

    //     mov       di, dx
    r.w.di = r.w.dx;

    //     cli
    SYS_ClearInterrupts();
    
    //     mov       dx, VGA_SequenceIndex     ;Port 0x3c4
    //     mov       ax, (VGA_SEQ0_AsyncReset SHL 8) OR VGA_SEQIdx_Reset;0x100
    //     out       dx, ax
    //     inc       ax
    VGA::Sequencer::Reset::Write(VGA::Sequencer::Reset::AsynchronousReset);
        
    //     mov       cx, 0004h
    r.w.cx = 0x0004;

    //     call      Func0x2ea3                ;Offset 0x2ea3
    //Func0x2ea3();
    VGA::SequencerData::Write(VGA::Sequencer::Register::ClockingMode,
                              videoParameterTable.SequencerRegisters,
                              sizeof(videoParameterTable.SequencerRegisters));

    //     mov       dl, VGA_MiscellaneousWrite_lowbyte;Port 0x3c2
    //     lodsb     byte ptr es:[si]
    //     out       dx, al
    VGA::MiscellaneousOutput::Write(videoParameterTable.MiscellaneousOutputRegister);
    
    //     push      cx
    //     mov       cx, 8000h
    // Label0x2e5f:                            ;Offset 0x2e5f
    //     loop      Label0x2e5f               ;Offset 0x2e5f  Speed sensitive!
    //     pop       cx
    for (int i = 0; i < 8000; ++i); //BOOOO

    //     mov       dl, VGA_SequenceIndex_lowbyte;Port 0x3c4
    //     mov       ax, ((VGA_SEQ0_AsyncReset OR VGA_SEQ0_SyncReset) SHL 8) OR VGA_SEQIdx_Reset;0x300
    //     out       dx, ax
    VGA::Sequencer::Reset::Write(VGA::Sequencer::Reset::AsynchronousReset |
                                 VGA::Sequencer::Reset::SynchronousReset);
    //     sti
    SYS_RestoreInterrupts();

    //     call      TurnScreenOff             ;Offset 0x3109
    //     push      ax
    Hag::VGA::Sequencer::ClockingMode_t previousScreenOffState = TurnScreenOff();

    //     mov       dx, di
    //     mov       ax, VGA_CRTCIdx_VertRetraceEnd;0x0011
    //     out       dx, ax
    VGA::CRTController::VerticalRetraceEnd::Write(baseVideoIOPort, 0x00);

    //     mov       cl, 19h
    r.h.cl = 0x19;

    //     xor       ax, ax
    r.w.ax = 0;

    //     call      Func0x2ea3                ;Offset 0x2ea3
    //Func0x2ea3();
    VGA::CRTControllerData::Write(baseVideoIOPort,
                                  VGA::CRTController::Register::HorizontalTotal,
                                  videoParameterTable.CRTCRegisters,
                                  sizeof(videoParameterTable.CRTCRegisters));

    //     push      si
    //     add       dl, 06h                   ;Port 0x3?a
    //     in        al, dx
    VGA::InputStatus1::Read(baseVideoIOPort + 0x06);

    //     xor       ax, ax
    //     out       dx, al
    VGA::FeatureControl::Write(baseVideoIOPort + 0x06, 0x00);

    //     mov       al, 10h            //Skipping palette colors?
    //     add       si, ax
    //     mov       cl, 01h
    //     call      Func0x2eb9                ;Offset 0x2eb9
    VGA::AttributeController::AttributeMode::Write(
        videoParameterTable.AttributeControllerRegisters[VGA::AttributeController::Register::AttributeMode]);

    //     inc       ax //Skip 0x11
    //     inc       si
    //     mov       cl, 02h
    //     call      Func0x2eb9                ;Offset 0x2eb9
    VGA::AttributeController::ColorPlane::Write(
        videoParameterTable.AttributeControllerRegisters[VGA::AttributeController::Register::ColorPlane]);
    VGA::AttributeController::HorizontalPixelPanning::Write(
        videoParameterTable.AttributeControllerRegisters[VGA::AttributeController::Register::HorizontalPixelPanning]);

    //     mov       dl, VGA_GraphicsControllerIndex_lowbyte;Port 0x3ce
    //     mov       cl, 09h
    //     xor       ax, ax
    //     call      Func0x2ea3                ;Offset 0x2ea3
    VGA::GraphicsControllerData::Write(VGA::GraphicsController::Register::SetResetData,
                                       videoParameterTable.GraphicsControllerRegisters,
                                       sizeof(videoParameterTable.GraphicsControllerRegisters));
    //     pop       si
    //     pop       ax

    //previousScreenOffState
    //     call      ToggleScreenOnOff         ;Offset 0x310b
    ToggleScreenOnOff(previousScreenOffState);
    
    //     pop       dx
    //     pop       cx
    //     ret
}

void Func0x2e39(Hag::System::BDA::VideoParameterTable& videoParameterTable)//Offset 0x2e39
{
    // push      cx
    // push      dx
    // call      Func0x2fe4                ;Offset 0x2fe4
    //Func0x2fe4();
    //Hag::System::BDA::VideoParameterTable& otherVideoParameterTable = *GetVideoParameterTable();
    // add       si, 0005h
    // mov       dx, word ptr ds:[BDA_VideoBaseIOPort];Offset 0x463
    Func0x2e45(videoParameterTable, Hag::System::BDA::VideoBaseIOPort::Get());
}

void SavePaletteToDynamicParams()//Offset 0x2eff
{
    //Copies the currently selected palette values into the dynamic param save area.
    //Should probably implement this to be 100% compatible.

    //     push      ds
    //     push      es
    //     push      si
    //     mov       al, BDA_VPCB_DynamicParamSaveArea;0x4
    //     call      LookupVideoParameterControlBlockPointer;Offset 0x317d
    //     pop       si
    //     pop       ds
    //     je        Label0x2f12               ;Offset 0x2f12
    //     mov       cx, 0008h
    //     rep movsw
    //     inc       si
    //     movsb
    // Label0x2f12:                            ;Offset 0x2f12
    //     pop       ds
    //     ret
}

#pragma pack(push, 1);
struct PaletteData
{
    Hag::System::BDA::VideoDisplayDataArea_t mask;
    uint8_t val;
    uint16_t count;
    uint8_t colors[];
};
#pragma pack(pop);

extern PaletteData* Palettes[];
uint8_t Greyscale(uint8_t red, uint8_t green, uint8_t blue)//Offset 0x2fcc
{
    //dh red, ch green, cl blue
    // mov       al, 4dh
    // mul       dh         ;red
    // mov       dx, ax
    // mov       al, 97h
    // mul       ch         ;green
    // add       dx, ax
    // mov       al, 1ch
    // mul       cl         ;blue
    // add       ax, dx
    // add       ax, 0080h
    // mov       al, ah
    // ret
    return ((0x4D * uint16_t(red)) +
            (0x97 * uint16_t(green)) +
            (0x1c * uint16_t(blue)) + 0x80) >> 8;
}

void LoadColorPalette(uint16_t count, uint16_t paletteIndex)//Offset 0x2f93
{
    using namespace Hag;
    using namespace Hag::System;
    uint8_t red = 0;
    uint8_t green = 0;
    uint8_t blue = 0;
    uint8_t greyscale = 0;
    uint16_t colorIndex = 0;
    uint16_t tripleCount = 0;

    //     test      byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_GrayScale OR BDA_VDDA_MonochromeMonitor;Offset 0x489 0x6
    //     jne       Label0x2fa6               ;Offset 0x2fa6
    if ((BDA::VideoDisplayDataArea::Get() & 
        (BDA::VideoDisplayDataArea::GrayScale | BDA::VideoDisplayDataArea::MonochromeMonitor)) != 0x00)
        goto Label0x2fa6;

    // Label0x2f9a:                            ;Offset 0x2f9a
    //     lodsb     byte ptr es:[si]
    //     out       dx, al
    //     lodsb     byte ptr es:[si]
    //     out       dx, al
    //     lodsb     byte ptr es:[si]
    //     out       dx, al
    //     loop      Label0x2f9a               ;Offset 0x2f9a
    tripleCount = count * 3;
    for (uint16_t idx = 0; idx < tripleCount; idx+=3)
    {
        VGA::RAMDACData::Write(Palettes[paletteIndex]->colors[idx + 0]);
        VGA::RAMDACData::Write(Palettes[paletteIndex]->colors[idx + 1]);
        VGA::RAMDACData::Write(Palettes[paletteIndex]->colors[idx + 2]);
    }
    //     ret
    return;


    // Label0x2fa6:                            ;Offset 0x2fa6
LABEL(LoadColorPalette, Label0x2fa6);
    for (uint16_t i = 0; i < count; ++i)
    {
        //     push      cx
        //     push      dx
        //     mov       dh, byte ptr es:[si]
        red = Palettes[paletteIndex]->colors[colorIndex];

        //     inc       si
        ++colorIndex;

        //     mov       ch, byte ptr es:[si]
        green = Palettes[paletteIndex]->colors[colorIndex];

        //     inc       si
        ++colorIndex;

        //     mov       cl, byte ptr es:[si]
        blue = Palettes[paletteIndex]->colors[colorIndex];

        //     inc       si
        ++colorIndex;

        //     call      Greyscale                ;Offset 0x2fcc
        greyscale = Greyscale(red, green, blue);

        //     pop       dx
        //     pop       cx
        //     out       dx, al
        VGA::RAMDACData::Write(greyscale);
        //     jmp       Label0x2fbc               ;Offset 0x2fbc Speed sensitive!
        // Label0x2fbc:                            ;Offset 0x2fbc
        //     out       dx, al
        VGA::RAMDACData::Write(greyscale);

        //     jmp       Label0x2fbf               ;Offset 0x2fbf Speed sensitive!
        // Label0x2fbf:                            ;Offset 0x2fbf
        //     out       dx, al
        VGA::RAMDACData::Write(greyscale);

        //     loop      Label0x2fa6               ;Offset 0x2fa6
    }
    //     ret
}

void LoadCompressedPalette(uint16_t count, uint16_t paletteIndex)//Offset 0x319b
{
    using namespace Hag;

    REGPACK r;
    memset(&r, 0, sizeof(r));

    for (uint16_t i = 0; i < count; ++i)
    {
        // Label0x319b:                            ;Offset 0x319b
        //     lodsb byte ptr es:[si]
        r.h.al = Palettes[paletteIndex]->colors[i];
        
        //     mov   ah, al
        r.h.ah = r.h.al;

        //     mov   bx, 0003h
        for (uint8_t c = 0; c < 3; ++c)
        {
            // Label0x31a2:                            ;Offset 0x31a2
            //     shl   ah, 01h
            r.h.ah <<= 1;

            //     shl   ah, 01h
            r.h.ah <<= 1;

            //     xor   al, al
            r.h.al = 0;

            //     test  ah, 0c0h
            //     je    Label0x31b7                   ;Offset 0x31b7
            if ((r.h.ah & 0xC0) == 0x00)
                goto Label0x31b7;

            //     jns   Label0x31b5                   ;Offset 0x31b5
            if ((r.h.ah & 0x80) == 0x00)//0x40
                goto Label0x31b5;

            //     jnp   Label0x31b3                   ;Offset 0x31b3
            if ((r.h.ah & 0xC0) == 0x80)
                goto Label0x31b3;

            //     add   al, 15h
            r.h.al += 0x15;

            // Label0x31b3:                            ;Offset 0x31b3
        LABEL(LoadCompressedPalette, Label0x31b3);
            
            //     add   al, 15h
            r.h.al += 0x15;

            // Label0x31b5:                            ;Offset 0x31b5
        LABEL(LoadCompressedPalette, Label0x31b5);

            //     add   al, 15h
            r.h.al += 0x15;

            // Label0x31b7:                            ;Offset 0x31b7
        LABEL(LoadCompressedPalette, Label0x31b7);

            //     out   dx, al
            VGA::RAMDACData::Write(r.h.al);

            //     dec   bx
            //     jne   Label0x31a2                   ;Offset 0x31a2
        }
        //     loop  Label0x319b                   ;Offset 0x319b
    }
    //     ret
}

void LoadPalette(Hag::VGA::DACWriteIndex_t startIndex, uint16_t paletteIndex)//Offset 0x2f5f
{
    using namespace Hag;
    using namespace Hag::System;

    //     mov       dx, VGA_DACWriteIndex     ;Port 0x3c8
    //     out       dx, al
    VGA::DACWriteIndex::Write(startIndex);

    //     inc       dx
    //     mov       ax, word ptr es:[si - 04h]
    BDA::VideoDisplayDataArea_t videoDisplayDataAreaMask = Palettes[paletteIndex]->mask;
    uint8_t val = Palettes[paletteIndex]->val;

    //     mov       cx, word ptr es:[si - 02h]
    uint16_t count = Palettes[paletteIndex]->count;

    //     test      byte ptr ds:[BDA_VideoDisplayDataArea], al;Offset 0x489
    //     je        Label0x2f7b               ;Offset 0x2f7b
    if ((BDA::VideoDisplayDataArea::Get() & videoDisplayDataAreaMask) == 0)
        goto Label0x2f7b;

    //     add       si, cx
    //     add       si, 0004h
    ++paletteIndex;

    //     mov       ax, word ptr es:[si - 04h]
    videoDisplayDataAreaMask = Palettes[paletteIndex]->mask;
    val = Palettes[paletteIndex]->val;

    // Label0x2f7b:                            ;Offset 0x2f7b
LABEL(LoadPalette, Label0x2f7b);

    //     or        ah, ah
    //     je        Label0x2f8d               ;Offset 0x2f8d
    if (val == 0x00)
        goto Label0x2f8d;

    //     jns       LoadColorPalette                ;Offset 0x2f93
    if ((val & 0x80) == 0x00)
    {
        LoadColorPalette(count, paletteIndex);
        return;
    }

    // Label0x2f81:                            ;Offset 0x2f81
    //     lodsb     byte ptr es:[si]
    //     out       dx, al
    //     jmp       Label0x2f86               ;Offset 0x2f86 Speed sensitive!
    // Label0x2f86:                            ;Offset 0x2f86
    //     out       dx, al
    //     jmp       Label0x2f89               ;Offset 0x2f89 Speed sensitive!
    // Label0x2f89:                            ;Offset 0x2f89
    //     out       dx, al
    //     loop      Label0x2f81               ;Offset 0x2f81

    //LoadMonochromePalette
    for (uint16_t idx = 0; idx < count; ++idx)
    {
        uint8_t color = Palettes[paletteIndex]->colors[idx];
        VGA::RAMDACData::Write(color);
        VGA::RAMDACData::Write(color);
        VGA::RAMDACData::Write(color);
    }

    //     ret
    return;

    // Label0x2f8d:                            ;Offset 0x2f8d
LABEL(LoadPalette, Label0x2f8d);
    //     push      bx
    //     call      LoadCompressedPalette                ;Offset 0x319b
    LoadCompressedPalette(count, paletteIndex);
    //     pop       bx
    //     ret
}

void LoadColorPaletteAtOffset0(uint16_t paletteIndex)//Offset 0x2f5d
{
    //    xor       al, al
    LoadPalette(0, paletteIndex);
}

void InitializePalette()//Offset 0x2f14
{
    using namespace Hag;
    using namespace Hag::System;

    REGPACK r;
    memset(&r, 0, sizeof(r));


    //     mov       dx, VGA_DACMask           ;Port 0x3c6
    //     mov       al, 0ffh
    //     out       dx, al
    VGA::DACMask::Write(0xFF);

    //     push      cs
    //     pop       es
    //     call      GetNumberOfActiveScanlines;Offset 0x3054
    r.h.al = GetNumberOfActiveScanlines();

    //     mov       ah, al
    r.h.ah = r.h.al;

    //     mov       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    r.h.al = BDA::DisplayMode::Get();

    //     cmp       ax, BDA_DM_320x200_256_Color_Graphics;0x0013
    //     je        Label0x2f43               ;Offset 0x2f43
    if (r.w.ax == VGA::VideoMode::G320x200x8bppC)
        goto Label0x2f43;
    
    //     lea       si, [Data0x337a]          ;Offset 0x337a
    r.w.si = 2;//Data0x337a

    //     jb        Label0x2f3f               ;Offset 0x2f3f
    if (r.w.ax < VGA::VideoMode::G320x200x8bppC)
        goto Label0x2f3f;

    //     lea       si, [Data0x3402]          ;Offset 0x3402
    r.w.si = 4;//Data0x3402

    //     cmp       al, BDA_DM_80x25_Monochrome_Text;0x7
    //     je        Label0x2f3f               ;Offset 0x2f3f
    if (r.h.al == VGA::VideoMode::T80x25x1bppM)
        goto Label0x2f3f;

    //     cmp       al, BDA_DM_640x350_Monochrome_Graphics;0xf
    //     je        Label0x2f3f               ;Offset 0x2f3f
    if (r.h.al == VGA::VideoMode::G640x350x1bppM)
        goto Label0x2f3f;

    //     lea       si, [Data0x32f2]          ;Offset 0x32f2
    r.w.si = 0;//Data0x32f2

    // Label0x2f3f:                            ;Offset 0x2f3f
LABEL(InitializePalette, Label0x2f3f);

    //     call      LoadColorPaletteAtOffset0                ;Offset 0x2f5d
    LoadColorPaletteAtOffset0(r.w.si);

    //     ret
    return;

    // Label0x2f43:                            ;Offset 0x2f43
LABEL(InitializePalette, Label0x2f43);

    //     lea       si, [Data0x3446]          ;Offset 0x3446
    r.w.si = 5;//Data0x3446

    //     call      LoadColorPaletteAtOffset0                ;Offset 0x2f5d
    LoadColorPaletteAtOffset0(r.w.si);

    //     lea       si, [Data0x346e]          ;Offset 0x346e
    r.w.si = 7;//Data0x346e

    //     mov       al, 10h
    r.h.al = 0x10;

    //     call      LoadPalette                ;Offset 0x2f5f
    LoadPalette(r.h.al, r.w.si);

    //     lea       si, [Data0x3482]          ;Offset 0x3482
    r.w.si = 8;//Data0x3482

    //     mov       al, 20h
    r.h.al = 0x20;

    //     call      LoadPalette                ;Offset 0x2f5f
    LoadPalette(r.h.al, r.w.si);

    //     ret
}

void InitializeAndSavePalettes(Hag::System::BDA::VideoParameterTable& videoParameterTable)//Offset 0x152a
{
    using namespace Hag;
    using namespace Hag::System;

    //     test  byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_PaletteLoadingEnabled;Offset 0x489 0x8
    //     jne   PaletteLoadingDisabled        ;Offset 0x1548
    if ((BDA::VideoDisplayDataArea::Get() & BDA::VideoDisplayDataArea::PaletteLoadingDisabled) != 0)
        goto PaletteLoadingDisabled;

    //     push  si
    //     xor   ax, ax
    //     mov   cx, 0010h
    //     call  Func0x2eb9                    ;Offset 0x2eb9
    VGA::AttributeControllerData::Write(VGA::AttributeController::Register::Palette0, videoParameterTable.AttributeControllerRegisters, 0x10);

    //     inc   ax                            ;Skip 0x10
    //     inc   si
    //     mov   cl, 01h
    //     call  Func0x2eb9                    ;Offset 0x2eb9
    VGA::AttributeController::BorderColor::Write(
        videoParameterTable.AttributeControllerRegisters[VGA::AttributeController::Register::BorderColor]);

    //     pop   si
    //     call  SavePaletteToDynamicParams                    ;Offset 0x2eff
    SavePaletteToDynamicParams();

    //     call  InitializePalette                    ;Offset 0x2f14
    InitializePalette();

    // PaletteLoadingDisabled:                 ;Offset 0x1548
LABEL(InitializeAndSavePalettes, PaletteLoadingDisabled);
    //     ret
}

Hag::VGA::VideoMode_t VesaToLegacyModeEquivalent(Hag::VGA::VideoMode_t videoMode)//Offset 0x64cd
{
    using namespace Hag;

    //     cmp  al, 20h                        ;Under VESA 0x100 640x400x256
    //     jb   Label0x64e5                    ;Offset 0x64e5
    if (videoMode < 0x20)
        return videoMode;

    //     cmp  al, 22h                        ;VESA 0x102 VESA_MODE_800x600x16
    //     je   Label0x64df                    ;Offset 0x64df
    if (videoMode == 0x22)
        return VGA::VideoMode::G640x480x4bppC;

    //     cmp  al, 28h                        ;Under VESA 0x108 VESA_MODE_80x60xText
    //     jb   Label0x64e3                    ;Offset 0x64e3
    if (videoMode < 0x28)
        return VGA::VideoMode::G320x200x8bppC;

    //     cmp  al, 2dh                        ;Under VESA 0x10d (320x200x32K)
    //     mov  al, 03h                        ;VGA 80x25 16 color text
    //     jb   Label0x64e5                    ;Offset 0x64e5
    if (videoMode < 0x2d)
        return VGA::VideoMode::T80x25x4bppC;

    // Label0x64df:                            ;Offset 0x64df
    //     mov  al, 12h                        ;640x480   16 color
    //     jmp  Label0x64e5                    ;Offset 0x64e5
    return VGA::VideoMode::G640x480x4bppC;

    // Label0x64e3:                            ;Offset 0x64e3
    //     mov  al, 13h                        ;320x200 256 color
    // Label0x64e5:                            ;Offset 0x64e5
    //     ret
}

void ClearScreen()//Offset 0x2ca5
{
    using namespace Hag;
    using namespace Hag::System;

    //     test      byte ptr ds:[BDA_VideoModeOptions], BDA_VMO_DontClearDisplay;Offset 0x487 0x80
    //     jne       Label0x2ce2               ;Offset 0x2ce2
    if (BDA::VideoModeOptions::Get() & BDA::VideoModeOptions::DontClearDisplay)
        return;

    //     cmp       word ptr ds:[BDA_VideoBufferSize], 00h;Offset 0x44c
    //     je        Label0x2ce2               ;Offset 0x2ce2
    if (BDA::VideoBufferSize::Get() == 0x0000)
        return;

    //     push      bx
    //     push      cx
    //     push      dx
    //     mov       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    //     call      VesaToLegacyModeEquivalent                ;Offset 0x64cd
    VGA::VideoMode_t videoMode = VesaToLegacyModeEquivalent(BDA::DisplayMode::Get());

    //     mov       bx, 0a000h                ;Segment 0xa000
    uint16_t segment = 0xA000;

    //     mov       cx, 8000h
    uint16_t count = 0x8000;

    // Label0x2cd5:                            ;Offset 0x2cd5
    //     xor       dx, dx
    uint16_t value = 0x0000;

    //     cmp       al, BDA_DM_80x25_Monochrome_Text;0x7
    //     ja        Label0x2cd5               ;Offset 0x2cd5
    if (videoMode <= VGA::VideoMode::T80x25x1bppM)
    {
        //     mov       bh, 0b0h                  ;Segment 0xb000
        segment = 0xB000;

        //     mov       ch, 40h
        count = 0x4000;

        //     mov       dx, 0720h                 ;Attribute + space
        value = 0x0720;
        //     je        Label0x2cd7               ;Offset 0x2cd7
        if (videoMode != VGA::VideoMode::T80x25x1bppM)
        {
            //     mov       bh, 0b8h                  ;Segment 0xb800
            segment = 0xB800;

            //     cmp       al, BDA_DM_80x25_16_Color_Text;0x3
            //     jbe       Label0x2cd7               ;Offset 0x2cd7
            if (videoMode > VGA::VideoMode::T80x25x4bppC)
            {
                value = 0x0000;
            }
            // Label0x2cd7:                            ;Offset 0x2cd7
        }
    }
    //     mov       es, bx
    //     mov       ax, dx
    //     xor       di, di
    //     rep stosw
    uint16_t* ptr = FARPointer(segment, 0x0000).ToPointer<uint16_t>(count);
    for (uint16_t i = 0; i < count; ++i)
    {
        *ptr = value;
        ++ptr;
    }
    
    //     pop       dx
    //     pop       cx
    //     pop       bx
    // Label0x2ce2:                            ;Offset 0x2ce2
    //     ret
}

bool Func0x30a2()
{
    using namespace Hag;
    using namespace Hag::System;

    //     push  ax
    //     mov   al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    //     call  VesaToLegacyModeEquivalent                    ;Offset 0x64cd
    VGA::VideoMode_t mode = VesaToLegacyModeEquivalent(BDA::DisplayMode::Get());

    //     cmp   al, BDA_DM_80x25_Monochrome_Text;0x7
    //     je    Label0x30b3                   ;Offset 0x30b3
    if (mode == VGA::VideoMode::T80x25x1bppM)
        return true;

    //     cmp   al, BDA_DM_80x25_16_Color_Text;0x3
    //     ja    Label0x30b3                   ;Offset 0x30b3
    if (mode > VGA::VideoMode::T80x25x4bppC)
        return false;

    //     xor   al, al
    // Label0x30b3:                            ;Offset 0x30b3
    //     pop   ax
    //     ret
    return true;
}

//Data0x2d0e              DW (VGA_SEQ2_Mask2 SHL 8) OR VGA_SEQIdx_MapMask;0x0402
//                        DW ((VGA_SEQ4_Unknown1 OR VGA_SEQ4_MemSize256k OR VGA_SEQ4_CPUAnyMap) SHL 8) OR VGA_SEQIdx_MemoryMode;0x0704
//                        DW (VGA_GCTL4_Map2 SHL 8) OR VGA_GCTLIdx_ReadMapSelect;0x0204
//                        DW (VGA_GCTL5_BLU SHL 8) OR VGA_GCTLIdx_GraphicMode;0x0005
//                        DW (VGA_GCTL6_Mem_A0000_AFFFF SHL 8) OR VGA_GCTLIdx_Miscellaneous;0x0406
void ConfigureFontLoadMemoryMapping()//Offset 0x2ce3
{
    using namespace Hag;
    using namespace Hag::Matrox;

    VGA::Sequencer::EnableWritePlane::Write(VGA::Sequencer::EnableWritePlane::Plane3);
    Shared::Sequencer::MemoryModeControl::Write(
        Hag::Matrox::Shared::Sequencer::MemoryModeControl::Unknown1 |
        Hag::Matrox::Shared::Sequencer::MemoryModeControl::ExtendedMemoryAddress |
        Hag::Matrox::Shared::Sequencer::MemoryModeControl::SequentialAddressingMode);
    
    VGA::GraphicsController::ReadPlaneSelect::Write(VGA::GraphicsController::ReadPlaneSelect::Plane3);
    VGA::GraphicsController::GraphicsControllerMode::Write(VGA::GraphicsController::GraphicsControllerMode::Mode0);
    VGA::GraphicsController::MemoryMapModeControl::Write(VGA::GraphicsController::MemoryMapModeControl::A0000HtoAFFFFH);
}

//Data0x2d18              DW ((VGA_SEQ2_Mask0 OR VGA_SEQ2_Mask1) SHL 8)OR VGA_SEQIdx_MapMask;0x0302
//                        DW ((VGA_SEQ4_Unknown1 OR VGA_SEQ4_MemSize256k) SHL 8) OR VGA_SEQIdx_MemoryMode;0x0304
//                        DW (VGA_GCTL4_Map0 SHL 8) OR VGA_GCTLIdx_ReadMapSelect;0x0004
//                        DW (VGA_GCTL5_OddEven SHL 8) OR VGA_GCTLIdx_GraphicMode;0x1005
//                        DW ((VGA_GCTL6_AlphaMode OR VGA_GCTL6_ChainEven OR VGA_GCTL6_Mem_B8000_BFFFF) SHL 8) OR VGA_GCTLIdx_Miscellaneous;0x0e06
//                        DW ((VGA_GCTL6_AlphaMode OR VGA_GCTL6_ChainEven OR VGA_GCTL6_Mem_B0000_B7FFF) SHL 8) OR VGA_GCTLIdx_Miscellaneous;0x0a06
void ConfigureTextMemoryMapping()//Offset 0x2ce9
{
    using namespace Hag;
    using namespace Hag::System;
    using namespace Hag::Matrox;

    VGA::Sequencer::EnableWritePlane::Write(VGA::Sequencer::EnableWritePlane::Plane1 | VGA::Sequencer::EnableWritePlane::Plane2);
    Shared::Sequencer::MemoryModeControl::Write(
        Hag::Matrox::Shared::Sequencer::MemoryModeControl::Unknown1 |
        Hag::Matrox::Shared::Sequencer::MemoryModeControl::ExtendedMemoryAddress);

    VGA::GraphicsController::ReadPlaneSelect::Write(VGA::GraphicsController::ReadPlaneSelect::Plane1);
    VGA::GraphicsController::GraphicsControllerMode::Write(VGA::GraphicsController::GraphicsControllerMode::OddEvenAddressing);
    if (BDA::VideoBaseIOPort::Get() == VGA::Register::CRTControllerIndexD)
        VGA::GraphicsController::MemoryMapModeControl::Write(
            VGA::GraphicsController::MemoryMapModeControl::ChainOddEvenPlanes |
            VGA::GraphicsController::MemoryMapModeControl::B8000HtoBFFFFH);
    else
    VGA::GraphicsController::MemoryMapModeControl::Write(
        VGA::GraphicsController::MemoryMapModeControl::ChainOddEvenPlanes |
        VGA::GraphicsController::MemoryMapModeControl::B0000HtoB7FFFH);
}

void Func0x2d47(uint8_t* font, uint16_t count, uint16_t val, uint16_t val2)//Offset 0x2d47
{
    static uint8_t Data0x2dbe[] = { 0x00, 0x40, 0x80, 0xC0, 0x20, 0x60, 0xA0, 0xE0 };

    REGPACK r;
    memset(&r, 0, sizeof(r));
    r.w.cx = count;
    r.w.dx = val;   //?
    r.w.bx = val2;  //bh = font height? bl = ?
    uint16_t saveCX = 0;
    uint16_t saveBX = 0;
    uint8_t* siPointer = font;
    FARPointer ptr;

    //     mov       si, bp
    //     push      es
    //     pop       ds
    //     mov       ax, 0a000h                ;Segment 0xa000
    r.w.ax = 0xA000;

    //     mov       es, ax
    ptr.Segment = r.w.ax;

    //     jcxz      Label0x2da6               ;Offset 0x2da6
    if (r.w.cx = 0x0000)
        goto Label0x2da6;

    // Label0x2d52:                            ;Offset 0x2d52
LABEL(Func0x2d47, Label0x2d52);

    //     push      cx
    saveCX = r.w.cx;
    //     mov       cl, 05h
    r.h.cl = 0x05;

    //     shl       dx, cl
    r.w.dx <<= r.h.cl;

    //     push      bx
    saveBX = r.w.bx;

    //     and       bx, 0007h
    r.w.bx &= 0x0007;

    //     add       dh, byte ptr cs:[bx + Data0x2dbe];Offset 0x2dbe
    r.h.dh += Data0x2dbe[r.w.bx];
    //     pop       bx
    r.w.bx = saveBX;

    //     mov       di, dx
    r.w.di = r.w.dx;
    ptr.Offset = r.w.dx;
    
    //     mov       dl, bh
    r.h.dl = r.h.bh;

    //     xor       dh, dh
    r.h.dh = 0x00;

    //     or        dl, dl
    //     jne       Label0x2d6d               ;Offset 0x2d6d
    if (r.h.dl != 0x00)
        goto Label0x2d6d;

    //     mov       dl, 10h
    r.h.dl = 0x10;

    // Label0x2d6d:                            ;Offset 0x2d6d
LABEL(Func0x2d47, Label0x2d6d);

    //     pop       ax
    r.w.ax = saveCX;

    // Label0x2d6e:                            ;Offset 0x2d6e
LABEL(Func0x2d47, Label0x2d6e);

    //     or        bh, bh
    //     jne       Label0x2d9a               ;Offset 0x2d9a
    if (r.h.bh != 0x00)
        goto Label0x2d9a;

    //     cmp       al, 99h
    //     je        Label0x2d8c               ;Offset 0x2d8c
    if (r.h.al == 0x99)
        goto Label0x2d8c;

    //     cmp       al, 96h
    //     je        Label0x2d8c               ;Offset 0x2d8c
    if (r.h.al == 0x96)
        goto Label0x2d8c;

    //     cmp       al, 87h
    //     je        Label0x2d8c               ;Offset 0x2d8c
    if (r.h.al == 0x87)
        goto Label0x2d8c;

    //     cmp       al, 90h
    //     je        Label0x2d8c               ;Offset 0x2d8c
    if (r.h.al == 0x90)
        goto Label0x2d8c;

    //     cmp       al, 8fh
    //     je        Label0x2d8c               ;Offset 0x2d8c
    if (r.h.al == 0x8F)
        goto Label0x2d8c;

    //     cmp       al, 68h
    //     je        Label0x2d8c               ;Offset 0x2d8c
    if (r.h.al == 0x68)
        goto Label0x2d8c;

    //     jmp       Label0x2d9a               ;Offset 0x2d9a
    goto Label0x2d9a;

    // Label0x2d8c:                            ;Offset 0x2d8c
LABEL(Func0x2d47, Label0x2d8c);

    //     mov       cx, 0008h
    r.w.cx = 0x0008;

    //     rep movsb
    memcpy(ptr.ToPointer<uint8_t>(8), siPointer, 8);
    r.w.di += 8;
    ptr.Offset += 8;
    siPointer += 8;

    //     inc       si
    ++siPointer;

    //     mov       cx, 0007h
    r.w.cx = 0x0007;

    //     rep movsb
    memcpy(ptr.ToPointer<uint8_t>(7), siPointer, 7);
    r.w.di += 7;
    ptr.Offset += 7;
    siPointer += 7;

    //     inc       di
    ++r.w.di;
    ++ptr.Offset;

    //     jmp       Label0x2d9e               ;Offset 0x2d9e
    goto Label0x2d9e;

    // Label0x2d9a:                            ;Offset 0x2d9a
LABEL(Func0x2d47, Label0x2d9a);

    //     mov       cx, dx
    r.w.cx = r.w.dx;

    //     rep movsb
    memcpy(ptr.ToPointer<uint8_t>(r.w.dx), siPointer, r.w.dx);
    ptr.Offset += r.w.dx;
    siPointer += r.w.dx;
    
    // Label0x2d9e:                            ;Offset 0x2d9e
LABEL(Func0x2d47, Label0x2d9e);

    //     sub       di, dx
    r.w.di -= r.w.dx;
    ptr.Offset -= r.w.dx;

    //     add       di, 0020h
    r.w.di += 0x0020;
    ptr.Offset += 0x0020;

    //     dec       ax
    --r.w.ax;

    //     jne       Label0x2d6e               ;Offset 0x2d6e
    if (r.w.ax != 0x0000)
        goto Label0x2d6e;

    // Label0x2da6:                            ;Offset 0x2da6
LABEL(Func0x2d47, Label0x2da6);

    //     or        bl, bl
    //     jns       Label0x2db3               ;Offset 0x2db3
    if ((r.h.bl & 0x80) == 0x00)
        goto Label0x2db3;

    //     mov       dl, byte ptr [si]
    r.h.dl = *siPointer;

    //     inc       si
    ++siPointer;

    //     inc       cx
    ++r.w.cx;

    //     or        dl, dl
    //     jne       Label0x2d52               ;Offset 0x2d52
    if (r.h.dl != 0x00)
        goto Label0x2d52;

    //     dec       cx
    --r.w.cx;

    // Label0x2db3:                            ;Offset 0x2db3
LABEL(Func0x2d47, Label0x2db3);

    //     or        bh, bh
    //     jne       Label0x2db9               ;Offset 0x2db9
    if (r.h.bh != 0x00)
        goto Label0x2db9;
        
    //     mov       bh, 0eh
    r.h.bh = 0x0E;

    // Label0x2db9:                            ;Offset 0x2db9
LABEL(Func0x2d47, Label0x2db9);

    //     push      ds
    //     pop       es
    //     mov       ds, cx                    ;I'm guessing cx is zero here...
    //     ret
}

void ApplySecondaryCharacterSetOverride()//Offset 0x1645
{
    //TODO
    //     mov   al, BDA_VPCB_SecondaryCharSetOverride;0x6
    //     call  LookupVideoParameterControlBlockPointer;Offset 0x317d
    //     je    Label0x1683                   ;Offset 0x1683
    //     mov   al, 07h
    //     call  AppliesToCurrentMode                    ;Offset 0x30b5
    //     jne   Label0x1683                   ;Offset 0x1683
    //     lodsw word ptr es:[si]
    //     cmp   al, byte ptr ds:[BDA_PointHeightOfCharacterMatrix];Offset 0x485
    //     jne   Label0x1683                   ;Offset 0x1683
    //     push  ax
    //     xchg  al, ah
    //     and   al, 7fh
    //     xchg  ax, bx
    //     inc   si
    //     les   bp, es:[si]
    //     xor   dx, dx
    //     mov   cx, 0100h
    //     call  Func0x2d47                    ;Offset 0x2d47
    //     pop   ax
    //     shl   ah, 01h
    //     shl   ah, 01h
    //     add   ah, 10h
    //     mov   dx, VGA_SequenceIndex         ;Port 0x3c4
    //     mov   al, VGA_SEQIdx_CharacterMapSelect;0x3
    //     out   dx, al
    //     inc   dx
    //     in    al, dx
    //     and   ax, 2c13h
    //     or    al, ah
    //     out   dx, al
    // Label0x1683:                            ;Offset 0x1683
    //     ret
}

void AppliesToCurrentMode()//Offset 0x30b5
{
    //     push  si
    //     cbw
    //     xchg  ax, si
    //     add   si, di
    // Label0x30ba:                            ;Offset 0x30ba
    //     lodsb byte ptr es:[si]
    //     cmp   al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    //     je    Label0x30c7                   ;Offset 0x30c7
    //     inc   al
    //     jne   Label0x30ba                   ;Offset 0x30ba
    //     inc   ax
    // Label0x30c7:                            ;Offset 0x30c7
    //     pop   si
    //     ret
}

void ApplyAlphanumericCharacterSetOverride()//Offset 0x1612
{
    //TODO
    //     mov   al, BDA_VPCB_AlphaNumCharSetOverride;0x8
    //     call  LookupVideoParameterControlBlockPointer;Offset 0x317d
    //     je    Label0x1644                   ;Offset 0x1644
    //     mov   al, 0bh
    //     call  AppliesToCurrentMode                    ;Offset 0x30b5
    //     jne   Label0x1644                   ;Offset 0x1644
    //     lodsw word ptr es:[si]
    //     xchg  al, ah
    //     xchg  ax, bx
    //     lodsw word ptr es:[si]
    //     xchg  ax, cx
    //     lodsw word ptr es:[si]
    //     xchg  ax, dx
    //     lodsw word ptr es:[si]
    //     xchg  ax, bp
    //     lodsw word ptr es:[si]
    //     push  word ptr es:[si]
    //     mov   es, ax
    //     call  Func0x2d47                    ;Offset 0x2d47
    //     call  Func0x2dc6                    ;Offset 0x2dc6
    //     pop   ax
    //     cmp   al, 0ffh
    //     je    Label0x1644                   ;Offset 0x1644
    //     dec   ax
    //     mov   byte ptr ds:[BDA_RowsOnScreen], al;Offset 0x484
    // Label0x1644:                            ;Offset 0x1644
    //     ret
}

void Func0x2d24(uint16_t val1, uint16_t val2, uint8_t* ptr, uint16_t count)//Offset 0x2d24
{
    REGPACK r;
    memset(&r, 0, sizeof(r));
    r.w.ax = val1;
    r.w.bx = val2;
    r.w.cx = count;
    uint8_t* bpPointer = ptr;
    // cbw
    r.h.ah = 0;

    // dec       ax
    --r.w.ax;

    // js        Func0x2d47                ;Offset 0x2d47
    if ((r.w.ax & 0x8000) != 0)
    {
        Func0x2d47(bpPointer, r.w.cx, r.w.dx, r.w.bx);
        return;
    }
    // mov       cx, 0100h
    r.w.cx = 0x0100;

    // xor       dx, dx
    r.w.dx = 0x0000;

    // push      cs
    // pop       es
    // lea       bp, [Font8x16]            ;Offset 0x3f20
    bpPointer = Font8x16;

    // mov       bh, 00h
    r.h.bh = 0x00;

    // dec       ax
    --r.w.ax;

    // js        Func0x2d47                ;Offset 0x2d47
    if (r.w.ax < 0x0000)
    {
        Func0x2d47(bpPointer, r.w.cx, r.w.dx, r.w.bx);
        return;
    }

    // lea       bp, [Font8x8]             ;Offset 0x3720
    bpPointer = Font8x8;

    // mov       bh, 08h
    r.h.bh = 0x08;

    // dec       ax
    --r.w.ax;

    // js        Func0x2d47                ;Offset 0x2d47
    if (r.w.ax < 0x0000)
    {
        Func0x2d47(bpPointer, r.w.cx, r.w.dx, r.w.bx);
        return;
    }

    // lea       bp, [Font8x16]            ;Offset 0x3f20
    bpPointer = Font8x16;

    // mov       bh, 10h
    r.h.bh = 0x10;

    // call      Func0x2d47
    Func0x2d47(bpPointer, r.w.cx, r.w.dx, r.w.bx);
}

void SelectAndLoadFont()//Offset 0x1549
{
    using namespace Hag;
    using namespace Hag::System;

    //     call  ConfigureFontLoadMemoryMapping                    ;Offset 0x2ce3
    ConfigureFontLoadMemoryMapping();

    //     call  GetNumberOfActiveScanlines    ;Offset 0x3054
    uint8_t scanLines = GetNumberOfActiveScanlines();

    //     mov   ax, 0002h
    uint16_t val = 0x02;
    uint16_t val2 = 0x00;
    
    //     dec   al
    //     js    Label0x1565                   ;Offset 0x1565
    if (scanLines == 0)
        goto Label0x1565;
    
    //     mov   al, 03h
    val = 0x03;

    //     jne   Label0x1563                   ;Offset 0x1563
    if (scanLines > 1)
        goto Label0x1563;

    //     mov   al, 01h
    val = 0x01;

    //     cmp   byte ptr ds:[BDA_DisplayMode], BDA_DM_80x25_Monochrome_Text;Offset 0x449 0x7
    //     jne   Label0x1565                   ;Offset 0x1565
    if (BDA::DisplayMode::Get() != VGA::VideoMode::T80x25x1bppM)
        goto Label0x1565;

    // Label0x1563:                            ;Offset 0x1563
LABEL(SelectAndLoadFont, Label0x1563);

//     mov   ah, 80h
    val2 = 0x80;

    // Label0x1565:                            ;Offset 0x1565
LABEL(SelectAndLoadFont, Label0x1565);

    //     mov   bl, ah
    //     call  Func0x2d24                    ;Offset 0x2d24
    Func0x2d24(val, val2, NULL, 0x0000);

    //     call  ApplyAlphanumericCharacterSetOverride                    ;Offset 0x1612
    ApplyAlphanumericCharacterSetOverride();

    //     call  ApplySecondaryCharacterSetOverride                    ;Offset 0x1645
    ApplySecondaryCharacterSetOverride();

    //     call  ConfigureTextMemoryMapping                    ;Offset 0x2ce9
    ConfigureTextMemoryMapping();

    //     ret
}

void ApplyGraphicsCharacterSetOverride()//Offset 0x15ee
{
    //TODO
    //     mov   al, BDA_VPCB_GrahicsCharSetOverride;0xc
    //     call  LookupVideoParameterControlBlockPointer;Offset 0x317d
    //     je    Label0x1611                   ;Offset 0x1611
    //     mov   al, 07h
    //     call  AppliesToCurrentMode                    ;Offset 0x30b5
    //     jne   Label0x1611                   ;Offset 0x1611
    //     lodsb byte ptr es:[si]
    //     dec   ax
    //     mov   byte ptr ds:[BDA_RowsOnScreen], al;Offset 0x484
    //     lodsw word ptr es:[si]
    //     mov   word ptr ds:[BDA_PointHeightOfCharacterMatrix], ax;Offset 0x485
    //     lodsw word ptr es:[si]
    //     mov   word ptr ds:[INT_43_HandlerOfs], ax;Offset 0x10c
    //     lodsw word ptr es:[si]
    //     mov   word ptr ds:[INT_43_HandlerSeg], ax;Offset 0x10e
    // Label0x1611:                            ;Offset 0x1611
    //     ret
}

void Func0x1574()
{
    //TODO
    //     call  GetNumberOfActiveScanlines    ;Offset 0x3054
    //     dec   al
    //     js    Label0x158e                   ;Offset 0x158e
    //     lea   ax, [Font8x16]                ;Offset 0x3f20
    //     mov   word ptr ds:[INT_43_HandlerOfs], ax;Offset 0x10c
    //     mov   ax, cs
    //     mov   word ptr ds:[INT_43_HandlerSeg], ax;Offset 0x10e
    //     jne   Label0x158e                   ;Offset 0x158e
    //     mov   ax, 0bd70h
    //     int   6dh
    // Label0x158e:                            ;Offset 0x158e
    //     xor   ax, ax
    //     mov   word ptr ds:[BDA_CursorEndScanLine], ax;Offset 0x460
    //     call  ApplyGraphicsCharacterSetOverride                    ;Offset 0x15ee
    //     ret
}

void ApplyPaletteOverride()
{
    //TODO
    //     mov   al, BDA_VPCB_PaletterProfileTable;0xa
    //     call  LookupVideoParameterControlBlockPointer;Offset 0x317d
    //     je    Label0x15ed                   ;Offset 0x15ed
    //     mov   al, 14h
    //     call  AppliesToCurrentMode                    ;Offset 0x30b5
    //     jne   Label0x15ed                   ;Offset 0x15ed
    //     lodsb byte ptr es:[si]
    //     or    al, al
    //     je    Label0x15bb                   ;Offset 0x15bb
    //     mov   ax, 1420h
    //     js    Label0x15b3                   ;Offset 0x15b3
    //     mov   al, byte ptr ds:[BDA_PointHeightOfCharacterMatrix];Offset 0x485
    // Label0x15b3:                            ;Offset 0x15b3
    //     dec   ax
    //     xchg  al, ah
    //     mov   dx, word ptr ds:[BDA_VideoBaseIOPort];Offset 0x463
    //     out   dx, ax
    // Label0x15bb:                            ;Offset 0x15bb
    //     test  byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_PaletteLoadingEnabled;Offset 0x489 0x8
    //     jne   Label0x15ed                   ;Offset 0x15ed
    //     push  es
    //     push  si
    //     add   si, 0003h
    //     lodsw word ptr es:[si]
    //     xchg  ax, cx
    //     lodsw word ptr es:[si]
    //     les   si, es:[si]
    //     jcxz  Label0x15d6                   ;Offset 0x15d6
    //     mov   ah, 10h
    //     call  LoadAttributeControllerRegs                    ;Offset 0x2ebb
    // Label0x15d6:                            ;Offset 0x15d6
    //     pop   si
    //     pop   es
    //     add   si, 000bh
    //     lodsw word ptr es:[si]
    //     xchg  ax, cx
    //     lodsw word ptr es:[si]
    //     les   si, es:[si]
    //     jcxz  Label0x15ed                   ;Offset 0x15ed
    //     mov   dx, VGA_DACWriteIndex         ;Port 0x3c8
    //     out   dx, al
    //     inc   dx
    //     call  Func0x2f93                    ;Offset 0x2f93
    // Label0x15ed:                            ;Offset 0x15ed
    //     ret
}

void ActivateAttributeController()
{
    using namespace Hag;
    using namespace Hag::System;

    // push  dx
    // mov   dx, word ptr ds:[BDA_VideoBaseIOPort];Offset 0x463
    // add   dl, 06h                       ;Port 0x3?a
    // in    al, dx
    VGA::InputStatus1::Read(BDA::VideoBaseIOPort::Get() + 0x06);

    // mov   dl, VGA_AttributeControllerIndex_lowbyte;Port 0x3c0
    // mov   al, VGA_ATTR_PaletteAddressSource;0x20
    // out   dx, al
    VGA::AttributeControllerIndex::Write(VGA::AttributeControllerIndex::EnableVideoDisplay);

    // pop   dx
    // ret
}

void Func0x1499(Hag::VGA::VideoMode_t& videoMode, Hag::System::BDA::VideoModeOptions_t& videoModeOptions);

void Func0x13cf(Hag::VGA::VideoMode_t& videoMode, Hag::System::BDA::VideoModeOptions_t& videoModeOptions, Hag::VGA::Register_t& videoBaseIOPort, Hag::System::BDA::VideoParameterTable* videoParameterTableOverride)//Offset 0x13cf
{
    using namespace Hag;
    using namespace Hag::System;
    using namespace Hag::Matrox::Shared;

    REGPACK r;
    memset(&r, 0, sizeof(r));
    uint16_t saveAX = 0;
    uint16_t saveDX = 0;

    //;
    //;inputs:
    //;   al = display mode
    //;   ah = video mode options
    //;   si = video base io port
    //;
    //;
    r.h.al = videoMode;
    r.h.ah = videoModeOptions;
    r.w.si = videoBaseIOPort;

    //     push      bx
    //     push      cx
    //     push      dx
    //     push      bp
    //     push      es

    //     push      ax
    saveAX = r.w.ax;

    //     call      TurnScreenOff             ;Offset 0x3109
    r.h.al = TurnScreenOff();

    //     mov       dx, ax
    r.w.dx = r.w.ax;

    //     pop       ax
    r.w.ax = saveAX;

    //     push      dx
    saveDX = r.w.dx;

    //     mov       byte ptr ds:[BDA_DisplayMode], al;Offset 0x449
    BDA::DisplayMode::Get() = r.h.al;
    
    //     mov       byte ptr ds:[BDA_VideoModeOptions], ah;Offset 0x487
    BDA::VideoModeOptions::Get() = r.h.ah;

    //     mov       word ptr ds:[BDA_VideoBaseIOPort], si;Offset 0x463
    BDA::VideoBaseIOPort::Get() = r.w.si;

    //     push      ax
    //     push      dx
    //     mov       dx, MGA_CRTCExtensionIndex;Port 0x3de
    //     mov       al, MGA_CRTCExt_HorCounterExt;0x1
    //     out       dx, al
    //     inc       dx
    //     in        al, dx
    //     or        al, MGA_CRTCEXT1_HorSyncOff OR MGA_CRTCEXT1_VerSyncOff;0x30
    //     out       dx, al
    //     pop       dx
    //     pop       ax
    CRTCExtension::HorizontalCounterExtensions::Write(
        CRTCExtension::HorizontalCounterExtensions::Read() |
        CRTCExtension::HorizontalCounterExtensions::HorizontalSyncOff |
        CRTCExtension::HorizontalCounterExtensions::VerticalSyncOff);

    //     call      Func0x1499                ;Offset 0x1499
    Func0x1499(r.h.al, r.h.ah);

    //     xor       ax, ax
    r.w.ax = 0;

    //     mov       es, ax
    r.w.es = r.w.ax;

    //     mov       byte ptr ds:[BDA_ActiveDisplayNumber], al;Offset 0x462
    BDA::ActiveDisplayNumber::Get() = r.h.al;

    //     mov       word ptr ds:[BDA_VideoBufferOffset], ax;Offset 0x44e
    BDA::VideoBufferOffset::Get() = r.w.ax;

    //     lea       di, ds:[DBA_CursorPositionPage0];Offset 0x450
    //     mov       cx, 0008h
    //     rep stosw
    BDA::CursorPositions::Clear();

    //     call      GetVideoParameterTable                ;Offset 0x2fe4
    BDA::VideoParameterTable& videoParameterTable = videoParameterTableOverride != NULL ? *videoParameterTableOverride : *GetVideoParameterTable();

    //     xor       ax, ax
    r.w.ax = 0;

    //     lodsb     byte ptr es:[si]
    //     mov       word ptr ds:[BDA_NumberOfScreenColumns], ax;Offset 0x44a
    BDA::NumberOfScreenColumns::Get() = videoParameterTable.NumCharacterColumns;
    
    //     lodsb     byte ptr es:[si]
    //     mov       byte ptr ds:[BDA_RowsOnScreen], al;Offset 0x484
    BDA::RowsOnScreen::Get() = videoParameterTable.NumScreenRowsMinus1;
    
    //     lodsb     byte ptr es:[si]
    //     mov       word ptr ds:[BDA_PointHeightOfCharacterMatrix], ax;Offset 0x485
    BDA::PointHeightOfCharacterMatrix::Get() = videoParameterTable.CharacterMatrixHeightInPoints;

    //     lodsw     word ptr es:[si]
    //     mov       word ptr ds:[BDA_VideoBufferSize], ax;Offset 0x44c
    BDA::VideoBufferSize::Get() = videoParameterTable.VideoBufferSize;

    //     mov       ax, word ptr es:[si + 0fh]
    //     xchg      al, ah
    //     mov       word ptr ds:[BDA_CursorEndStartScanLine], ax;Offset 0x460
    BDA::CursorScanLines::Get().Start = videoParameterTable.CRTCRegisters[VGA::CRTController::Register::CursorStartScanLine];
    BDA::CursorScanLines::Get().End = videoParameterTable.CRTCRegisters[VGA::CRTController::Register::CursorEndScanLine];

    //     call      Func0x2e39                ;Offset 0x2e39
    Func0x2e39(videoParameterTable);

    //     mov       dx, VGA_AttributeControllerIndex;Port 0x3c0
    //     mov       al, VGA_ATTR_ColorSelect  ;0x14
    //     out       dx, al
    //     xor       al, al
    r.h.al = 0;
    //     out       dx, al
    VGA::AttributeController::PixelPadding::Write(0);

    //     push      ax
    //     push      dx
    //     mov       dx, MGA_CRTCExtensionIndex;Port 0x3de
    //     mov       al, MGA_CRTCExt_HorCounterExt;0x1
    //     out       dx, al
    //     inc       dx
    //     in        al, dx
    //     and       al, NOT (MGA_CRTCEXT1_HorSyncOff OR MGA_CRTCEXT1_VerSyncOff);0xcf
    //     out       dx, al
    //     pop       dx
    //     pop       ax
    CRTCExtension::HorizontalCounterExtensions::Write(
        CRTCExtension::HorizontalCounterExtensions::Read() &
        ~(CRTCExtension::HorizontalCounterExtensions::HorizontalSyncOff |
        CRTCExtension::HorizontalCounterExtensions::VerticalSyncOff));

    //     call      InitializeAndSavePalettes                ;Offset 0x152a
    InitializeAndSavePalettes(videoParameterTable);

    //     call      ClearScreen               ;Offset 0x2ca5
    ClearScreen();

    //     lea       si, [SelectAndLoadFont]          ;Offset 0x1549
    //     call      Func0x30a2                ;Offset 0x30a2
    //     je        Label0x145c               ;Offset 0x145c
    //     lea       si, [Func0x1574]          ;Offset 0x1574
    // Label0x145c:                            ;Offset 0x145c
    //     call      si
    if (Func0x30a2())
        SelectAndLoadFont();
    else
        Func0x1574();

    //     call      ApplyPaletteOverride                ;Offset 0x1597
    ApplyPaletteOverride();

    //     call      ActivateAttributeController                ;Offset 0x30c9
    ActivateAttributeController();

    //     pop       ax
    //     call      TurnScreenOn              ;Offset 0x3105
    TurnScreenOn();
    
    static BDA::CRTModeControlRegValue_t CRTModeControlRegValue[] =
    {
        BDA::CRTModeControlRegValue::Monochrome |
        BDA::CRTModeControlRegValue::VideoEnabled |
        BDA::CRTModeControlRegValue::Blinking,//0x2c
        BDA::CRTModeControlRegValue::VideoEnabled |
        BDA::CRTModeControlRegValue::Blinking,//0x28
        BDA::CRTModeControlRegValue::Mode2Or3Text |
        BDA::CRTModeControlRegValue::Monochrome |
        BDA::CRTModeControlRegValue::VideoEnabled |
        BDA::CRTModeControlRegValue::Blinking,//0x2d
        BDA::CRTModeControlRegValue::Mode2Or3Text |
        BDA::CRTModeControlRegValue::VideoEnabled |
        BDA::CRTModeControlRegValue::Blinking,//0x29
        BDA::CRTModeControlRegValue::Mode4Or5Graphics |
        BDA::CRTModeControlRegValue::VideoEnabled |
        BDA::CRTModeControlRegValue::Blinking,//0x2a
        BDA::CRTModeControlRegValue::Mode4Or5Graphics |
        BDA::CRTModeControlRegValue::Monochrome |
        BDA::CRTModeControlRegValue::VideoEnabled |
        BDA::CRTModeControlRegValue::Blinking,//0x2e
        BDA::CRTModeControlRegValue::Mode4Or5Graphics |
        BDA::CRTModeControlRegValue::Monochrome |
        BDA::CRTModeControlRegValue::VideoEnabled |
        BDA::CRTModeControlRegValue::GraphicsOperation,//0x1e
        BDA::CRTModeControlRegValue::Mode2Or3Text |
        BDA::CRTModeControlRegValue::VideoEnabled |
        BDA::CRTModeControlRegValue::Blinking//0x29
    };

    //     mov       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    //     cmp       al, BDA_DM_80x25_Monochrome_Text;0x7
    //     ja        Label0x1486               ;Offset 0x1486
    if (BDA::DisplayMode::Get() <= VGA::VideoMode::T80x25x1bppM)
    {
        //     mov       ah, al
        //     lea       bx, [CRTModeControlRegValue]           ;Offset 0x4a8
        //     xlatb     cs:[bx]
        //     mov       byte ptr ds:[BDA_CRTModeControlRegValue], al;Offset 0x465
        BDA::CRTModeControlRegValue::Get() = CRTModeControlRegValue[BDA::DisplayMode::Get()];

        //     mov       al, 30h
        //     cmp       ah, BDA_DM_640x200_BW_Graphics;0x6
        //     jne       Label0x1483               ;Offset 0x1483
        //     mov       al, 3fh
        // Label0x1483:                            ;Offset 0x1483
        //     mov       byte ptr ds:[BDA_CGAColorPaletteMaskSetting], al;Offset 0x466
        BDA::CGAColorPaletteMaskSetting::Get() = BDA::DisplayMode::Get() == VGA::VideoMode::G640x200x1bppM ? 0x3f : 0x30;
    }
    // Label0x1486:                            ;Offset 0x1486
    //     mov       al, byte ptr ds:[BDA_VideoDisplayDataArea];Offset 0x489
    //     and       al, BDA_VDDA_Reserved     ;0x20
    //     je        Label0x1492               ;Offset 0x1492
    //if ((BDA::VideoDisplayDataArea::Get() & BDA::VideoDisplayDataArea::Reserved) != 0x00)
    //{
        //     and       byte ptr ds:[BDA_VideoDisplayDataArea], NOT BDA_VDDA_Reserved;Offset 0x489 0xdf
        BDA::VideoDisplayDataArea::Get() &= ~BDA::VideoDisplayDataArea::Reserved;
    //}
    // Label0x1492:                            ;Offset 0x1492
    
    //     pop       es
    //     pop       bp
    //     pop       dx
    //     pop       cx
    //     pop       bx

    //     pop       ax
    //     ret
}

void Func0x13cc(Hag::VGA::VideoMode_t& videoMode, Hag::System::BDA::VideoModeOptions_t& videoModeOptions, Hag::VGA::Register_t& videoBaseIOPort, Hag::System::BDA::VideoParameterTable* videoParameterTableOverride)//Offset 0x13cc
{
    //;
    //;inputs:
    //;   al = display mode
    //;   ah = video mode options
    //;   si = video base io port
    //;
    //;
    //and       ah, NOT BDA_VMO_DontClearDisplay;0x7f
    videoModeOptions &= ~Hag::System::BDA::VideoModeOptions::DontClearDisplay;
    Func0x13cf(videoMode, videoModeOptions, videoBaseIOPort, videoParameterTableOverride);
}

void DeactivateAndInvokeSystemHandler(Hag::VGA::VideoMode_t videoMode, Hag::System::BDA::VideoModeOptions_t videoModeOptions)//Offset 0x13aa
{
    using namespace Hag::System;
    // mov  byte ptr ds:[BDA_RowsOnScreen], 18h;Offset 0x484 0x18
    BDA::RowsOnScreen::Get() = 0x18;

    // or   ah, BDA_VMO_Inactive           ;0x8
    videoModeOptions |= BDA::VideoModeOptions::Inactive;

    // mov  byte ptr ds:[BDA_VideoModeOptions], ah;Offset 0x487
    BDA::VideoModeOptions::Get() = videoModeOptions;

    // cbw
    // int  42h
    // ret
    //printf("Invoke system int 10h handler.\n");
}

void DeactivateAndForward(Hag::VGA::VideoMode_t videoMode, Hag::System::BDA::VideoModeOptions_t videoModeOptions)//Offset 0x1399
{
    using namespace Hag::System;

    // mov  word ptr ds:[BDA_PointHeightOfCharacterMatrix], 0eh;Offset 0x485 0xe
    BDA::PointHeightOfCharacterMatrix::Get() = 0x0E;

    // call DeactivateAndInvokeSystemHandler                     ;Offset 0x13aa
    DeactivateAndInvokeSystemHandler(videoMode, videoModeOptions);

    // mov  word ptr ds:[BDA_CursorEndStartScanLine], 0b0ch;Offset 0x460
    BDA::CursorScanLines::Get().Start = 0x0B;
    BDA::CursorScanLines::Get().End = 0x0C;

    // pop  ax
    // ret
}

void Func0x13ba(Hag::VGA::VideoMode_t& videoMode, Hag::System::BDA::VideoModeOptions_t& videoModeOptions, Hag::System::BDA::VideoParameterTable* videoParameterTableOverride)//Offset 0x13ba
{
    //;
    //;inputs:
    //;   al = display mode
    //;   ah = video mode options
    //;
    //;
    //    test      ah, BDA_VMO_Monochrome    ;0x2
    //    je        DeactivateAndForward                ;Ofset 0x1399
    if ((videoModeOptions & Hag::System::BDA::VideoModeOptions::Monochrome) == 0)
    {
        DeactivateAndForward(videoMode, videoModeOptions);
        RETURN("Func0x13ba.Return 1");
    }
    //    mov       si, VGA_CRTControllerIndexB;Port 0x3b4
    Hag::VGA::Register_t videoBaseIOPort = Hag::VGA::Register::CRTControllerIndexB;

    //    cmp       al, BDA_DM_80x25_Monochrome_Text;0x7
    //    je        Func0x13cf                ;Offset 0x13cf
    if (videoMode == Hag::VGA::VideoMode::T80x25x1bppM)
    {
        Func0x13cf(videoMode, videoModeOptions, videoBaseIOPort, videoParameterTableOverride);
        RETURN("Func0x13ba.Return 2");
    }
    //    cmp       al, BDA_DM_640x350_Monochrome_Graphics;0xf
    //    je        Func0x13cf                ;Offset 0x13cf
    if (videoMode == Hag::VGA::VideoMode::G640x350x1bppM)
    {
        Func0x13cf(videoMode, videoModeOptions, videoBaseIOPort, videoParameterTableOverride);
        RETURN("Func0x13ba.Return 3");
    }
    //    mov       al, BDA_DM_80x25_Monochrome_Text;0x7
    videoMode = Hag::VGA::VideoMode::T80x25x1bppM;
    Func0x13cc(videoMode, videoModeOptions, videoBaseIOPort, videoParameterTableOverride);

    RETURN("Func0x13ba.Return 4");
}

void ConfigureEGAFeatureBitSwitchesAdapter(Hag::VGA::VideoMode_t& videoMode, Hag::System::BDA::VideoModeOptions_t& modeOptions)//Offset 0x149c
{
    using namespace Hag;
    using namespace Hag::System;

    REGPACK r;
    memset(&r, 0, sizeof(r));
    uint8_t* siPointer = NULL;
    bool isLower = false;

    r.h.al = videoMode;
    r.h.ah = modeOptions;
    
    //Data0x1520              DB 080h, VGA_CRTControllerIndexB_lowbyte, 0FFh, BDA_DH_80x25Monochrome, 002h;0x80 0xB4 0xFF 0x30 0x02
    static uint8_t Data0x1520[] = 
    {
        0x80,
        (uint8_t)VGA::Register::CRTControllerIndexB,
        0xFF,
        BDA::DetectedHardware::Monochrome80x25,
        BDA::VideoModeOptions::Monochrome
    };
    //Data0x1525              DB 001h, VGA_CRTControllerIndexD_lowbyte, BDA_DH_80x25Monochrome, 000h, 000h;0x01 0xD4 0x30 0x00 0x00
    static uint8_t Data0x1525[] =
    {
        0x01,
        (uint8_t)VGA::Register::CRTControllerIndexD,
        BDA::DetectedHardware::Monochrome80x25,
        0x00,
        BDA::VideoModeOptions::Color
    };

    //     test      byte ptr ds:[BDA_VideoDisplayDataArea], BDA_VDDA_VGA;Offset 0x489 0x1
    //     je        Label0x151f               ;Offset 0x151f
    if ((BDA::VideoDisplayDataArea::Get() & BDA::VideoDisplayDataArea::VGA) == 0)
        goto Label0x151f;

    //     cmp       al, byte ptr ds:[BDA_DisplayMode];Offset 0x449
    //     je        Label0x151f               ;Offset 0x151f
    if (r.h.al == BDA::DisplayMode::Get())
        goto Label0x151f;

    //     push      bx
    //     push      dx
    //Unnecessary

    //     lea       si, [Data0x1520]          ;Offset 0x1520
    siPointer = Data0x1520;

    //     cmp       al, BDA_DM_80x25_Monochrome_Text;0x7
    //     je        Label0x14bb               ;Offset 0x14bb
    if (r.h.al == VGA::VideoMode::T80x25x1bppM)
        goto Label0x14bb;

    //     cmp       al, BDA_DM_640x350_Monochrome_Graphics;0xf
    //     je        Label0x14bb               ;Offset 0x14bb
    if (r.h.al == VGA::VideoMode::G640x350x1bppM)
        goto Label0x14bb;

    //     add       si, 0005h
        siPointer = Data0x1525;

    // Label0x14bb:                            ;Offset 0x14bb
LABEL(ConfigureEGAFeatureBitSwitchesAdapter, Label0x14bb);

    //     xchg      ax, bx
    {
        uint16_t tmp = r.w.ax;
        r.w.ax = r.w.bx;
        r.w.bx = tmp;
    }

    //     mov       al, byte ptr ds:[BDA_VideoBaseIOPort];Offset 0x463
    r.h.al = uint8_t(BDA::VideoBaseIOPort::Get());

    //     cmp       al, byte ptr cs:[si + 01h]
    //     je        Label0x151c               ;Offset 0x151c
    if (r.h.al == siPointer[1])
        goto Label0x151c;

    //     mov       ah, bl
    r.h.ah = r.h.bl;

    //     mov       al, byte ptr ds:[BDA_DetectedHardware];Offset 0x410
    r.h.al = BDA::DetectedHardware::Get();

    //     and       al, BDA_DH_InitialVideoModeMask;0x30
    r.h.al &= BDA::DetectedHardware::InitialVideoModeMask;

    //     mov       bl, BDA_DM_80x25_Monochrome_Text;0x7
    r.h.bl = VGA::VideoMode::T80x25x1bppM;

    //     cmp       al, byte ptr cs:[si + 02h]
    //     je        Label0x151c               ;Offset 0x151c
    if (r.h.al == siPointer[2])
        goto Label0x151c;

    //     mov       bl, BDA_DM_80x25_16_Color_Text;0x3
    r.h.bl = VGA::VideoMode::T80x25x4bppC;

    //     cmp       al, byte ptr cs:[si + 03h]
    //     js        Label0x151c               ;Offset 0x151c
    if (r.h.al < siPointer[3])
        goto Label0x151c;

    //     mov       bl, ah
    r.h.bl = r.h.ah;

    //     and       bh, 0fdh
    r.h.bh &= ~BDA::VideoModeOptions::Monochrome;

    //     or        bh, byte ptr cs:[si + 04h]
    r.h.bh |= siPointer[4];

    //     mov       al, byte ptr ds:[BDA_EGAFeatureBitSwitches];Offset 0x488
    r.h.al = BDA::EGAFeatureBitSwitches::Get();

    //     and       al, BDA_EFBS_AdapterTypeMask;0xf
    r.h.al &= BDA::EGAFeatureBitSwitches::AdapterTypeMask;

    //     sub       al, BDA_EFBS_MDAColor40x25_2;0x6
    r.h.al -= BDA::EGAFeatureBitSwitches::MDAColor40x25_2;

    //     cmp       al, BDA_EFBS_CGAMono80x25 ;0x5
    //     ja        Label0x151c               ;Offset 0x151c
    if (r.h.al > BDA::EGAFeatureBitSwitches::CGAMono80x25)
        goto Label0x151c;

    //     sub       al, BDA_EFBS_MDAHiResEnhanced;0x3
    isLower = r.h.al <= BDA::EGAFeatureBitSwitches::MDAHiResEnhanced;
    r.h.al -= BDA::EGAFeatureBitSwitches::MDAHiResEnhanced;

    //     cbw
    r.h.ah = ((r.h.al & 0x80) != 0) ? 0xFF : 0x00;

    //     mov       al, BDA_EFBS_CGAMono80x25_2;0xb
    r.h.al = BDA::EGAFeatureBitSwitches::CGAMono80x25_2;

    //     jbe       Label0x14f9               ;Offset 0x14f9
    if (isLower)
        goto Label0x14f9;

    //     mov       al, BDA_EFBS_MDAHiResEnhanced_2;0x9
    r.h.al = BDA::EGAFeatureBitSwitches::MDAHiResEnhanced_2;

    // Label0x14f9:                            ;Offset 0x14f9
LABEL(ConfigureEGAFeatureBitSwitchesAdapter, Label0x14f9);

    //     mov       dl, byte ptr ds:[BDA_VideoDisplayDataArea];Offset 0x489
    r.h.dl = BDA::VideoDisplayDataArea::Get();

    //     mov       dh, dl
    r.h.dh = r.h.dl;

    //     and       dx, 807fh
    r.h.dl &= ~BDA::VideoDisplayDataArea::LineMode200;
    r.h.dh &= BDA::VideoDisplayDataArea::LineMode200;

    //     rol       dh, 01h
    r.h.dh = (r.h.dh << 1) | (r.h.dh >> 7);

    //     and       dh, byte ptr cs:[si]
    r.h.dh &= siPointer[0];

    //     sub       al, dh
    r.h.al -= r.h.dh;

    //     and       ah, byte ptr cs:[si]
    r.h.ah &= siPointer[0];

    //     or        dl, ah
    r.h.dl |= r.h.ah;

    //     and       byte ptr ds:[BDA_EGAFeatureBitSwitches], BDA_EFBS_FeatureConnectorMask;Offset 0x488 0xf0
    BDA::EGAFeatureBitSwitches::Get() &= BDA::EGAFeatureBitSwitches::FeatureConnectorMask;

    //     or        byte ptr ds:[BDA_EGAFeatureBitSwitches], al;Offset 0x488
    BDA::EGAFeatureBitSwitches::Get() |= r.h.al;

    //     mov       byte ptr ds:[BDA_VideoDisplayDataArea], dl;Offset 0x489
    BDA::VideoDisplayDataArea::Get() = r.h.dl;

    // Label0x151c:                            ;Offset 0x151c
LABEL(ConfigureEGAFeatureBitSwitchesAdapter, Label0x151c);

    //     xchg      ax, bx
    {
        uint16_t tmp = r.w.ax;
        r.w.ax = r.w.bx;
        r.w.bx = tmp;
    }

    //     pop       dx
    //     pop       bx
    // Label0x151f:                            ;Offset 0x151f
LABEL(ConfigureEGAFeatureBitSwitchesAdapter, Label0x151f);
    //     ret
    videoMode = r.h.al;
    modeOptions = r.h.ah;
}

bool IsExtensionReg7Writeable()//Offset 0x5606
{
    using namespace Hag::Matrox;
    // push dx
    // mov  dx, MGA_CRTCExtensionIndex     ;Port 0x3de
    // mov  al, MGA_CRTCExt_Reserved7      ;0x7
    // out  dx, al
    Shared::CRTCExtensionIndex::Write(0x07);

    // in   ax, dx
    Shared::CRTCExtensionData_t save = Shared::CRTCExtensionData::Read();

    // push ax
    // mov  ax, 0a007h                     ;Unknown values.
    // out  dx, ax                         ;It seems to be checking if extension reg 7 is writeable.
    Shared::CRTCExtensionData::Write(0x07, 0x0A);

    // in   ax, dx
    // cmp  ah, 0a0h
    bool equal = Shared::CRTCExtensionData::Read() == 0x0A;
    
    // pop  ax
    // out  dx, ax
    Shared::CRTCExtensionData::Write(0x07, save);

    // pop  dx
    // ret
    return equal;
}

uint8_t Data0x7814 = 0xEE;

void ResetCRTCExtensionRegisters()//Offset 0x6257
{
    using namespace Hag;
    using namespace Hag::System;
    using namespace Hag::Matrox;
    
    REGPACK r;
    memset(&r, 0, sizeof(r));
    PCI::Device_t mystique = 0;
    
    //     push bx
    //     push cx
    //     push dx
    //     push si
    //     push di
    //     call IsExtensionReg7Writeable       ;Offset 0x5606
    //     je   ExtensionRegistersNotWriteable                    ;Offset 0x62db
    if (IsExtensionReg7Writeable())
        goto ExtensionRegistersNotWriteable;
    //     push es
    //     push ds
    //     push cs
    //     pop  ds
    //     call FindMystique                   ;Offset 0x57c6
    PCI::FindDevice(0x102B, 0x051A, mystique);
    //printf("PCI device found: 0x%04X\n", mystique);

    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call ReadIndexedRegister            ;Offset 0x5bab
    //     and  cl, NOT (MGA_MISCCTRL_MAFC_MASK OR MGA_MISCCTRL_DAC_Bit_MASK);0xf1
    //     mov  ch, cl
    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::MiscellaneousControl::Write(mystique,
        Shared::PCI::Indexed::MiscellaneousControl::Read(mystique) &
        ~(Shared::Indexed::MiscellaneousControl::MAFCFuncSelect | Shared::Indexed::MiscellaneousControl::VGADACBitDepth));
    
    //     mov  cl, MGA_INDD_MultiplexControl  ;0x19
    //     xor  ch, ch                         ;MGA_MULCTRL_Depth8
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::MultiplexControl::Write(mystique, Shared::Indexed::MultiplexControl::Bits8p);

    //     mov  cl, MGA_INDD_GeneralControl    ;0x1d
    //     call ReadIndexedRegister            ;Offset 0x5bab
    //     and  cl, NOT MGA_GENCTRL_PedestalControl_MASK;0xef
    //     mov  al, byte ptr cs:[Data0x7814]   ;Offset 0x7814
    //     and  al, 01h
    //     shl  al, 04h                        ;Pedestal Control
    //     or   cl, al
    //     mov  ch, MGA_INDD_GeneralControl    ;0x1d
    //     xchg cl, ch
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::GeneralControl::Write(mystique,
        (Shared::PCI::Indexed::GeneralControl::Read(mystique) &
        ~Shared::Indexed::GeneralControl::PedestalControl) |
        ((Data0x7814 & 0x01) << 4));

    //     mov  cl, MGA_INDD_GeneralControl    ;0x1d
    //     call ReadIndexedRegister            ;Offset 0x5bab
    //     and  cl, NOT MGA_GENCTRL_GreenSyncOut_MASK;0xdf
    //     mov  al, byte ptr cs:[Data0x7814]   ;Offset 0x7814
    //     and  al, MGA_GENCTRL_GreenSyncOut_MASK;0x20
    //     or   cl, al
    //     mov  ch, MGA_INDD_GeneralControl    ;0x1d
    //     xchg cl, ch
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::GeneralControl::Write(mystique,
        (Shared::PCI::Indexed::GeneralControl::Read(mystique) &
        ~Shared::Indexed::GeneralControl::GreenChannelSync) |
        (Data0x7814 & Shared::Indexed::GeneralControl::GreenChannelSync));

    //     mov  cl, MGA_INDD_GeneralControl    ;0x1d
    //     call ReadIndexedRegister            ;Offset 0x5bab
    //     and  cl, MGA_GENCTRL_PedestalControl_MASK OR MGA_GENCTRL_GreenSyncOut_MASK;0x30
    //     mov  ch, MGA_INDD_GeneralControl    ;0x1d
    //     xchg cl, ch
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::GeneralControl::Write(mystique,
        Shared::PCI::Indexed::GeneralControl::Read(mystique) &
        (Shared::Indexed::GeneralControl::PedestalControl |
        Shared::Indexed::GeneralControl::GreenChannelSync));

    //     mov  cl, MGA_INDD_CursorControl     ;0x6
    //     mov  ch, MGA_CURCTRL_CursorDisabled ;0x0
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::CursorControl::Write(mystique,
        Shared::Indexed::CursorControl::Disabled);

    //     mov  cl, MGA_INDD_PixelClockControl ;0x1a
    //     call ReadIndexedRegister            ;Offset 0x5bab
    //     and  cl, NOT MGA_PIXCLKCTRL_SelMASK ;0xfc
    //     or   cl, MGA_PIXCLKCTRL_SelPLL      ;0x1
    //     mov  ch, cl
    //     mov  cl, MGA_INDD_PixelClockControl ;0x1a
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::PixelClockControl::Write(mystique,
        (Shared::PCI::Indexed::PixelClockControl::Read(mystique) &
        ~Shared::Indexed::PixelClockControl::ClockSelection) |
        Shared::Indexed::PixelClockControl::ClockPLL);

    //     pop  ds
    //     pop  es
    // ExtensionRegistersNotWriteable:                            ;Offset 0x62db
LABEL(ResetCRTCExtensionRegisters, ExtensionRegistersNotWriteable);

    //     mov  ax, MGA_CRTCExt_AddrGeneratorExt SHL 8;0x0
    //     call MGAWriteCRTCExtensionRegister  ;Offset 0x3c4
    Shared::CRTCExtension::AddressGeneratorExtensions::Write(0x00);

    //     mov  ax, (MGA_CRTCExt_HorCounterExt SHL 8) OR MGA_CRTCEXT1_HorSyncOff OR MGA_CRTCEXT1_VerSyncOff;0x130
    //     call MGAWriteCRTCExtensionRegister  ;Offset 0x3c4
    Shared::CRTCExtension::HorizontalCounterExtensions::Write(
        Shared::CRTCExtension::HorizontalCounterExtensions::HorizontalSyncOff |
        Shared::CRTCExtension::HorizontalCounterExtensions::VerticalSyncOff);

    //     mov  ax, MGA_CRTCExt_VertCounterExt SHL 8;0x200
    //     call MGAWriteCRTCExtensionRegister  ;Offset 0x3c4
    Shared::CRTCExtension::VerticalCounterExtensions::Write(0x00);

    //     mov  dx, MGA_CRTCExtensionIndex     ;Port 0x3de
    //     mov  ah, byte ptr cs:[Data0x7814]   ;Offset 0x7814
    //     and  ah, MGA_CRTCEXT3_CompSyncEnable SHR 2;10h
    //     shl  ah, 02h                        ;MGA_CRTCEXT3_CompSyncEnable
    //     mov  al, MGA_CRTCExt_Misc           ;0x3
    //     out  dx, ax
    Shared::CRTCExtension::Miscellaneous::Write(
        (Data0x7814 & (Shared::CRTCExtension::Miscellaneous::CompositeSyncEnable >> 2)) << 2);

    //     mov  ax, MGA_CRTCExt_MemoryPage SHL 8;0x400
    //     call MGAWriteCRTCExtensionRegister  ;Offset 0x3c4
    Shared::CRTCExtension::MemoryPage::Write(0x00);

    //     mov  ax, MGA_CRTCExt_HorVidHalfCount SHL 8;0x500
    //     call MGAWriteCRTCExtensionRegister  ;Offset 0x3c4
    Shared::CRTCExtension::HorizontalHalfCount::Write(0x00);

    //     pop  di
    //     pop  si
    //     pop  dx
    //     pop  cx
    //     pop  bx
    //     ret
}

void Func0x1499(Hag::VGA::VideoMode_t& videoMode, Hag::System::BDA::VideoModeOptions_t& videoModeOptions)//Offset 0x1499
{
    //call      ResetCRTCExtensionRegisters                ;Offset 0x6257
    ResetCRTCExtensionRegisters();
    ConfigureEGAFeatureBitSwitchesAdapter(videoMode, videoModeOptions);
}

Hag::Vesa::VideoMode_t TranslateSpecialModes(Hag::Vesa::VideoMode_t videoMode)//Offset 0x70a8
{
    //     push cx
    //     cmp  bx, 81ffh                      ;full memory access mode.
    //     jne  Label0x70b5                    ;Offset 0x70b5
    if (videoMode != 0x81FF)
        goto Label0x70b5;

    //     mov  bx, 011fh                      ;replace with 0x11f
    //     jmp  Label0x70ca                    ;Offset 0x70ca
    goto Label0x70ca;
    //     nop
    // Label0x70b5:                            ;Offset 0x70b5
LABEL(TranslateSpecialModes, Label0x70b5);

    //     mov  cx, bx
    //     and  cx, 01ffh
    //     cmp  cx, 006ah                      ;0x6a is also 0x102
    //     jne  Label0x70ca                    ;Offset 0x70ca
    if ((videoMode & Hag::Vesa::VideoMode::ModeMask) != 0x6A)
        goto Label0x70ca;

    //     and  bx, 0fe00h                     ;preserve flags
    //     or   bx, 0102h                      ;replace video mode
    videoMode = (videoMode & ~Hag::Vesa::VideoMode::ModeMask) | Hag::Vesa::VideoMode::G800x600x4bpp;

    // Label0x70ca:                            ;Offset 0x70ca
    LABEL(TranslateSpecialModes, Label0x70ca);

    //     pop  cx
    //     ret
    return videoMode;
}

//Offset 0x665d
Hag::Vesa::VideoMode_t SupportedVESAVideoModes[] =
{
    Hag::Vesa::VideoMode::G640x400x8bpp,        //0x100      //1MB
    Hag::Vesa::VideoMode::G640x480x8bpp,        //0x101
    Hag::Vesa::VideoMode::G800x600x4bpp,        //0x102
    Hag::Vesa::VideoMode::G800x600x8bpp,        //0x103
    Hag::Vesa::VideoMode::G1024x768x8bpp,       //0x105
    Hag::Vesa::VideoMode::G1280x1024x8bpp,      //0x107
    Hag::Vesa::VideoMode::T80x60x4bpp,          //0x108
    Hag::Vesa::VideoMode::T132x25x4bpp,         //0x109
    Hag::Vesa::VideoMode::T132x43x4bpp,         //0x10a
    Hag::Vesa::VideoMode::T132x50x4bpp,         //0x10b
    Hag::Vesa::VideoMode::T132x60x4bpp,         //0x10c
    0xFFFF,
    Hag::Vesa::VideoMode::G640x480x15bpp,       //0x110      //2MB
    Hag::Vesa::VideoMode::G640x480x16bpp,       //0x111
    Hag::Vesa::VideoMode::G640x480x32bpp,       //0x112
    Hag::Vesa::VideoMode::G800x600x15bpp,       //0x113
    Hag::Vesa::VideoMode::G800x600x16bpp,       //0x114
    Hag::Vesa::VideoMode::G800x600x32bpp,       //0x115
    Hag::Vesa::VideoMode::G1024x768x15bpp,      //0x116
    Hag::Vesa::VideoMode::G1024x768x16bpp,      //0x117
    Hag::Vesa::VideoMode::G1600x1200x8bpp2,     //0x11c
    0xFFFF,
    Hag::Vesa::VideoMode::G1024x768x32bpp,      //0x118      //4MB
    Hag::Vesa::VideoMode::G1280x1024x15bpp,     //0x119
    Hag::Vesa::VideoMode::G1280x1024x16bpp,     //0x11a
    Hag::Vesa::VideoMode::G1600x1200x15bpp2,    //0x11d
    Hag::Vesa::VideoMode::G1600x1200x16bpp2,    //0x11e
    0xFFFF
};

//;inputs:
//;   -
//;
//;outputs:
//;   ah = Size of memory in 64KB blocks
//;
uint8_t GetMemorySize()//Offset 0x5866
{
    using namespace Hag;
    using namespace Hag::Matrox;

    REGPACK r;
    memset(&r, 0, sizeof(r));

    uint16_t saveAX1 = 0;
    uint16_t saveAX2 = 0;
    uint16_t saveAX3 = 0;
    uint16_t saveAX4 = 0;
    uint16_t saveAX5 = 0;
    uint16_t saveDI = 0;
    uint16_t saveCX = 0;

    FARPointer ptr;
    uint8_t* siPointer = NULL;
    uint8_t* diPointer = NULL;
    bool valNotEqual = false;

    //     push  bx
    //     push  cx
    //     push  dx
    //     push  ds
    //     push  di
    //     push  si

    //     mov   dx, VGA_SequenceIndex         ;Port 0x3c4
    //     in    al, dx
    r.h.al = VGA::SequencerIndex::Read();
    
    //     push  ax
    saveAX1 = r.w.ax;

    //     mov   al, VGA_SEQIdx_ClockingMode   ;0x1
    //     out   dx, al
    //     in    ax, dx
    r.h.ah = VGA::Sequencer::ClockingMode::Read();
    r.h.al = VGA::Sequencer::Register::ClockingMode;

    //     push  ax
    saveAX2 = r.w.ax;

    //     or    ah, VGA_SEQ1_ScreenOff        ;0x20
    //     out   dx, ax
    VGA::Sequencer::ClockingMode::Write(r.h.ah | VGA::Sequencer::ClockingMode::ScreenOff);

    //     mov   cx, 04b0h
    // Label0x587d:                            ;Offset 0x587d
    //     loop  Label0x587d                   ;Offset 0x587d Speed sensitive!
    for (r.w.cx = 0x4b0; r.w.cx != 0x0000; --r.w.cx);

    //     mov   dx, VGA_GraphicsControllerIndex;Port 0x3ce
    //     mov   al, VGA_GCTLIdx_Miscellaneous ;0x6
    //     out   dx, al
    //     in    ax, dx
    r.h.ah = VGA::GraphicsController::MemoryMapModeControl::Read();
    r.h.al = VGA::GraphicsController::Register::MemoryMapModeControl;

    //     push  ax
    saveAX3 = r.w.ax;

    //     and   ah, VGA_GCTL6_GfxMode OR VGA_GCTL6_ChainEven;0x3
    r.h.ah &= VGA::GraphicsController::MemoryMapModeControl::SelectTextGraphicsMode | 
              VGA::GraphicsController::MemoryMapModeControl::ChainOddEvenPlanes;

    //     or    ah, VGA_GCTL6_Mem_A0000_AFFFF ;0x4h
    r.h.ah |= VGA::GraphicsController::MemoryMapModeControl::A0000HtoAFFFFH;

    //     out   dx, ax
    VGA::GraphicsController::MemoryMapModeControl::Write(r.h.ah);

    //     mov   dx, VGA_InputStatus1D         ;Port 0x3da
    //     xor   cx, cx
    r.w.cx = 0x0000;

    // Label0x5893:                            ;Offset 0x5893
LABEL(GetMemorySize, Label0x5893);

    //     dec   cx
    --r.w.cx;

    //     je    Label0x58a3                   ;Offset 0x58a3
    if (r.w.cx == 0x0000)
        goto Label0x58a3;

    //     in    al, dx
    r.h.al = VGA::InputStatus1::Read(VGA::Register::InputStatus1D);

    //     and   al, VGA_INSTS1_VerInactiveDisplayIntv;0x8
    r.h.al &= VGA::InputStatus1::VerticalSyncActive;

    //     je    Label0x5893                   ;Offset 0x5893
    if (r.h.al == 0x00)
        goto Label0x5893;

    // Label0x589b:                            ;Offset 0x589b
LABEL(GetMemorySize, Label0x589b);
    //     dec   cx
    --r.w.cx;

    //     je    Label0x58a3                   ;Offset 0x58a3
    if (r.w.cx == 0x0000)
        goto Label0x58a3;

    //     in    al, dx
    r.h.al = VGA::InputStatus1::Read(VGA::Register::InputStatus1D);

    //     and   al, VGA_INSTS1_VerInactiveDisplayIntv;0x8
    r.h.al &= VGA::InputStatus1::VerticalSyncActive;

    //     je    Label0x589b                   ;Offset 0x589b
    if (r.h.al == 0x00)
        goto Label0x589b;

    // Label0x58a3:                            ;Offset 0x58a3
LABEL(GetMemorySize, Label0x58a3);

    //     mov   dx, MGA_CRTCExtensionIndex    ;Port 0x3de
    //     mov   al, MGA_CRTCExt_Misc          ;0x3
    //     out   dx, al
    //     in    ax, dx
    r.h.ah = Shared::CRTCExtension::Miscellaneous::Read();
    r.h.al = Shared::CRTCExtension::Register::Miscellaneous;

    //     push  ax
    saveAX4 = r.w.ax;

    //     mov   ax, ((MGA_CRTCEXT3_ScaleDiv2 OR MGA_CRTCEXT3_MGAModeEnable) SHL 8) OR MGA_CRTCExt_Misc;0x8103
    //     out   dx, ax
    Shared::CRTCExtension::Miscellaneous::Write(Shared::CRTCExtension::Miscellaneous::ScaleDiv2 |
                                                Shared::CRTCExtension::Miscellaneous::MGAModeEnable);

    //     mov   al, MGA_CRTCExt_MemoryPage    ;0x4
    //     out   dx, al
    //     in    ax, dx
    r.h.ah = Shared::CRTCExtension::MemoryPage::Read();
    r.h.al = Shared::CRTCExtension::Register::MemoryPage;

    //     push  ax
    saveAX5 = r.w.ax;

    //     mov   bx, 0a000h                    ;Segment 0xa000
    r.w.bx = 0xA000;

    //     mov   ds, bx
    ptr.Segment = r.w.bx;
    
    //     xor   si, si
    r.w.si = 0x0000;
    
    //     dec   si
    --r.w.si;

    //     dec   si
    --r.w.si;
    ptr.Offset = r.w.si;
    siPointer = ptr.ToPointer<uint8_t>();//No size, we only poke one byte.

    //     call  FindMystique                  ;Offset 0x57c6
    //     call  ReadPCIDeviceID               ;Offset 0x5823

    //     mov   di, 2000h
    r.w.di = 0x2000;

    //     mov   bx, 8000h                     ;8MB max
    r.w.bx = 0x8000;

    //     cmp   ax, PCI_DEVICE_MillenniumIIPCI;0x051b
    //     jb    Label0x58d2                   ;Offset 0x58d2
    //     xor   bx, bx
    // Label0x58d2:                            ;Offset 0x58d2
    //The whole PCI device ID testing is irrelevant.

    //     mov   ax, (20h SHL 8)OR MGA_CRTCExt_MemoryPage;0x2004 Start at 2MB
    r.h.ah = 0x20;

    // Label0x58d5:                            ;Offset 0x58d5
LABEL(GetMemorySize, Label0x58d5);

    //     out   dx, ax
    Shared::CRTCExtension::MemoryPage::Write(r.h.ah);

    //     mov   ch, byte ptr [si]
    r.h.ch = *siPointer;

    //     mov   cl, 0a5h
    r.h.cl = 0xa5;

    //     mov   byte ptr [si], cl
    *siPointer = r.h.cl;

    //     push  di
    saveDI = r.w.di;

    //     push  cx
    saveCX = r.w.cx;

    //     not   cx
    r.w.cx = ~r.w.cx;

    //     mov   di, 0000h
    r.w.di = 0x0000;
    ptr.Offset = r.w.di;
    diPointer = ptr.ToPointer<uint8_t>();//No size, we only poke one byte.

    //     mov   ch, byte ptr [di]
    r.h.ch = *diPointer;

    //     mov   byte ptr [di], cl
    *diPointer = r.h.cl;

    //     mov   byte ptr [di], ch
    *diPointer = r.h.ch;

    //     pop   cx
    r.w.cx = saveCX;

    //     pop   di
    r.w.di = saveDI;

    //     cmp   cl, byte ptr [si]
    valNotEqual = r.h.cl != *siPointer;

    //     mov   byte ptr [si], ch
    *siPointer = r.h.ch;

    //     jne   Label0x58fc                   ;Offset 0x58fc
    if (valNotEqual)
        goto Label0x58fc;

    //     add   di, 1000h
    r.w.di += 0x1000;

    //     add   ah, 10h
    r.h.ah += 0x10;

    //     cmp   bx, di
    //     jne   Label0x58d5                   ;Offset 0x58d5
    if (r.w.bx != r.w.di)
        goto Label0x58d5;

    // Label0x58fc:                            ;Offset 0x58fc
LABEL(GetMemorySize, Label0x58fc);

    //     pop   ax
    r.w.ax = saveAX5;

    //     out   dx, ax
    Shared::CRTCExtension::MemoryPage::Write(r.h.ah);

    //     pop   ax
    r.w.ax = saveAX4;

    //     out   dx, ax
    Shared::CRTCExtension::Miscellaneous::Write(r.h.ah);

    //     pop   ax
    r.w.ax = saveAX3;

    //     mov   dl, VGA_GraphicsControllerIndex_lowbyte;Port 0x3ce
    //     out   dx, ax
    VGA::GraphicsController::MemoryMapModeControl::Write(r.h.ah);

    //     pop   ax
    r.w.ax = saveAX2;

    //     mov   dl, VGA_SequenceIndex_lowbyte ;Port 0x3c4
    //     out   dx, ax
    VGA::Sequencer::ClockingMode::Write(r.h.ah);

    //     pop   ax
    r.w.ax = saveAX1;

    //     out   dx, al
    VGA::SequencerIndex::Write(r.h.al);

    //     or    di, di
    //     jne   Label0x5913                   ;Offset 0x5913
    if (r.w.di != 0x0000)
        goto Label0x5913;

    //     mov   di, 0001h
    r.w.di = 0x0001;

    // Label0x5913:                            ;Offset 0x5913
LABEL(GetMemorySize, Label0x5913);
    //     mov   ax, di
    r.w.ax = r.w.di;

    //     pop   si
    //     pop   di
    //     pop   ds
    //     pop   dx
    //     pop   cx
    //     pop   bx
    //     ret
    return r.h.ah;
}

uint8_t GetMemoryExternal()//Offset 0x5855
{
    // push  dx
    // mov   ax, 0bd50h
    // xor   dx, dx
    // int   6dh
    // shl   dx, 0ch
    // mov   di, dx
    // pop   dx
    // or    ah, ah
    // ret
    return 0;
}

uint8_t GetMemoryIn64KBlocks()//Offset 0x5846
{
    //     push  di
    //     call  GetMemoryExternal             ;Offset 0x5855
    //     mov   ax, di
    //     je    Label0x5853                   ;Offset 0x5853
    //     call  GetMemorySize                 ;Offset 0x5866
    // Label0x5853:                            ;Offset 0x5853
    //     pop   di
    return GetMemorySize();
}

uint8_t CapAXTo0x40(uint8_t value)//Offset 0x5832
{
    return value > 0x40 ? 0x40 : value;
    //     cmp   ax, 40h
    //     jbe   IsLess                        ;Offset 0x583b
    //     mov  ah, 40h
    // IsLess:                                 ;Offset 0x583b
    //     cmp  ah, 00h
    //     jne  NotZero                        ;Offset 0x5845
    //     mov  ax, 4000h
    // NotZero:                                ;Offset 0x5845
    //     ret
}

bool ValidateVesaMode(Hag::Vesa::VideoMode_t videoMode)//Offset 0x70cc
{
    using namespace Hag;
    using namespace Hag::System;

    REGPACK r;
    memset(&r, 0, sizeof(r));
    uint16_t saveBX = 0;
    r.w.bx = videoMode;
    uint16_t* siPointer = NULL;
    bool ret = false;

    //     push  ax
    //     push  bx
    //     push  si
    //     push  ds

    //     push  cs
    //     pop   ds

    //     and   bx, 01ffh
    r.w.bx &= Vesa::VideoMode::ModeMask;

    //     mov   si, offset SupportedVESAVideoModes;Offset 0x665d
    siPointer = SupportedVESAVideoModes;

    // Label0x70d9:                            ;Offset 0x70d9
LABEL(ValidateVesaMode, Label0x70d9);

    //     lodsw
    r.w.ax = *siPointer;
    ++siPointer;

    //     cmp   ax, 0ffffh
    //     je    Label0x70e9                   ;Offset 0x70e9
    if (r.w.ax == 0xFFFF)
        goto Label0x70e9;

    //     cmp   bx, ax
    //     je    Label0x7124                   ;Offset 0x7124
    if (r.w.bx == r.w.ax)
        goto Label0x7124;

    //     jmp   Label0x70d9                   ;Offset 0x70d9
    goto Label0x70d9;

    // Label0x70e9:                            ;Offset 0x70e9
LABEL(ValidateVesaMode, Label0x70e9);

    //     lodsw
    r.w.ax = *siPointer;
    ++siPointer;

    //     cmp   ax, 0ffffh
    //     je    Label0x70f9                   ;Offset 0x70f9
    if (r.w.ax == 0xFFFF)
        goto Label0x70f9;

    //     cmp   bx, ax
    //     je    Label0x7124                   ;Offset 0x7124
    if (r.w.bx == r.w.ax)
        goto Label0x7124;

    //     jmp   Label0x70e9                   ;Offset 0x70e9
    goto Label0x70e9;

    // Label0x70f9:                            ;Offset 0x70f9
LABEL(ValidateVesaMode, Label0x70f9);

    //     call  GetMemoryIn64KBlocks          ;Offset 0x5846
    r.h.al = GetMemoryIn64KBlocks();

    //     call  CapAXTo0x40                   ;Offset 0x5832
    r.h.al = CapAXTo0x40(r.h.al);

    //     xchg  al, ah//ignore
    //     cmp   ax, 0020h
    //     jne   Label0x710e                   ;Offset 0x710e
    if (r.w.ax != 0x0020)
        goto Label0x710e;

    //     or    ax, 0001h
    ret = false;

    //     jmp   Label0x7126                   ;Offset 0x7126
    goto Label0x7126;

    //     nop
    // Label0x710e:                            ;Offset 0x710e
LABEL(ValidateVesaMode, Label0x710e);

    //     lodsw
    r.w.ax = *siPointer;

    //     cmp   ax, 0ffffh
    //     je    Label0x711e                   ;Offset 0x711e
    if (r.w.ax == 0xFFFF)
        goto Label0x711e;

    //     cmp   bx, ax
    //     je    Label0x7124                   ;Offset 0x7124
    if (r.w.bx == r.w.ax)
        goto Label0x7124;

    //     jmp   Label0x710e                   ;Offset 0x710e
    goto Label0x710e;

    // Label0x711e:                            ;Offset 0x711e
LABEL(ValidateVesaMode, Label0x711e);

    //     or    ax, 0001h
    ret = false;

    //     jmp   Label0x7126                   ;Offset 0x7126
    goto Label0x7126;

    //     nop
    // Label0x7124:                            ;Offset 0x7124
LABEL(ValidateVesaMode, Label0x7124);

    //     xor   ax, ax
        ret = true;

    // Label0x7126:                            ;Offset 0x7126
LABEL(ValidateVesaMode, Label0x7126);
    //     pop   ds
    //     pop   si
    //     pop   bx
    //     pop   ax
    //     ret
    return ret;
}

//Offset 0x6ae5
uint8_t Data0x6ae5[] =
{
    0x50, 0x0B, 0x08, 0x00, 0x20, 0x01, 0x0F, 0x00, 0x0E, 0x6F, 0x67, 0x4F, 0x4F, 0x0B, 0x53, 0x9F,
    0xC0, 0x1F, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x8D, 0x8F, 0x50, 0x00, 0x8F,
    0xC1, 0xC3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
    0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF
};

//Offset 0x6b25
uint8_t Data0x6b25[] =
{
    0x50, 0x0B, 0x08, 0x00, 0x20, 0x01, 0x0F, 0x00, 0x0E, 0xEF, 0x5F, 0x4F, 0x4F, 0x03, 0x51, 0x9D,
    0x0B, 0x3E, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE9, 0x2B, 0xDF, 0x50, 0x00, 0xDF,
    0x0C, 0xC3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
    0x0D, 0x0E, 0x0F, 0x41, 0x02, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF
};

//Offset 0x6c63
uint8_t Data0x6c63[] =
{
    0x64, 0x24, 0x10, 0x00, 0xF0, 0x01, 0x0F, 0x00, 0x06, 0x2F, 0x7F, 0x63, 0x63, 0x82, 0x6B, 0x1B,
    0x72, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x8C, 0x57, 0x32, 0x00, 0x57,
    0x73, 0xE3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C,
    0x3D, 0x3E, 0x3F, 0x01, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF
};

//Offset 0x6b65
uint8_t Data0x6b65[] =
{
    0x50, 0x0B, 0x08, 0x00, 0x20, 0x01, 0x0F, 0x00, 0x0E, 0x2F, 0x7F, 0x63, 0x63, 0x03, 0x68, 0x18,
    0x72, 0xF0, 0x00, 0x60, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x2C, 0x57, 0x64, 0x00, 0x57,
    0x73, 0xC3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
    0x0D, 0x0E, 0x0F, 0x41, 0x02, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF
};

//Offset 0x6ba5
uint8_t Data0x6ba5[] =
{
    0x50, 0x0B, 0x08, 0x00, 0x20, 0x01, 0x0F, 0x00, 0x0E, 0xEF, 0xA3, 0x7F, 0x7F, 0x07, 0x82, 0x93,
    0x24, 0xF5, 0x00, 0x60, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x28, 0xFF, 0x80, 0x00, 0xFF,
    0x25, 0xC3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
    0x0D, 0x0E, 0x0F, 0x41, 0x02, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF
};

//Offset 0x6be5
uint8_t Data0x6be5[] =
{
    0x50, 0x0B, 0x08, 0x00, 0x20, 0x01, 0x0F, 0x00, 0x0E, 0x2F, 0xCE, 0x9F, 0x9F, 0x12, 0xA5, 0x13,
    0x28, 0x5A, 0x00, 0x60, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0xFF, 0xA0, 0x00, 0xFF,
    0x29, 0xC3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
    0x0D, 0x0E, 0x0F, 0x41, 0x02, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F
};

//Offset 0x6c24
uint8_t Data0x6c24[] =
{
    0x50, 0x0B, 0x08, 0x00, 0x20, 0x01, 0x0F, 0x00, 0x0E, 0x2F, 0x09, 0xC7, 0xC7, 0x0D, 0xCF, 0x07,
    0xE0, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x23, 0xAF, 0xC8, 0x00, 0xAF,
    0xE1, 0xC3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
    0x0D, 0x0E, 0x0F, 0x41, 0x02, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F
};

//Offset 0x6ca3
uint8_t Data0x6ca3[] =
{
    0x50, 0x3B, 0x08, 0x80, 0x25, 0x01, 0x03, 0x00, 0x02, 0xEF, 0x60, 0x4F, 0x50, 0x83, 0x52, 0x9E,
    0x0B, 0x3E, 0x00, 0x47, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x8C, 0xDF, 0x28, 0x1F, 0xE6,
    0x06, 0xA3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C,
    0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF
};

//Offset 0x6ce3
uint8_t Data0x6ce3[] =
{
    0x84, 0x18, 0x10, 0xD0, 0x19, 0x01, 0x03, 0x00, 0x02, 0x6F, 0x9E, 0x83, 0x84, 0x01, 0x87, 0x8D,
    0xC0, 0x1F, 0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x9E, 0x86, 0x8F, 0x42, 0x1F, 0x96,
    0xBB, 0xA3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C,
    0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF
};

//Offset 0x6d23
uint8_t Data0x6d23[] =
{
    0x84, 0x2A, 0x08, 0x58, 0x2C, 0x01, 0x03, 0x00, 0x02, 0x6F, 0x9E, 0x83, 0x84, 0x01, 0x87, 0x8D,
    0x88, 0x1F, 0x00, 0x47, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x66, 0x84, 0x57, 0x42, 0x1F, 0x5E,
    0x83, 0xA3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C,
    0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF
};

//Offset 0x6d63
uint8_t Data0x6d63[] =
{
    0x84, 0x31, 0x08, 0x00, 0x34, 0x01, 0x03, 0x00, 0x02, 0x6F, 0x9E, 0x83, 0x84, 0x01, 0x87, 0x8D,
    0xC0, 0x1F, 0x00, 0x47, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x9E, 0x86, 0x8F, 0x42, 0x1F, 0x96,
    0xBB, 0xA3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C,
    0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF
};

//Offset 0x6da3
uint8_t Data0x6da3[] =
{
    0x84, 0x3B, 0x08, 0x00, 0x3E, 0x01, 0x03, 0x00, 0x02, 0xEF, 0x9E, 0x83, 0x84, 0x01, 0x87, 0x8D,
    0x11, 0x3E, 0x00, 0x47, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x8E, 0xDF, 0x42, 0x1F, 0xE6,
    0x0C, 0xA3, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C,
    0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF
};

struct VesaDataStruct1
{
    uint32_t FrequencyKHz;
    uint16_t Width;
    uint16_t Height;
    uint8_t Data2[4];
    uint8_t* Data3;
    uint8_t Data4[];
};

//Offset 0x6de3      ;VESA_MODE_640x400x256
VesaDataStruct1 Data0x6de3 =
{
    0x00006A86,
    0x0280,
    0x0190,
    { 0x00, 0x01, 0x08, 0x00 },
    Data0x6ae5,
    { 0x00, 0x00, 0x40, 0x00, 0x1C, 0x13, 0x04, 0x00 }
};

//Offset 0x6df9      ;VESA_MODE_640x480x256
VesaDataStruct1 Data0x6df9 =
{
    0x00006257,
    0x0280,
    0x01E0,
    { 0x00, 0x01, 0x08, 0x00 },
    Data0x6b25,
    { 0x00, 0x00, 0x40, 0x00, 0x1C, 0x13, 0x04, 0x2E }
};

//Offset 0x6e0f      ;VESA_MODE_640x480x32K
VesaDataStruct1 Data0x6e0f =
{
    0x00006257,
    0x0280,
    0x01E0,
    { 0x00, 0x01, 0x0F, 0x50 },
    Data0x6b25,
    { 0x00, 0x00, 0x40, 0x00, 0x1C, 0x13, 0x04, 0x2E }
};

//Offset 0x6e25      ;VESA_MODE_640x480x64K
VesaDataStruct1 Data0x6e25 =
{
    0x00006257,
    0x0280,
    0x01E0,
    { 0x00, 0x01, 0x10, 0x10 },
    Data0x6b25,
    { 0x00, 0x00, 0x40, 0x00, 0x1C, 0x13, 0x04, 0x2E }
};

//Offset 0x6e3b      ;VESA_MODE_640x480x16M
VesaDataStruct1 Data0x6e3b =
{
    0x00006257,
    0x0280,
    0x01E0,
    { 0x00, 0x01, 0x20, 0x30 },
    Data0x6b25,
    { 0x00, 0x00, 0x40, 0x00, 0x1C, 0x13, 0x04, 0x2E }
};

//Offset 0x6e51      ;VESA_MODE_800x600x16
VesaDataStruct1 Data0x6e51 =
{
    0x00009C40,
    0x0320,
    0x0258,
    { 0x10, 0x00, 0x01, 0x09 },
    Data0x6c63,
    { 0x00, 0x00, 0x00, 0x00, 0x1B, 0x12, 0x00, 0x00, 0x07, 0x16 }
};

//Offset 0x6e69      ;VESA_MODE_800x600x256
VesaDataStruct1 Data0x6e69 =
{
    0x00009C40,
    0x0320,
    0x0258,
    { 0x00, 0x01, 0x08, 0x00 },
    Data0x6b65,
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x13, 0x07, 0x16 } 
};

//Offset 0x6e7f      ;VESA_MODE_800x600x32K
VesaDataStruct1 Data0x6e7f =
{
    0x00009C40,
    0x0320,
    0x0258,
    { 0xFF, 0x7F, 0x08, 0x50 },
    Data0x6b65,
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6e95      ;VESA_MODE_800x600x64K
VesaDataStruct1 Data0x6e95 =
{
    0x00009C40,
    0x0320,
    0x0258,
    { 0xFF, 0xFF, 0x08, 0x10 },
    Data0x6b65,
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6eab      ;VESA_MODE_800x600x16M
VesaDataStruct1 Data0x6eab =
{
    0x00009C40,
    0x0320,
    0x0258,
    { 0x00, 0x01, 0x08, 0x30 },
    Data0x6b65,
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6ec1      ;VESA_MODE_1024x768x256
VesaDataStruct1 Data0x6ec1 =
{
    0x0000FDE8,
    0x0400,
    0x0300,
    { 0x00, 0x01, 0x08, 0x00 },
    Data0x6ba5,
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6ed7      ;VESA_MODE_1024x768x32K
VesaDataStruct1 Data0x6ed7 =
{
    0x0000FDE8,
    0x0400,
    0x0300,
    { 0xFF, 0x7F, 0x08, 0x50 },
    Data0x6ba5,
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6eed      ;VESA_MODE_1024x768x64K
VesaDataStruct1 Data0x6eed =
{
    0x0000FDE8,
    0x0400,
    0x0300,
    { 0xFF, 0xFF, 0x08, 0x10 },
    Data0x6ba5,
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6f03      ;VESA_MODE_1024x768x16M
VesaDataStruct1 Data0x6f03 =
{
    0x0000FDE8,
    0x0400,
    0x0300,
    { 0x00, 0x01, 0x08, 0x30 },
    Data0x6ba5,
    { 0x00, 0x00, 0x00, 0x00, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6f19      ;VESA_MODE_1280x1024x256
VesaDataStruct1 Data0x6f19 =
{
    0x0001A5E0,
    0x0500,
    0x0400,
    { 0x00, 0x01, 0x08, 0x00 },
    Data0x6be5,
    { 0x00, 0x00, 0x40, 0x21, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6f2f      ;VESA_MODE_1280x1024x32K
VesaDataStruct1 Data0x6f2f =
{
    0x0001A5E0,
    0x0500,
    0x0400,
    { 0xFF, 0x7F, 0x08, 0x50 },
    Data0x6be5,
    { 0x00, 0x00, 0x40, 0x21, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6f45      ;VESA_MODE_1280x1024x64K
VesaDataStruct1 Data0x6f45 =
{
    0x0001A5E0,
    0x0500,
    0x0400,
    { 0xFF, 0xFF, 0x08, 0x10 },
    Data0x6be5,
    { 0x00, 0x00, 0x40, 0x21, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6f5b      ;VESA_MODE_1280x1024x16M
VesaDataStruct1 Data0x6f5b =
{
    0x0001A5E0,
    0x0500,
    0x0400,
    { 0x00, 0x01, 0x08, 0x30 },
    Data0x6be5,
    { 0x00, 0x00, 0x40, 0x21, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6f71      ;VESA_MODE_1600x1200x256
VesaDataStruct1 Data0x6f71 =
{
    0x000278D0,
    0x0640,
    0x04B0,
    { 0x00, 0x01, 0x08, 0x00 },
    Data0x6c24,
    { 0x00, 0x00, 0x01, 0x2D, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6f87      ;VESA_MODE_1600x1200x32K
VesaDataStruct1 Data0x6f87 =
{
    0x000278D0,
    0x0640,
    0x04B0,
    { 0xFF, 0x7F, 0x08, 0x50 },
    Data0x6c24,
    { 0x00, 0x00, 0x01, 0x2D, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6f9d      ;VESA_MODE_1600x1200x64K
VesaDataStruct1 Data0x6f9d =
{
    0x000278D0,
    0x0640,
    0x04B0,
    { 0xFF, 0xFF, 0x08, 0x10 },
    Data0x6c24,
    { 0x00, 0x00, 0x01, 0x2D, 0x1C, 0x13, 0x0C, 0x00 }
};

//Offset 0x6fc9      ;VESA_MODE_80x60xText
VesaDataStruct1 Data0x6fc9 =
{
    0x00006270,
    0x0280,
    0x01E0,
    { 0x10, 0x00, 0x01, 0x82 },
    Data0x6ca3,
    { 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x00 }
};

//Offset 0x6fdf      ;VESA_MODE_132x25xText
VesaDataStruct1 Data0x6fdf =
{
    0x0000A078,
    0x0420,
    0x0190,
    { 0x10, 0x00, 0x01, 0x02 },
    Data0x6ce3,
    { 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x00 }
};

//Offset 0x6ff5      ;VESA_MODE_132x43xText
VesaDataStruct1 Data0x6ff5 =
{
    0x0000A078,
    0x0420,
    0x0158,
    { 0x10, 0x00, 0x01, 0x82 },
    Data0x6d23,
    { 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x00 }
};

//Offset 0x700b      ;VESA_MODE_132x50xText
VesaDataStruct1 Data0x700b =
{
    0x0000A078,
    0x0420,
    0x0190,
    { 0x10, 0x00, 0x01, 0x82 },
    Data0x6d63,
    { 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x00 }
};

//Offset 0x7021      ;VESA_MODE_132x60xText
VesaDataStruct1 Data0x7021 =
{
    0x0000A078,
    0x0420,
    0x01E0,
    { 0x10, 0x00, 0x01, 0x82 },
    Data0x6da3,
    { 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x00 }
};


VesaDataStruct1* Data0x6aa7[] =
{
    &Data0x6de3,   //Offset 0x6de3 VESA_MODE_640x400x256
    &Data0x6df9,   //Offset 0x6df9 VESA_MODE_640x480x256
    &Data0x6e51,   //Offset 0x6e51 VESA_MODE_800x600x16
    &Data0x6e69,   //Offset 0x6e69 VESA_MODE_800x600x256
    NULL,
    &Data0x6ec1,   //Offset 0x6ec1 VESA_MODE_1024x768x256
    NULL,
    &Data0x6f19,   //Offset 0x6f19 VESA_MODE_1280x1024x256
    &Data0x6fc9,   //Offset 0x6fc9 VESA_MODE_80x60xText
    &Data0x6fdf,   //Offset 0x6fdf VESA_MODE_132x25xText
    &Data0x6ff5,   //Offset 0x6ff5 VESA_MODE_132x43xText
    &Data0x700b,   //Offset 0x700b VESA_MODE_132x50xText
    &Data0x7021,   //Offset 0x7021 VESA_MODE_132x60xText
    NULL,
    NULL,
    NULL,
    &Data0x6e0f,   //Offset 0x6e0f VESA_MODE_640x480x32K
    &Data0x6e25,   //Offset 0x6e25 VESA_MODE_640x480x64K
    &Data0x6e3b,   //Offset 0x6e3b VESA_MODE_640x480x16M
    &Data0x6e7f,   //Offset 0x6e7f VESA_MODE_800x600x32K
    &Data0x6e95,   //Offset 0x6e95 VESA_MODE_800x600x64K
    &Data0x6eab,   //Offset 0x6eab VESA_MODE_800x600x16M
    &Data0x6ed7,   //Offset 0x6ed7 VESA_MODE_1024x768x32K
    &Data0x6eed,   //Offset 0x6eed VESA_MODE_1024x768x64K
    &Data0x6f03,   //Offset 0x6f03 VESA_MODE_1024x768x16M
    &Data0x6f2f,   //Offset 0x6f2f VESA_MODE_1280x1024x32K
    &Data0x6f45,   //Offset 0x6f45 VESA_MODE_1280x1024x64K
    &Data0x6f5b,   //Offset 0x6f5b VESA_MODE_1280x1024x16M
    &Data0x6f71,   //Offset 0x6f71 VESA_MODE_1600x1200x256
    &Data0x6f87,   //Offset 0x6f87 VESA_MODE_1600x1200x32K
    &Data0x6f9d,   //Offset 0x6f9d VESA_MODE_1600x1200x64K
};


//
//Calculate the M, N, P and S values for the PLL's given an input frequency in KHz
//
//inputs:
//   eax = requested frequency in KHz
//
//outputs:
//   ebx = M,N,P and S values
//         bl holds N in lower 7 bits
//         bh holds M in lower 5 bits
//         bh holds P in upper 3 bits
//         S 2 bits sit above bh
//         00000000 000000SS PPPMMMMM xNNNNNNN
//
uint32_t CalculatePLL_MNPS(uint32_t frequencyKHz)//Offset 0x5e4b
{
    REGPACK r;
    memset(&r, 0, sizeof(r));
    r.x.eax = frequencyKHz;
    bool notEquals = false;
    uint32_t saveEAX = 0;
    uint32_t saveEBX = 0;
    uint32_t saveEDX = 0;

    //     push   eax
    //     push   ecx
    //     push   edx
    //     push   esi
    //     push   edi

    //     cmp    eax, 00001876h               ;6,262
    //     jge    Label0x5e63                  ;Offset 0x5e63
    if (r.x.eax >= 6262)
        goto Label0x5e63;

    //     mov    eax, 00001876h               ;6,262
    r.x.eax = 6262;

    // Label0x5e63:                            ;Offset 0x5e63
LABEL(CalculatePLL_MNPS, Label0x5e63);

    //     cmp    eax, 000356f0h               ;218,864
    //     jle    Label0x5e71                  ;Offset 0x5e71
    if (r.x.eax <= 218864)
        goto Label0x5e71;

    //     mov    eax, 000356f0h               ;218,864
    r.x.eax = 218864;

    // Label0x5e71:                            ;Offset 0x5e71
LABEL(CalculatePLL_MNPS, Label0x5e71);

    //     mov    esi, eax
    r.x.esi = r.x.eax;

    //     mov    edi, 000356f0h               ;218,864
    r.x.edi = 218864;

    //     mov    edx, 00035b60h               ;220,000
    r.x.edx = 220000;

    //     mov    cl, 64h                      ;100
    r.h.cl = 64;

    //     xor    ebx, ebx
    r.x.ebx = 0;

    // Label0x5e85:                            ;Offset 0x5e85
LABEL(CalculatePLL_MNPS, Label0x5e85);

    //     cmp    cl, 80h                      ;128
    //     je     Label0x5f86                  ;Offset 0x5f86
    if (r.h.cl == 0x80)
        goto Label0x5f86;

    //     mov    ch, 00h
    r.h.ch = 0x00;

    // Label0x5e8e:                            ;Offset 0x5e8e
LABEL(CalculatePLL_MNPS, Label0x5e8e);

    //     cmp    ch, 20h                      ;32
    //     je     Label0x5f81                  ;Offset 0x5f81
    if (r.h.ch == 0x20)
        goto Label0x5f81;

    //     push   ebx
    saveEBX = r.x.ebx;

    //     push   edx
    saveEDX = r.x.edx;

    //     xor    edx, edx
    r.x.edx = 0;

    //     mov    eax, 000037eeh               ;14,318
    r.x.eax = 14318;

    //     xor    ebx, ebx
    r.x.ebx = 0;

    //     mov    bl, cl
    r.h.bl = r.h.cl;

    //     inc    ebx
    ++r.x.ebx;

    //     mul    ebx
    r.x.eax = uint32_t(r.x.eax * r.x.ebx);

    //     xor    ebx, ebx
    r.x.ebx = 0;

    //     mov    bl, ch
    r.h.bl = r.h.ch;

    //     inc    ebx
    ++r.x.ebx;
    //     div    ebx
    r.x.eax /= r.x.ebx;

    //     pop    edx
    r.x.edx = saveEDX;

    //     pop    ebx
    r.x.ebx = saveEBX;

    //     cmp    eax, 0000c350h               ;50,000
    //     jl     Label0x5f7c                  ;Offset 0x5f7c
    if (r.x.eax < 50000)
        goto Label0x5f7c;

    //     cmp    eax, 00035b60h               ;220,000
    //     jg     Label0x5f7c                  ;Offset 0x5f7c
    if (r.x.eax > 220000)
        goto Label0x5f7c;

    //     shl    ecx, 10h
    r.x.ecx <<= 0x10;

    //     mov    cl, 00h
    r.h.cl = 0x00;

    // Label0x5ed4:                            ;Offset 0x5ed4
LABEL(CalculatePLL_MNPS, Label0x5ed4);

    //     cmp    cl, 04h
    //     jne    Label0x5ee0                  ;Offset 0x5ee0
    if (r.h.cl != 0x04)
        goto Label0x5ee0;

    //     shr    ecx, 10h
    r.x.ecx >>= 0x10;

    //     jmp    Label0x5f7c                  ;Offset 0x5f7c
    goto Label0x5f7c;

    // Label0x5ee0:                            ;Offset 0x5ee0
LABEL(CalculatePLL_MNPS, Label0x5ee0);

    //     push   eax
    saveEAX = r.x.eax;

    //     push   ebx
    saveEBX = r.x.ebx;

    //     push   edx
    saveEDX = r.x.edx;

    //     xor    edx, edx
    r.x.edx = 0;

    //     mov    ebx, 00000001h
    r.x.ebx = 1;

    //     shl    ebx, cl
    r.x.ebx <<= r.h.cl;

    //     div    ebx
    r.x.eax /= r.x.ebx;

    //     mov    edx, esi
    r.x.edx = r.x.esi;

    //     cmp    eax, edx
    //     jge    Label0x5eff                  ;Offset 0x5eff
    if (r.x.eax >= r.x.edx)
        goto Label0x5eff;
    //     xchg   eax, edx
    {
        uint32_t tmp = r.x.eax;
        r.x.eax = r.x.edx;
        r.x.edx = tmp;
    }

    // Label0x5eff:                            ;Offset 0x5eff
LABEL(CalculatePLL_MNPS, Label0x5eff);

    //     sub    eax, edx
    r.x.eax -= r.x.edx;

    //     pop    edx
    r.x.edx = saveEDX;

    //     pop    ebx
    r.x.ebx = saveEBX;

    //     cmp    eax, edi
    //     jg     Label0x5f75                  ;Offset 0x5f75
    if (r.x.eax > r.x.edi)
        goto Label0x5f75;

    //     cmp    eax, edi
    notEquals = r.x.eax != r.x.edi;

    //     mov    edi, eax
    r.x.edi = r.x.eax;

    //     jne    Label0x5f1c                  ;Offset 0x5f1c
    if (notEquals)
        goto Label0x5f1c;

    //     pop    eax
    //     push   eax
    r.x.eax = saveEAX;
    
    //     cmp    eax, edx
    //     jge    Label0x5f75                  ;Offset 0x5f75
    if (r.x.eax >= r.x.edx)
        goto Label0x5f75;

    // Label0x5f1c:                            ;Offset 0x5f1c
LABEL(CalculatePLL_MNPS, Label0x5f1c);

    //     pop    eax
    //     push   eax
    r.x.eax = saveEAX;

    //     mov    edx, eax
    r.x.edx = r.x.eax;

    //     xor    ebx, ebx
    r.x.ebx = 0;

    //     mov    eax, ecx
    r.x.eax = r.x.ecx;

    //     shr    eax, 10h
    r.x.eax >>= 1;

    //     mov    bx, ax
    r.w.bx = r.w.ax;

    //     and    bx, 1fffh
    r.w.bx &= 0x1FFF;

    //     mov    ax, 0001h
    r.w.ax = 1;

    //     shl    ax, cl
    r.w.ax <<= r.h.cl;

    //     dec    ax
    --r.w.ax;

    //     shl    ax, 0dh
    r.w.ax <<= 0x0D;

    //     or     bx, ax
    r.w.bx |= r.w.ax;

    //     xor    eax, eax
    r.x.eax = 0;

    //     cmp    edx, 000186a0h               ;100,000
    //     jg     Label0x5f4f                  ;Offset 0x5f4f
    if (r.x.edx > 100000)
        goto Label0x5f4f;

    //     mov    ax, 0000h
    r.w.ax = 0;

    //     jmp    Label0x5f6e                  ;Offset 0x5f6e
    goto Label0x5f6e;

    // Label0x5f4f:                            ;Offset 0x5f4f
LABEL(CalculatePLL_MNPS, Label0x5f4f);

    //     cmp    edx, 000222e0h               ;140,000
    //     jg     Label0x5f5d                  ;Offset 0x5f5d
    if (r.x.edx > 140000)
        goto Label0x5f5d;

    //     mov    ax, 0001h
    r.w.ax = 1;

    //     jmp    Label0x5f6e                  ;Offset 0x5f6e
    goto Label0x5f6e;

    // Label0x5f5d:                            ;Offset 0x5f5d
LABEL(CalculatePLL_MNPS, Label0x5f5d);

    //     cmp    edx, 0002bf20h               ;180,000
    //     jg     Label0x5f6b                  ;Offset 0x5f6b
    if (r.x.edx > 180000)
        goto Label0x5f6b;

    //     mov    ax, 0002h
    r.w.ax = 2;
    //     jmp    Label0x5f6e                  ;Offset 0x5f6e
        goto Label0x5f6e;

    // Label0x5f6b:                            ;Offset 0x5f6b
LABEL(CalculatePLL_MNPS, Label0x5f6b);
    
    //     mov    ax, 0003h
    r.w.ax = 3;

    // Label0x5f6e:                            ;Offset 0x5f6e
LABEL(CalculatePLL_MNPS, Label0x5f6e);

    //     shl    eax, 10h
    r.x.eax <<= 0x10;

    //     or     ebx, eax
    r.x.ebx |= r.x.eax;

    // Label0x5f75:                            ;Offset 0x5f75
LABEL(CalculatePLL_MNPS, Label0x5f75);
    //     pop    eax
    r.x.eax = saveEAX;

    //     inc    cl
    ++r.h.cl;

    //     jmp    Label0x5ed4                  ;Offset 0x5ed4
    goto Label0x5ed4;

    // Label0x5f7c:                            ;Offset 0x5f7c
LABEL(CalculatePLL_MNPS, Label0x5f7c);

    //     inc    ch
    ++r.h.ch;

    //     jmp    Label0x5e8e                  ;Offset 0x5e8e
    goto Label0x5e8e;

    // Label0x5f81:                            ;Offset 0x5f81
LABEL(CalculatePLL_MNPS, Label0x5f81);

    //     inc    cl
    ++r.h.cl;

    //     jmp    Label0x5e85                  ;Offset 0x5e85
    goto Label0x5e85;

    // Label0x5f86:                            ;Offset 0x5f86
LABEL(CalculatePLL_MNPS, Label0x5f86);

    //     pop    edi
    //     pop    esi
    //     pop    edx
    //     pop    ecx
    //     pop    eax
    //     ret

    return r.x.ebx;
}

//
//inputs:
//   ebx = M,N,P and S values
//         bl holds N in lower 7 bits
//         bh holds M in lower 5 bits
//         bh holds P in upper 3 bits
//         S 2 bits sit above bh
//         00000000 000000SS PPPMMMMM xNNNNNNN
//    cl = bits 1-0 = PLL Set A = 0, B = 1, C = 2
//         bits 7-2 = Clock select: 0 = PCI, 1 = PLL, 2 = VDOCLK
//

typedef uint8_t PixelClocksSettings_t;
namespace PixelClocksSettings
{
    enum
    {
        PLLSetA = 0x00,
        PLLSetB = 0x01,
        PLLSetC = 0x02,
        ClockPCI = 0x00,
        ClockPLL = 0x04,
        ClockVDOCLK = 0x08
    };
}

//TODO: Write proper API for this stuff.
void SetupSquareWave()//Offset 0x3230
{
    // push ax
    // mov  al, PIT_MC_OpMode_SquareWaveGenerator OR PIT_MC_AccMode_LoByteHiByte OR PIT_MC_ChanSel_2;0xb6
    // out  PIT_ModeCommand, al            ;Port 0x43
    SYS_WritePortByte(0x43, 0xB6);

    // mov  ax, 04a9h                      ;1193 ticks
    // out  PIT_Channel2Data, al           ;Port 0x42
    SYS_WritePortByte(0x42, 0xA9);

    // mov  al, ah
    // out  PIT_Channel2Data, al           ;Port 0x42
    SYS_WritePortByte(0x42, 0x04);

    // pop  ax
    // ret
}

//
//inputs:
//   al * 8 * 1193 ticks time
//outputs:
//   -
//
//TODO: Write proper API for this stuff.
void Sleep2(uint8_t count)//Offset 0x31f0
{
    printf("Entering Sleep2...\n");
    //     call  SetupSquareWave               ;Offset 0x3230
    SetupSquareWave();

    //     push  ax
    //     push  cx
    //     push  dx
    //     push  ds

    FARPointer sysPointer;
    //     mov   dx, SYS_Segment               ;Segment 0xf000
    sysPointer.Segment = 0xF000;

    //     mov   ds, dx
    //     mov   dx, KB_CommandPort_XT         ;0x62
    uint16_t commandPort = 0x62;

    sysPointer.Offset = 0xfffe;
    //     cmp   byte ptr ds:[SYS_MachineID], SYS_MachineID_IBM_AT;Offset 0xfffe 0xfc
    //     jne   NotAT                         ;Offset 0x3207
    if (*sysPointer.ToPointer<uint8_t>() == 0xFC)
    {
        //     dec   dx
        --commandPort;
    }
    printf("Machine ID = 0x%02X\n", *sysPointer.ToPointer<uint8_t>());
    printf("Command port is 0x%02X\n", commandPort);

    // NotAT:                                  ;Offset 0x3207
    //     pop   ds

    //     mov   cl, al
    //     xor   ch, ch
    //     shl   cx, 01h
    //     shl   cx, 01h
    //     shl   cx, 01h
    count <<= 3;

    //     jcxz  NoSleep                       ;Offset 0x322c
    if (count != 0)
    {
        //     in    al, KB_PortB                  ;Port 0x61
        uint8_t orgValue = SYS_ReadPortByte(0x61);

        //     mov   ah, al                        ;store off original value
        //     or    al, KB_PBW_Timer2GateSpeakerEnable;0x1
        //     out   KB_PortB, al                  ;Port 0x61
        SYS_WritePortByte(0x61, orgValue |= 0x01);

        // WaitTimeExpired:                        ;Offset 0x321c
        do
        {
            do
            {
            //     in    al, dx
            //     and   al, KB_PBR_MirrorTimer2OutputCond;0x20
            //     jne   WaitTimeExpired               ;Offset 0x321c
            } while ((SYS_ReadPortByte(commandPort) & 0x20) != 0);

            // WaitAgain:                              ;Offset 0x3221
            do
            {
            //     in    al, dx
            //     and   al, KB_PBR_MirrorTimer2OutputCond;0x20
            //     je    WaitAgain                     ;Offset 0x3221
            } while ((SYS_ReadPortByte(commandPort) & 0x20) != 0);

            --count;
        } while (count != 0);

        //     loop  WaitTimeExpired               ;Offset 0x321c
        //     mov   al, ah                        ;restore original value
        //     out   KB_PortB, al                  ;Port 0x61
        SYS_WritePortByte(0x61, orgValue);

        // NoSleep:                                ;Offset 0x322c
    }
    //     pop   dx
    //     pop   cx
    //     pop   ax
    //     ret
    printf("Exiting Sleep2...\n");
}

void ConfigurePixelClocks(uint32_t mnps, PixelClocksSettings_t PllAndClock)//Offset 0x6090
{
    using namespace Hag;
    using namespace Hag::System;
    using namespace Hag::Matrox;

    REGPACK r;
    memset(&r, 0, sizeof(r));
    PCI::Device_t mystique = 0;
    uint32_t saveEDX = 0;
    uint16_t saveCX = 0;
    uint16_t saveAX = 0;

    r.x.ebx = mnps;
    r.h.cl = PllAndClock;
    
    //     push   eax
    //     push   ebx
    //     push   ecx
    //     push   edx
    
    //     mov    edx, ebx
    r.x.edx = r.x.ebx;

    //     push   edx
    saveEDX = r.x.edx;

    //     push   cx
    saveCX = r.w.cx;

    //     call   FindMystique                 ;Offset 0x57c6
    PCI::FindDevice(0x102B, 0x051A, mystique);

    //     mov    dx, VGA_SequenceIndex        ;Port 0x3c4
    //     mov    al, VGA_SEQIdx_ClockingMode  ;0x1
    //     out    dx, al
    //     inc    dx
    //     in     al, dx
    //     or     al, VGA_SEQ1_ScreenOff       ;0x20
    //     out    dx, al
    VGA::Sequencer::ClockingMode::Write(
        VGA::Sequencer::ClockingMode::Read() |
        VGA::Sequencer::ClockingMode::ScreenOff);

    //     mov    cl, MGA_INDD_PixelClockControl;0x1a
    //     call   ReadIndexedRegister          ;Offset 0x5bab
    //     or     cl, MGA_PIXCLKCTRL_ClockDisable;0x4
    //     xchg   ch, cl
    //     mov    cl, MGA_INDD_PixelClockControl;0x1a
    //     call   WriteIndexedRegister         ;Offset 0x5b90
    Shared::PCI::Indexed::PixelClockControl::Write(mystique,
        Shared::PCI::Indexed::PixelClockControl::Read(mystique) |
        Shared::Indexed::PixelClockControl::ClockDisable);

    //     pop    cx
    r.w.cx = saveCX;

    //     mov    al, cl
    r.h.al = r.h.cl;

    //     and    al, 03h
    r.h.al &= 0x03; //PLL selection

    //     cmp    al, 00h
    //     jne    Label0x60c8                  ;Offset 0x60c8
    if (r.h.al != 0x00)
        goto Label0x60c8;

    //     mov    al, MGA_INDD_PIXPLL_M_ValueSetA;0x44
    r.h.al = Shared::Indexed::Register::PixelPLLMA;

    //     jmp    Label0x60d2                  ;Offset 0x60d2
    goto Label0x60d2;

    // Label0x60c8:                            ;Offset 0x60c8
LABEL(ConfigurePixelClocks, Label0x60c8);

    //     cmp    al, 01h
    //     jne    Label0x60d0                  ;Offset 0x60d0
    if (r.h.al != 0x01)
        goto Label0x60d0;

    //     mov    al, MGA_INDD_PIXPLL_M_ValueSetB;0x48
    r.h.al = Shared::Indexed::Register::PixelPLLMB;

    //     jmp    Label0x60d2                  ;Offset 0x60d2
    goto Label0x60d2;

    // Label0x60d0:                            ;Offset 0x60d0
LABEL(ConfigurePixelClocks, Label0x60d0);

    //     mov    al, MGA_INDD_PIXPLL_M_ValueSetC;0x4c
    r.h.al = Shared::Indexed::Register::PixelPLLMC;

    // Label0x60d2:                            ;Offset 0x60d2
LABEL(ConfigurePixelClocks, Label0x60d2);

    //     mov    ah, cl
    r.h.ah = r.h.cl;

    //     shr    ah, 02h
    r.h.ah >>= 2;

    //     cmp    ah, 01h
    //     jne    Label0x60e0                  ;Offset 0x60e0
    if (r.h.ah != 0x01)
        goto Label0x60e0;

    //     mov    ah, MGA_PIXCLKCTRL_SelPLL    ;0x01
    r.h.ah = Shared::Indexed::PixelClockControl::ClockPLL;

    //     jmp    Label0x60eb                  ;Offset 0x60eb
    goto Label0x60eb;

    // Label0x60e0:                            ;Offset 0x60e0
LABEL(ConfigurePixelClocks, Label0x60e0);

    //     cmp    ah, 00h
    //     jne    Label0x60e9                  ;Offset 0x60e9
    if (r.h.ah != 0x00)
        goto Label0x60e9;

    //     mov    ah, MGA_PIXCLKCTRL_SelPCI    ;0x0
    r.h.ah = Shared::Indexed::PixelClockControl::ClockPCI;

    //     jmp    Label0x60eb                  ;Offset 0x60eb
    goto Label0x60eb;

    // Label0x60e9:                            ;Offset 0x60e9
LABEL(ConfigurePixelClocks, Label0x60e9);

    //     mov    ah, MGA_PIXCLKCTRL_SelVDOCLK ;0x2
    r.h.ah = Shared::Indexed::PixelClockControl::ClockVDCLK;

    // Label0x60eb:                            ;Offset 0x60eb
LABEL(ConfigurePixelClocks, Label0x60eb);

    //     pop    edx
    r.x.edx = saveEDX;

    //     push   ax
    saveAX = r.w.ax;

    //     mov    ch, dh
    r.h.ch = r.h.dh;

    //     and    ch, MGA_PIXPLL_M_MASK        ;0x1f
    r.h.ch &= Shared::Indexed::PixelPLLM::MValue;

    //     mov    cl, al
    r.h.cl = r.h.al;

    //     call   WriteIndexedRegister         ;Offset 0x5b90
    Shared::PCI::IndexedData::Write(mystique, r.h.cl, r.h.ch);

    //     mov    ch, dl
    r.h.ch = r.h.dl;
    
    //     inc    cl                           ;MGA_INDD_PIXPLL_N_Value
    ++r.h.cl;

    //     call   WriteIndexedRegister         ;Offset 0x5b90
    Shared::PCI::IndexedData::Write(mystique, r.h.cl, r.h.ch);

    //     shr    edx, 0dh
    r.x.edx >>= 0x0D;

    //     mov    ch, dl
    r.h.ch = r.h.dl;

    //     inc    cl                           ;MGA_INDD_PIXPLL_P_Value
    ++r.h.cl;

    //     call   WriteIndexedRegister         ;Offset 0x5b90
    Shared::PCI::IndexedData::Write(mystique, r.h.cl, r.h.ch);

    //     mov    al, 01h
    r.h.al = 0x01;

    //     cli
    SYS_ClearInterrupts();

    //     call   Sleep2                       ;Offset 0x31f0
    Sleep2(r.h.al);

    //     sti
    SYS_RestoreInterrupts();

    //     xor    dx, dx
    r.w.dx = 0;

    printf("Entering PLL frequency lock wait...\n");
    // Label0x6113:                            ;Offset 0x6113
LABEL(ConfigurePixelClocks, Label0x6113);

    //     dec    dx
    --r.w.dx;

    //     je     Label0x6120                  ;Offset 0x6120
    if (r.w.dx == 0x0000)
        goto Label0x6120;

    //     mov    cl, MGA_INDD_PIXPLL_Status   ;0x4f
    //     call   ReadIndexedRegister          ;Offset 0x5bab
    //     and    cl, MGA_PIXPLLSTAT_FrequencyLock;0x40
    //     je     Label0x6113                  ;Offset 0x6113
    if ((Shared::PCI::Indexed::PixelPLLStatus::Read(mystique) &
        Shared::Indexed::PixelPLLStatus::FrequencyStatus) ==
        Shared::Indexed::PixelPLLStatus::FrequencyNotLocked)
        goto Label0x6113;

    // Label0x6120:                            ;Offset 0x6120
LABEL(ConfigurePixelClocks, Label0x6120);

printf("Leaving PLL frequency lock wait...\n");

    //     pop    dx
    r.w.dx = saveAX;

    //     mov    cl, MGA_INDD_PixelClockControl;0x1a
    //     call   ReadIndexedRegister          ;Offset 0x5bab
    //     and    cl, NOT MGA_PIXCLKCTRL_SelMASK;0xfc
    //     or     cl, dh
    //     xchg   cl, ch
    //     mov    cl, MGA_INDD_PixelClockControl;0x1a
    //     call   WriteIndexedRegister         ;Offset 0x5b90
    Shared::PCI::Indexed::PixelClockControl::Write(mystique,
        (Shared::PCI::Indexed::PixelClockControl::Read(mystique) &
         ~Shared::Indexed::PixelClockControl::ClockSelection) |
         r.h.dh);

    //     mov    cl, MGA_INDD_PixelClockControl;0x1a
    //     call   ReadIndexedRegister          ;Offset 0x5bab
    //     and    cl, NOT MGA_PIXCLKCTRL_ClockMASK;0xfb
    //     xchg   ch, cl
    //     mov    cl, MGA_INDD_PixelClockControl;0x1a
    //     call   WriteIndexedRegister         ;Offset 0x5b90
    Shared::PCI::Indexed::PixelClockControl::Write(mystique,
        Shared::PCI::Indexed::PixelClockControl::Read(mystique) &
        ~Shared::Indexed::PixelClockControl::Clock);

    //     cmp    dh, MGA_PIXCLKCTRL_SelPCI    ;0x0
    //     jne    Label0x614a                  ;Offset 0x614a
    if (r.h.dh != Shared::Indexed::PixelClockControl::ClockPCI)
        goto Label0x614a;

    //     mov    bl, VGA_MISC_Clock25p175MHz SHR 2;0x0
    r.h.bl = VGA::MiscellaneousOutput::ClockSelect25p175MHz;

    //     jmp    Label0x6155                  ;Offset 0x6155
    goto Label0x6155;

    // Label0x614a:                            ;Offset 0x614a
LABEL(ConfigurePixelClocks, Label0x614a);

    //     cmp    dh, MGA_PIXCLKCTRL_SelPLL    ;0x1
    //     jne    Label0x6153                  ;Offset 0x6153
    if (r.h.dh != Shared::Indexed::PixelClockControl::ClockPLL)
        goto Label0x6153;

    //     mov    bl, VGA_MISC_Clock28p322MHz SHR 2;0x1
    r.h.bl = VGA::MiscellaneousOutput::ClockSelect28p322MHz;

    //     jmp    Label0x6155                  ;Offset 0x6155
    goto Label0x6155;

    // Label0x6153:                            ;Offset 0x6153
LABEL(ConfigurePixelClocks, Label0x6153);

    //     mov    bl, MGA_MISC_MGAPixelClock SHR 2;0x3
    r.h.bl = Shared::MiscellaneousOutput::ClockSelectMGAPixelClock;

    // Label0x6155:                            ;Offset 0x6155
LABEL(ConfigurePixelClocks, Label0x6155);

    //     mov    dx, VGA_MiscellaneousRead    ;Port 0x3cc
    //     in     al, dx
    //     shl    bl, 02h
    //     and    al, NOT VGA_MISC_ClockSelectMask;0xf3
    //     or     al, bl
    //     mov    dx, VGA_MiscellaneousWrite   ;Port 0x3c2
    //     out    dx, al
    VGA::MiscellaneousOutput::Write((VGA::MiscellaneousOutput::Read() & ~VGA::MiscellaneousOutput::ClockSelect) | r.h.bl);

    //     mov    dx, VGA_SequenceIndex        ;Port 0x3c4
    //     mov    al, VGA_SEQIdx_ClockingMode  ;0x1
    //     out    dx, al
    //     inc    dx
    //     in     al, dx
    //     and    al, NOT VGA_SEQ1_ScreenOff   ;0xdf
    //     out    dx, al
    VGA::Sequencer::ClockingMode::Write(VGA::Sequencer::ClockingMode::Read() & ~VGA::Sequencer::ClockingMode::ScreenOff);

    //     pop    edx
    //     pop    ecx
    //     pop    ebx
    //     pop    eax
    //     ret
}

//inputs:
//   edx = requested frequency in KHz
//
//outputs:
//   -
//
//destroys:
//   -
//

void ConfigureAndSelectPLLSetC(uint32_t frequencyKHz)//Offset 0x6178
{
    // push eax
    // push ebx
    // push ecx
    // mov  cl, MGA_CPC_PLLSetC OR MGA_CPC_ClockPLL;0x6
    // mov  eax, edx
    // call CalculatePLL_MNPS              ;Offset 0x5e4b
    uint32_t mnps = CalculatePLL_MNPS(frequencyKHz);

    // call ConfigurePixelClocks           ;Offset 0x6090
    ConfigurePixelClocks(mnps, PixelClocksSettings::PLLSetC | PixelClocksSettings::ClockPLL);
    // pop  ecx
    // pop  ebx
    // pop  eax
    // ret
}

void Func0x61d7(Hag::System::PCI::Device_t device)//Offset 0x61d7
{
    using namespace Hag;
    using namespace Hag::System;
    using namespace Hag::Matrox;

    REGPACK r;
    memset(&r, 0, sizeof(r));

    //     push dx
    //     push cx

    //     mov  cl, MGA_INDD_MultiplexControl  ;0x19
    //     call ReadIndexedRegister            ;Offset 0x5bab
    //     and  cl, MGA_MULCTRL_DepthMask      ;0x7
    r.h.cl = Shared::PCI::Indexed::MultiplexControl::Read(device) &
             Shared::Indexed::MultiplexControl::ColorDepth;

    //     mov  dx, VGA_DACWriteIndex          ;Port 0x3c8
    //     xor  al, al
    r.h.al = 0;

    //     cmp  cl, MGA_MULCTRL_Depth32Pal     ;0x7
    //     je   Label0x61f2                    ;Offset 0x61f2
    if (r.h.cl == Shared::Indexed::MultiplexControl::Bits24p8x)
        goto Label0x61f2;

    //     cmp  cl, MGA_MULCTRL_Depth16        ;0x2
    //     je   Label0x61fe                    ;Offset 0x61fe
    if (r.h.cl == Shared::Indexed::MultiplexControl::Bits16p)
        goto Label0x61fe;

    //     jmp  Label0x621b                    ;Offset 0x621b
    goto Label0x621b;

    // Label0x61f2:                            ;Offset 0x61f2
LABEL(Func0x61d7, Label0x61f2);

    //     out  dx, al
    VGA::DACWriteIndex::Write(r.h.al);
    
    //     inc  dx
    //     out  dx, al
    VGA::RAMDACData::Write(r.h.al);

    //     out  dx, al
    VGA::RAMDACData::Write(r.h.al);

    //     out  dx, al
    VGA::RAMDACData::Write(r.h.al);

    //     dec  dx
    //     inc  al
    ++r.h.al;

    //     jne  Label0x61f2                    ;Offset 0x61f2
    if (r.h.al != 0x00)
        goto Label0x61f2;

    //     jmp  Label0x622c                    ;Offset 0x622c
    goto Label0x622c;

    // Label0x61fe:                            ;Offset 0x61fe
LABEL(Func0x61d7, Label0x61fe);

    //     out  dx, al
    VGA::DACWriteIndex::Write(r.h.al);

    //     inc  dx
    //     mov  cl, al
    r.h.cl = r.h.al;

    //     shl  al, 03h
    r.h.al <<= 3;

    //     out  dx, al
    VGA::RAMDACData::Write(r.h.al);

    //     mov  al, cl
    r.h.al = r.h.cl;

    //     shl  al, 02h
    r.h.al <<= 2;

    //     out  dx, al
    VGA::RAMDACData::Write(r.h.al);

    //     mov  al, cl
    r.h.al = r.h.cl;

    //     shl  al, 03h
    r.h.al <<= 3;

    //     out  dx, al
    VGA::RAMDACData::Write(r.h.al);

    //     dec  dx
    //     mov  al, cl
    r.h.al = r.h.cl;

    //     inc  al
    ++r.h.al;

    //     jne  Label0x61fe                    ;Offset 0x61fe
    if (r.h.al != 0x00)
        goto Label0x61fe;

    //     jmp  Label0x622c                    ;Offset 0x622c
    goto Label0x622c;

    // Label0x621b:                            ;Offset 0x621b
LABEL(Func0x61d7, Label0x621b);

    //     out  dx, al
    VGA::DACWriteIndex::Write(r.h.al);

    //     inc  dx
    //     mov  cl, al
    r.h.cl = r.h.al;

    //     shl  al, 03h
    r.h.al <<= 3;

    //     out  dx, al
    VGA::RAMDACData::Write(r.h.al);

    //     out  dx, al
    VGA::RAMDACData::Write(r.h.al);
    
    //     out  dx, al
    VGA::RAMDACData::Write(r.h.al);
    
    //     dec  dx
    //     mov  al, cl
    r.h.al = r.h.cl;

    //     inc  al
    ++r.h.al;

    //     jne  Label0x621b                    ;Offset 0x621b
    if (r.h.al != 0x00)
        goto Label0x621b;

    // Label0x622c:                            ;Offset 0x622c
LABEL(Func0x61d7, Label0x622c);

    //     pop  cx
    //     pop  dx
    //     ret
    return;
}

void Func0x622f(uint8_t cl)//Offset 0x622f
{
    using namespace Hag;
    using namespace Hag::System;
    using namespace Hag::Matrox;

    REGPACK r;
    memset(&r, 0, sizeof(r));
    r.h.cl = cl;

    //     push dx
    //     mov  dx, MGA_CRTCExtensionIndex     ;Port 0x3de
    //     xor  ax, ax                         ;MGA_CRTCExt_AddrGeneratorExt
    r.w.ax = 0;

    //     out  dx, al
    //     inc  dx
    //     in   al, dx
    r.h.al = Shared::CRTCExtension::AddressGeneratorExtensions::Read();

    //     shl  ax, 04h
    r.w.ax <<= 4;

    //     mov  dl, VGA_CRTControllerIndexD_lowbyte;Port 0x3d4
    //     mov  al, VGA_CRTCIdx_Offset         ;0x13
    //     out  dx, al
    //     inc  dx
    //     in   al, dx
    r.h.al = VGA::CRTController::ScreenOffset::Read(VGA::Register::CRTControllerIndexD);

    //     or   cl, cl
    //     jne  Label0x624a                    ;Offset 0x624a
    if (r.h.cl != 0x00)
        goto Label0x624a;

    //     shr  ax, 01h
    r.w.ax >>= 1;

    //     jmp  Label0x624c                    ;Offset 0x624c
    goto Label0x624c;

    // Label0x624a:                            ;Offset 0x624a
LABEL(Func0x622f, Label0x624a);

    //     shl  ax, cl
    r.w.ax <<= r.h.cl;

    // Label0x624c:                            ;Offset 0x624c
LABEL(Func0x622f, Label0x624c);

    //     out  dx, al
    VGA::CRTController::ScreenOffset::Write(VGA::Register::CRTControllerIndexD, r.h.al);

    //     mov  dl, MGA_CRTCExtensionData_lowbyte;Port 0x3df
    //     mov  al, ah
    r.h.al = r.h.ah;

    //     shl  al, 04h
    r.h.al <<= 4;
    
    //     out  dx, al
    Shared::CRTCExtension::AddressGeneratorExtensions::Write(r.h.al);

    //     pop  dx
    //     ret
}

void Func0x6310(VesaDataStruct1* siPointer)//Offset 0x6310
{
    using namespace Hag;
    using namespace Hag::System;
    using namespace Hag::Matrox;

    REGPACK r;
    memset(&r, 0, sizeof(r));
    PCI::Device_t mystique = 0;

    //     push ds
    //     push es
    //     push si
    //     push cx
    //     push bx
    //     push dx

    //     xor  ax, ax
    //     mov  es, ax
    //     call GetMemoryIn64KBlocks           ;Offset 0x5846
    r.h.ah = GetMemoryIn64KBlocks();

    //     call CapAXTo0x40                    ;Offset 0x5832
    r.h.ah = CapAXTo0x40(r.h.ah);

    //     mov  byte ptr es:[BDA_VideoBufferSize + 01h], ah;Offset 0x44d
    //     mov  byte ptr es:[BDA_VideoBufferSize], 00h;Offset 0x44c
    BDA::VideoBufferSize::Get() = uint16_t(r.h.ah) << 8;

    //     mov  al, 03h
    //     and  al, byte ptr [si + 0bh]
    //     jne  Label0x6400                    ;Offset 0x6400
    if ((siPointer->Data2[3] & 0x03) != 0x00)
        goto Label0x6400;

    //     call FindMystique                   ;Offset 0x57c6
    PCI::FindDevice(0x102B, 0x051A, mystique);

    //     mov  al, PCI_ACCESS_ReadByte        ;0x8
    //     mov  di, PCI_MGA_Option + 01h       ;0x41
    //     call AccessPCIRegister              ;Offset 0x5734
    //     and  cl, NOT (PCI_MGA_Opt_SplitModeEnable SHR 8);0xdf
    //     mov  al, PCI_ACCESS_WriteByte       ;0xb
    //     call AccessPCIRegister              ;Offset 0x5734
    Shared::PCI::Option::WriteByte1(mystique,
        Shared::PCI::Option::Read(mystique) &
        ~Shared::PCI::Option::SplitMode);

    //     mov  dx, MGA_CRTCExtensionIndex     ;Port 0x3de
    //     mov  ax, MGA_CRTCExt_MemoryPage     ;0x4
    //     out  dx, ax
    Shared::CRTCExtension::MemoryPage::Write(r.h.ah);

    //     test byte ptr [si + 0bh], 10h
    //     je   Label0x63b8                    ;Offset 0x63b8
    if ((siPointer->Data2[3] & 0x10) == 0x00)
        goto Label0x63b8;

    //     test byte ptr [si + 0bh], 20h
    //     je   Label0x6385                    ;Offset 0x6385
    if ((siPointer->Data2[3] & 0x20) == 0x00)
        goto Label0x6385;

    //     mov  byte ptr es:[BDA_VideoBufferSize], 03h;Offset 0x44c
    BDA::VideoBufferSize::Get() = (BDA::VideoBufferSize::Get() & 0xFF00) | 0x03;

    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call ReadIndexedRegister            ;Offset 0x5bab
    //     or   cl, MGA_MISCCTRL_DAC_8Bit      ;0x8
    //     mov  ch, cl
    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::MiscellaneousControl::Write(mystique,
        Shared::PCI::Indexed::MiscellaneousControl::Read(mystique) |
        Shared::Indexed::MiscellaneousControl::VGADAC8Bit);

    //     mov  cl, MGA_INDD_MultiplexControl  ;0x19
    //     mov  ch, MGA_MULCTRL_Depth32Pal     ;0x7
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::MultiplexControl::Write(mystique,
        Shared::Indexed::MultiplexControl::Bits24p8x);

    //     mov  dx, MGA_CRTCExtensionIndex     ;Port 0x3de
    //     mov  ax, ((MGA_CRTCEXT3_MGAModeEnable OR MGA_CRTCEXT3_ScaleDiv4) SHL 8) OR MGA_CRTCExt_Misc;0x8303
    //     out  dx, ax
    Shared::CRTCExtension::Miscellaneous::Write(
        Shared::CRTCExtension::Miscellaneous::ScaleDiv4 |
        Shared::CRTCExtension::Miscellaneous::MGAModeEnable);

    //     call Func0x61d7                     ;Offset 0x61d7
    Func0x61d7(mystique);

    //     mov  cx, 0002h
    r.w.cx = 0x0002;

    //     jmp  Label0x63de                    ;Offset 0x63de
    goto Label0x63de;

    // Label0x6385:                            ;Offset 0x6385
LABEL(Func0x6310, Label0x6385);

    //     mov  byte ptr es:[BDA_VideoBufferSize], 02h;Offset 0x44c
    BDA::VideoBufferSize::Get() = (BDA::VideoBufferSize::Get() & 0xFF00) | 0x02;

    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call ReadIndexedRegister            ;Offset 0x5bab
    //     or   cl, MGA_MISCCTRL_DAC_8Bit      ;0x8
    //     mov  ch, cl
    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::MiscellaneousControl::Write(mystique,
        Shared::PCI::Indexed::MiscellaneousControl::Read(mystique) |
        Shared::Indexed::MiscellaneousControl::VGADAC8Bit);

    //     mov  cl, MGA_INDD_MultiplexControl  ;0x19
    //     mov  ch, 02h                        ;Bits16p
    r.h.ch = Shared::Indexed::MultiplexControl::Bits16p;

    //     test byte ptr [si + 0bh], 40h
    //     je   Label0x63a6                    ;Offset 0x63a6
    if ((siPointer->Data2[3] & 0x40) == 0x00)
    goto Label0x63a6;

    //     mov  ch, 01h                        ;Bits15p
    r.h.ch = Shared::Indexed::MultiplexControl::Bits15p;

    // Label0x63a6:                            ;Offset 0x63a6
LABEL(Func0x6310, Label0x63a6);

    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::MultiplexControl::Write(mystique, r.h.ch);

    //     mov  dx, MGA_CRTCExtensionIndex     ;Port 0x3de
    //     mov  ax, ((MGA_CRTCEXT3_MGAModeEnable OR MGA_CRTCEXT3_ScaleDiv2) SHL 8) OR MGA_CRTCExt_Misc;0x8103
    //     out  dx, ax
    Shared::CRTCExtension::Miscellaneous::Write(
        Shared::CRTCExtension::Miscellaneous::ScaleDiv2 |
        Shared::CRTCExtension::Miscellaneous::MGAModeEnable);

    //     call Func0x61d7                     ;Offset 0x61d7
    Func0x61d7(mystique);
    
    //     mov  cx, 0000h
    r.w.cx = 0;
    
    //     jmp  Label0x63de                    ;Offset 0x63de
    goto Label0x63de;

    // Label0x63b8:                            ;Offset 0x63b8
LABEL(Func0x6310, Label0x63b8);

    //     mov  byte ptr es:[BDA_VideoBufferSize], 01h;Offset 0x44c
    BDA::VideoBufferSize::Get() = (BDA::VideoBufferSize::Get() & 0xFF00) | 0x01;

    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call ReadIndexedRegister            ;Offset 0x5bab
    //     and  cl, NOT MGA_MISCCTRL_DAC_8Bit  ;0xf7
    //     mov  ch, cl
    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::MiscellaneousControl::Write(mystique,
        Shared::PCI::Indexed::MiscellaneousControl::Read(mystique) &
        ~Shared::Indexed::MiscellaneousControl::VGADACBitDepth);

    //     mov  cl, MGA_INDD_MultiplexControl  ;0x19
    //     xor  ch, ch
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::MultiplexControl::Write(mystique,
        Shared::Indexed::MultiplexControl::Bits8p);

    //     mov  dx, MGA_CRTCExtensionIndex     ;Port 0x3de
    //     mov  ax, ((MGA_CRTCEXT3_MGAModeEnable OR MGA_CRTCEXT3_ScaleDiv1) SHL 8) OR MGA_CRTCExt_Misc;0x8003
    //     out  dx, ax
    Shared::CRTCExtension::Miscellaneous::Write(
        Shared::CRTCExtension::Miscellaneous::ScaleDiv1 |
        Shared::CRTCExtension::Miscellaneous::MGAModeEnable);

    //     mov  cx, 0001h
    r.w.cx = 0x0001;

    // Label0x63de:                            ;Offset 0x63de
LABEL(Func0x6310, Label0x63de);

    //     push cx
    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call ReadIndexedRegister            ;Offset 0x5bab
    //     or   cl, MGA_MISCCTRL_MAFC_Disable  ;0x6
    //     mov  ch, cl
    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call WriteIndexedRegister           ;Offset 0x5b90
    //     pop  cx
    Shared::PCI::Indexed::MiscellaneousControl::Write(mystique,
        Shared::PCI::Indexed::MiscellaneousControl::Read(mystique) |
        Shared::Indexed::MiscellaneousControl::MAFCDisable);

    //     mov  ax, (MGA_CRTCExt_HorVidHalfCount SHL 8) OR 01h;0x501
    //     call MGAWriteCRTCExtensionRegister  ;Offset 0x3c4
    Shared::CRTCExtension::HorizontalHalfCount::Write(0x01);

    //     or   cl, cl
    //     je   Label0x640f                    ;Offset 0x640f
    if (r.h.cl == 0x00)
        goto Label0x640f;

    //     dec  cl
    --r.h.cl;

    //     call Func0x622f                     ;Offset 0x622f
    Func0x622f(r.h.cl);

    //     jmp  Label0x640f                    ;Offset 0x640f
    goto Label0x640f;

    // Label0x6400:                            ;Offset 0x6400
LABEL(Func0x6310, Label0x6400);

    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call ReadIndexedRegister            ;Offset 0x5bab
    //     and  cl, NOT MGA_MISCCTRL_MAFC_MASK;0xf9
    //     mov  ch, cl
    //     mov  cl, MGA_INDD_MiscellaneousControl;0x1e
    //     call WriteIndexedRegister           ;Offset 0x5b90
    Shared::PCI::Indexed::MiscellaneousControl::Write(mystique,
        Shared::PCI::Indexed::MiscellaneousControl::Read(mystique) &
        ~Shared::Indexed::MiscellaneousControl::MAFCFuncSelect);

    // Label0x640f:                            ;Offset 0x640f
LABEL(Func0x6310, Label0x640f);

    //     pop  dx
    //     pop  bx
    //     pop  cx
    //     pop  si
    //     pop  es
    //     pop  ds
    //     ret
    return;
}

uint16_t GetVideoMemorySize()//Offset 0x59c0
{
    uint16_t ret = 0;
    //     push  ds
    //     xor   ax, ax
    //     mov   ds, ax
    //     mov   ax, 01h
    ret = 1;
    //     cmp   byte ptr ds:[BDA_DisplayMode], BDA_DM_320x200_256_Color_Graphics;Offset 0x449 0x13
    //     je    IsMode13                      ;Offset 0x59d2
    if (Hag::System::BDA::DisplayMode::Get() != Hag::VGA::VideoMode::G320x200x8bppC)
        ret = Hag::System::BDA::VideoBufferSize::Get();
    //     mov   ax, word ptr ds:[BDA_VideoBufferSize];Offset 0x44c
    // IsMode13:                               ;Offset 0x59d2
    //     and   al, 0fh
    ret &= 0xFF0F;
    //     pop   ds
    //     ret
    return ret;
}

void ClearVideoMemory()//Offset 0x64e6
{
    using namespace Hag::Matrox;

    //     push      es
    //     push      di
    //     push      dx
    //     push      ecx

    //     mov       ax, 0a000h                ;Segment 0xa000
    FARPointer ptr;
    ptr.Segment = 0xA000;
    
    //     mov       es, ax
    //     mov       dx, MGA_CRTCExtensionIndex;Port 0x3de
    //     call      GetVideoMemorySize                ;Offset 0x59c0
    uint8_t ah = uint8_t(GetVideoMemorySize() >> 8);

    //     mov       al, 04h                   ;MemoryPage
    // Label0x64f8:                            ;Offset 0x64f8
LABEL(ClearVideoMemory, Label0x64f8);

    //     dec       ah
    --ah;
    
    //     jb        Label0x6512               ;Offset 0x6512
    if (ah == 0xFF)
        goto Label0x6512;

    //     out       dx, ax
    Shared::CRTCExtension::MemoryPage::Write(ah);

    //     push      ax
    //     xor       eax, eax
    //     mov       di, 0000h
    ptr.Offset = 0x0000;
    
    //     mov       ecx, 00004000h
    //     rep stosd
    memset(ptr.ToPointer<uint8_t>(0x10000), 0, 0x10000);

    //     pop       ax
    //     or        ah, ah
    //     jne       Label0x64f8               ;Offset 0x64f8
    if (ah != 0x00)
        goto Label0x64f8;

    // Label0x6512:                            ;Offset 0x6512
LABEL(ClearVideoMemory, Label0x6512);

    //     pop       ecx
    //     pop       dx
    //     pop       di
    //     pop       es
    //     ret
}

void TextFunctions0X(uint8_t function, uint16_t bx)//Offset 0x2612
{
    //     cmp       al, 03h
    //     je        SelectCharacterMap        ;Offset 0x262a
    if (function == 0x03)
    {
        // SelectCharacterMap:                     ;Offset 0x262a
        //     mov       dx, VGA_SequenceIndex     ;Port 0x3c4
        //     mov       al, VGA_SEQIdx_CharacterMapSelect;0x3
        //     mov       ah, bl
        //     out       dx, ax
        Hag::VGA::Sequencer::CharacterFontSelect::Write(uint8_t(bx));
    }
    //     cmp       al, 04h
    //     ja        Return                    ;Offset 0x2632
    else if (function < 0x04)
    {
        //     and       bl, 7fh
        bx &= 0xFF7F;
        
        //     call      Func0x2ce3                ;Offset 0x2ce3
        ConfigureFontLoadMemoryMapping();

        //     call      Func0x2d24                ;Offset 0x2d24
        Func0x2d24(function, bx, NULL, 0x0000);

        //     call      Func0x2ce9                ;Offset 0x2ce9
        ConfigureTextMemoryMapping();

        //     call      Func0x30c9                ;Offset 0x30c9
        ActivateAttributeController();

        //     ret
    }
    // Return:                                 ;Offset 0x2632
    //     ret
}

void SetStartAddress(uint32_t address)//Offset 0x5a28
{
    //     push  dx
    //     push  ds
    //     xor   dx, dx
    //     mov   ds, dx
    //     call  Func0x6416                    ;Offset 0x6416
    //     je    Label0x5a36                   ;Offset 0x5a36
    //     shr   eax, 01h
    // Label0x5a36:                            ;Offset 0x5a36
    //     pop   ds
    //     push  eax
    //     test  bl, 80h
    //     je    Label0x5a48                   ;Offset 0x5a48
    //     mov   dx, VGA_InputStatus1D         ;Port 0x3da
    // Label0x5a43:                            ;Offset 0x5a43
    //     in    al, dx
    //     and   al, VGA_INSTS1_VerInactiveDisplayIntv;0x8
    //     je    Label0x5a43                   ;Offset 0x5a43
    // Label0x5a48:                            ;Offset 0x5a48
    //     mov   dx, VGA_CRTControllerIndexD   ;Port 0x3d4
    //     mov   al, VGA_CRTCIdx_StartAddrLow  ;0xd
    //     out   dx, al
    //     inc   dx
    //     pop   ax
    //     out   dx, al
    //     dec   dx
    //     mov   al, VGA_CRTCIdx_StartAddrHigh ;0xc
    //     out   dx, al
    //     inc   dx
    //     xchg  al, ah
    //     out   dx, al
    //     mov   dl, MGA_CRTCExtensionIndex_lowbyte;Port 0x3de
    //     xor   al, al                        ;MGA_CRTCExt_AddrGeneratorExt
    //     out   dx, al
    //     inc   dx
    //     pop   ax
    //     xchg  al, ah
    //     in    al, dx
    //     and   al, NOT MGA_CRTEXT0_StartAddress19_16;0xf0
    //     or    al, ah
    //     out   dx, al
    //     pop   dx
    //     ret
}

bool SetVideoModeInternal(Hag::VGA::VideoMode_t videoMode, Hag::System::BDA::VideoParameterTable* videoParameterTableOverride);

void Func0x6518(VesaDataStruct1* vesaStruct)//Offset 0x6518
{
    using namespace Hag;
    using namespace Hag::System;
    using namespace Hag::Matrox;

    REGPACK r;
    memset(&r, 0, sizeof(r));
    VesaDataStruct1* siPointer = NULL;
    uint8_t* axPointer = NULL;

    //     push      bp
    //     mov       bp, sp
    //     push      es
    //     push      ebx
    //     sub       sp, 002ch

    //     push      ss
    //     pop       es
    //     mov       di, sp
    //     mov       bx, ax
    //     shl       ebx, 01h
    //     xor       dx, dx
    //     mov       ds, dx
    //     lds       si, ds:[BDA_VideoParameterControlBlockPtrOfs];Offset 0x4a8
    //     push      ds
    //     push      si
    //     push      di
    //     mov       cx, 000eh
    //     rep movsw

    //     pop       di
    //     lds       si, [bp + 04h]
    siPointer = vesaStruct;

    //     push      ax
    //     push      dx
    //     mov       dx, MGA_CRTCExtensionIndex;Port 0x3de
    //     mov       al, MGA_CRTCExt_HorCounterExt;0x1
    //     out       dx, al
    //     inc       dx
    //     in        al, dx
    //     or        al, MGA_CRTCEXT1_VerSyncOff OR MGA_CRTCEXT1_HorSyncOff;0x30
    //     out       dx, al
    //     pop       dx
    //     pop       ax
    Shared::CRTCExtension::HorizontalCounterExtensions::Write(
        Shared::CRTCExtension::HorizontalCounterExtensions::Read() |
        Shared::CRTCExtension::HorizontalCounterExtensions::VerticalSyncOff |
        Shared::CRTCExtension::HorizontalCounterExtensions::HorizontalSyncOff);
    
    //     mov       dx, VGA_MiscellaneousWrite
    //     mov       al, NOT VGA_MISC_VideoDisable;0xef
    //     out       dx, al
    VGA::MiscellaneousOutput::Write(~VGA::MiscellaneousOutput::VideoEnable);

    //     mov       edx, dword ptr [si]
    r.x.edx = siPointer->FrequencyKHz;
    
    //     mov       cl, 2dh
    r.h.cl = 0x2D;  //Does nothing. stomped in function

    //     call      ConfigureAndSelectPLLSetC ;Offset 0x6178
    ConfigureAndSelectPLLSetC(r.x.edx);

    //     xor       dx, dx
    r.w.dx = 0;

    //     xor       eax, eax
    r.x.eax = 0;

    //     mov       ax, word ptr [si + 0ch]
    axPointer = siPointer->Data3;

    //     mov       bx, ds                    ;bx = 0xC000
    //     mov       cx, bx
    //     or        cx, ax
    //     je        Label0x6589               ;Offset 0x6589
    //     push      ax
    //     mov       cx, 0004h
    //     shr       ax, cl
    //     add       bx, ax
    //     mov       al, byte ptr [si + 12h]
    //     xor       ah, ah
    //     shl       ax, 01h
    //     shl       ax, 01h
    //     sub       bx, ax
    //     pop       ax
    //     and       ax, 000fh
    //     mov       word ptr es:[di], ax      ;VideoParameters
    //     mov       word ptr es:[di + 02h], bx;
    // Label0x6589:                            ;Offset 0x6589
    //     mov       word ptr es:[di + 08h], dx;0 AlphanumericCharsetOverride
    //     mov       word ptr es:[di + 0ah], dx;0
    //     shr       ebx, 01h
    //     and       bh, 80h
    //     mov       dl, byte ptr [si + 13h]
    //     or        dl, bh
    //     shl       ebx, 01h
    //     xor       ax, ax
    //     mov       ds, ax
    //     mov       word ptr ds:[BDA_VideoParameterControlBlockPtrOfs], di;Offset 0x4a8
    //     mov       word ptr ds:[BDA_VideoParameterControlBlockPtrSeg], es;Offset 0x4aa

    //All this chaos above is just to get the standard video mode code to apply our legacy mode settings

    //     mov       ax, dx
    //     int       6dh
    SetVideoModeInternal(VGA::VideoMode::T40x25x4bppG, (BDA::VideoParameterTable*)axPointer);

    //     call      TurnScreenOff             ;Offset 0x3109
    TurnScreenOff();

    //     pop       word ptr ds:[BDA_VideoParameterControlBlockPtrOfs];Offset 0x4a8
    //     pop       word ptr ds:[BDA_VideoParameterControlBlockPtrSeg];Offset 0x4aa

    //     lds       si, [bp + 04h]


//Offset 0x7021      ;VESA_MODE_132x60xText
// VesaDataStruct1 Data0x7021 =
// {
//     0x0000A078,                  // 00
//     0x0420,                      // 04
//     0x01E0,                      // 06
//     { 0x10, 0x00, 0x01, 0x82 },  // 08
//     Data0x6da3,                  // 0C
//     { 
//0x00,                             // 0E 0
//0x00,                             // 0F 1
//0x00,                             // 10 2 Shared::CRTCExtension::HorizontalCounterExtensions
//0x00,                             // 11 3 Shared::CRTCExtension::VerticalCounterExtensions
//0x18,                             // 12 4
//0x03,                             // 13 5
//0x00,                             // 14 6
//0x00 }                            // 15 7
// };

// struct VesaDataStruct1
// {
//     uint32_t FrequencyKHz;
//     uint16_t Width;
//     uint16_t Height;
//     uint8_t Data2[4];
//     uint8_t* Data3;
//     uint8_t Data4[];
// };


    //     test      byte ptr [si + 0bh], 80h
    //     je        Label0x65cf               ;Offset 0x65cf
    if ((siPointer->Data2[3] & 0x80) == 0x00)
        goto Label0x65cf;

    //     push      si
    //     push      ds
    //     mov       al, 02h
    r.h.al = 0x02;

    //     mov       bx, 0000h
    r.w.bx = 0x0000;

    //     call      TextFunctions             ;Offset 0x25e5
    TextFunctions0X(r.h.al, r.w.bx);

    //     pop       ds
    //     pop       si

    // Label0x65cf:                            ;Offset 0x65cf
LABEL(Func0x6518, Label0x65cf);

    //     mov       dx, MGA_CRTCExtensionIndex;Port 0x3de
    //     mov       ah, byte ptr [si + 10h]
    //     mov       al, MGA_CRTCExt_HorCounterExt;0x1
    //     out       dx, ax
    Shared::CRTCExtension::HorizontalCounterExtensions::Write(siPointer->Data4[2]);

    //     mov       ah, byte ptr [si + 11h]
    //     mov       al, MGA_CRTCExt_VertCounterExt;0x2
    //     out       dx, ax
    Shared::CRTCExtension::VerticalCounterExtensions::Write(siPointer->Data4[3]);

    //     call      Func0x6310                ;Offset 0x6310
    Func0x6310(siPointer);

    //     shr       ebx, 01h
    r.x.ebx >>= 1;

    //     and       bh, 80h
    r.h.bh &= 0x80;

    //     jne       Label0x65f2               ;Offset 0x65f2
    if (r.h.bh != 0x00)
    goto Label0x65f2;

    //     test      byte ptr [si + 0bh], 02h
    //     jne       Label0x65f2               ;Offset 0x65f2
    if ((siPointer->Data2[3] & 0x2) != 0)
        goto Label0x65f2;

    //     call      ClearVideoMemory                ;Offset 0x64e6
    ClearVideoMemory();

    // Label0x65f2:                            ;Offset 0x65f2
LABEL(Func0x6518, Label0x65f2);

    //     xor       eax, eax
    r.x.eax = 0;
    //     call      SetStartAddress           ;Offset 0x5a28
    SetStartAddress(r.x.eax);

    //     call      TurnScreenOn              ;Offset 0x3105
    TurnScreenOn();

    //     add       sp, 002ch
    //     xor       ax, ax
    //     pop       ebx
    //     pop       es
    //     pop       bp
    //     ret
}

bool SetVideoMode(Hag::VGA::VideoMode_t videoMode);

bool SetVESAMode(Hag::Vesa::VideoMode_t videoMode)//Offset 0x7356
{
    using namespace Hag;
    using namespace Hag::System;

    bool ret = false;

    REGPACK r;
    memset(&r, 0, sizeof(r));
    uint16_t saveBX = 0;
    r.w.ax = videoMode;
    VesaDataStruct1* siStruct = NULL;

    //     push  ax
    //     push  ds
    //     push  di
    //     push  si
    //     push  cx
    //     push  dx
    //     push  cs
    //     pop   ds
    //     mov   bx, ax
    r.w.bx = r.w.ax;

    //     call  IsExtensionReg7Writeable      ;Offset 0x5606
    //     je    Label0x73e1                   ;Offset 0x73e1
    if (IsExtensionReg7Writeable())
        goto Label0x73e1;
    
    //     push  bx
    saveBX = r.w.bx;
    //     call  TranslateSpecialModes                    ;Offset 0x70a8
    r.w.bx = TranslateSpecialModes(r.w.bx);

    //     mov   ax, bx
    r.w.ax = r.w.bx;

    //     cmp   bl, 1fh                       ;Full memory access mode
    //     jne   Label0x7375                   ;Offset 0x7375
    if (r.h.bl != 0x1F)
        goto Label0x7375;
        
    //     mov   bx, VESA_MODE_640x400x256     ;0x100
        r.w.bx = Hag::Vesa::VideoMode::G640x400x8bpp;

    // Label0x7375:                            ;Offset 0x7375
LABEL(SetVESAMode, Label0x7375);

    //     call  ValidateVesaMode                    ;Offset 0x70cc
    //     jne   Label0x73a4                   ;Offset 0x73a4
    if (!ValidateVesaMode(r.w.bx))
        goto Label0x73a4;

    //     and   bx, 00ffh
    r.w.bx &= 0xFF;
    
    //     shl   bx, 01h
    //     add   bx, Data0x6aa7                ;Offset 0x6aa7
    //     mov   si, word ptr cs:[bx]
    siStruct = Data0x6aa7[r.w.bx];

    //     push  ax
    //     mov   ax, 0bd60h
    //     int   6dh
    //     pop   ax
    //Ignore.

    //     push  ds
    //     push  si
    //     call  Func0x6518                    ;Offset 0x6518
    Func0x6518(siStruct);

    //     pop   ax
    //     pop   ax

    //     pop   bx
    r.w.bx = saveBX;

    //     cmp   bl, 1fh
    //     jne   Label0x73a2                   ;Offset 0x73a2
    if (r.h.bl != 0x1F)
        goto Label0x73a2;

    //     mov   dx, VGA_SequenceIndex         ;Port 0x3c4
    //     mov   ax, (VGA_SEQ1_ScreenOff SHL 8) OR VGA_SEQIdx_ClockingMode;0x2001
    //     out   dx, ax
    VGA::Sequencer::ClockingMode::Write(VGA::Sequencer::ClockingMode::ScreenOff);

    // Label0x73a2:                            ;Offset 0x73a2
LABEL(SetVESAMode, Label0x73a2);

    //     jmp   Label0x73bf                   ;Offset 0x73bf
    goto Label0x73bf;

    // Label0x73a4:                            ;Offset 0x73a4
LABEL(SetVESAMode, Label0x73a4);

    //     pop   bx
    r.w.bx = saveBX;

    //     mov   ax, bx
    r.w.ax = r.w.bx;

    //     cmp   ax, BDA_DM_320x200_256_Color_Graphics;0x13
    //     jle   Label0x73b1                   ;Offset 0x73b1
    if (r.w.ax <= VGA::VideoMode::G320x200x8bppC)
        goto Label0x73b1;

    //     mov   ax, 014fh
    ret = false;

    //     jmp   Label0x73e1                   ;Offset 0x73e1
    goto Label0x73e1;

    // Label0x73b1:                            ;Offset 0x73b1
LABEL(SetVESAMode, Label0x73b1);

    //     mov   ah, 00h
    r.h.ah = 0x00;

    //     mov   al, bl
    r.h.al = r.h.bl;

    //     int   10h                           ;Regular int 10h handler for standard modes
    //     inc   ax
    //     jne   Label0x73bf                   ;Offset 0x73bf
    if (!SetVideoMode(r.h.al))
        goto Label0x73bf;

    //     mov   ax, 014fh
    ret = false;

    //     jmp   Label0x73e1                   ;Offset 0x73e1
    goto Label0x73e1;

    // Label0x73bf:                            ;Offset 0x73bf
LABEL(SetVESAMode, Label0x73bf);
    //     push  bx
    saveBX = r.w.bx;

    //     and   bx, 7f7fh
    r.w.bx &= 0x7F7F;
    //     cmp   bx, VESA_MODE_640x400x256     ;0x100
    //     jl    Label0x73cd                   ;Offset 0x73cd
    if (r.w.bx < Vesa::VideoMode::G640x400x8bpp)
        goto    Label0x73cd;
    
    //     add   bl, 20h                       ;VESA mode is (mode & 0x7f) + 0x20
    r.h.bl += 0x20;

    // Label0x73cd:                            ;Offset 0x73cd
LABEL(SetVESAMode, Label0x73cd);

    //     xor   ax, ax
    r.w.ax = 0;

    //     mov   ds, ax
    //     mov   al, bl
    r.h.al = r.h.al;

    //     pop   bx
    r.w.bx = saveBX;

    //     mov   ah, bh
    r.h.ah = r.h.bh;

    //     and   ah, 0c0h                      ;Top 2 bits are preserved
    r.h.ah &= 0xC0;

    //     or    al, ah                        ;And stored along with the mode
    r.h.al |= r.h.ah;

    //     mov   byte ptr ds:[BDA_DisplayMode], al;Offset 0x449
    BDA::DisplayMode::Get() = r.h.al;

    //     mov   ax, 004fh
    ret = true;

    // Label0x73e1:                            ;Offset 0x73e1
LABEL(SetVESAMode, Label0x73e1);
    //     pop   dx
    //     pop   cx
    //     pop   si
    //     pop   di
    //     pop   ds
    //     pop   bx
    //     or    ah, ah
    //     jne   Label0x73eb                   ;Offset 0x73eb   If not, then still.
    // Label0x73eb:                            ;Offset 0x73eb
    //     iret

    return ret;
}

bool SetVideoModeInternal(Hag::VGA::VideoMode_t videoMode, Hag::System::BDA::VideoParameterTable* videoParameterTableOverride)
{
    using namespace Hag;
    using namespace Hag::System;

    REGPACK r;
    memset(&r, 0, sizeof(r));
    uint16_t saveAX = 0;
    r.h.al = videoMode;

    //     push ax
    //     mov  ah, al
    r.h.ah = r.h.al;

    //     mov  al, byte ptr ds:[BDA_VideoDisplayDataArea];Offset 0x489
    r.h.al = BDA::VideoDisplayDataArea::Get();

    //     and  al, BDA_VDDA_Reserved          ;0x20
    r.h.al &= BDA::VideoDisplayDataArea::Reserved;

    //     je   Label0x12fd                    ;Offset 0x12fd
    if (r.h.al == 0)
        goto Label0x12fd;

    //     or   ah, BDA_DM_DONT_CLEAR_SCREEN   ;0x80
    r.h.ah |= VGA::VideoMode::DontClearDisplay;

    // Label0x12fd:                            ;Offset 0x12fd
LABEL(SetVideoMode, Label0x12fd);

    //     mov  al, byte ptr ds:[BDA_VideoModeOptions];Offset 0x487
    r.h.al = BDA::VideoModeOptions::Get();

    //     shl  ax, 01h                        ;Don't clear screen bit is now in carry flag
    //     xchg al, ah                         ;al = mode, ah = video mode options
    //     rcr  ax, 01h                        ;al no longer has clear screen bit, ah dont clear screen bit replaced.
    r.h.al &= ~BDA::VideoModeOptions::DontClearDisplay;
    r.h.al |= r.h.ah & BDA::VideoModeOptions::DontClearDisplay;
    r.h.ah &= ~BDA::VideoModeOptions::DontClearDisplay;
    {
        uint8_t x = r.h.al;
        r.h.al = r.h.ah;
        r.h.ah = x;
    }

    //     cmp  al, BDA_DM_320x200_256_Color_Graphics;0x13
    //     ja   Label0x136a                    ;Offset 0x136a
    if (r.h.al > VGA::VideoMode::G320x200x8bppC)
        goto Label0x136a;

    //     push ax
    saveAX = r.w.ax;

    //     cmp  al, BDA_DM_80x25_Monochrome_Text;0x7
    //     je   Label0x131c                    ;Offset 0x131c
    if (r.h.al == VGA::VideoMode::T80x25x1bppM)
        goto Label0x131c;

    //     cmp  al, BDA_DM_640x350_Monochrome_Graphics;0xf
    //     je   Label0x131c                    ;Offset 0x131c
    if (r.h.al == VGA::VideoMode::G640x350x1bppM)
        goto Label0x131c;

    //     mov  al, byte ptr ds:[BDA_DetectedHardware];Offset 0x410
    r.h.al = BDA::DetectedHardware::Get();

    //     and  al, NOT BDA_DH_InitialVideoModeMask;0xcf
    r.h.al &= ~BDA::DetectedHardware::InitialVideoModeMask;

    //     or   al, BDA_DH_80x25Color          ;0x20
    r.h.al |= BDA::DetectedHardware::Color80x25;

    //     jmp  Label0x1323                    ;Offset 0x1323
    goto Label0x1323;

    // Label0x131c:                            ;Offset 0x131c
LABEL(SetVideoMode, Label0x131c);

    //     mov  al, byte ptr ds:[BDA_DetectedHardware];Offset 0x410
    r.h.al = BDA::DetectedHardware::Get();

    //     and  al, NOT BDA_DH_InitialVideoModeMask;0xcf
    r.h.al &= ~BDA::DetectedHardware::InitialVideoModeMask;

    //     or   al, BDA_DH_80x25Monochrome     ;0x30
    r.h.al |= BDA::DetectedHardware::Monochrome80x25;

    // Label0x1323:                            ;Offset 0x1323
LABEL(SetVideoMode, Label0x1323);

    //     mov  byte ptr ds:[BDA_DetectedHardware], al;Offset 0x410
    BDA::DetectedHardware::Get() = r.h.al;

    //     pop  ax
    r.w.ax = saveAX;

    //     call ConfigureEGAFeatureBitSwitchesAdapter                     ;Offset 0x149c
    ConfigureEGAFeatureBitSwitchesAdapter(r.h.al, r.h.ah);

    //Don't set this pointer.
    //     mov  word ptr ds:[INT_43_HandlerOfs], offset Font8x8;Offset 0x10c Offset 0x3720
    //     mov  word ptr ds:[INT_43_HandlerSeg], cs;Offset 0x10e

    //     and  ah, 0f3h
    r.h.ah &= 0xF3;

    //     test byte ptr ds:[BDA_DetectedHardware], BDA_DH_InitialVideoModeMask;Offset 0x410 0x30
    //     je   Label0x1340                    ;Offset 0x1340
    if ((BDA::DetectedHardware::Get() & BDA::DetectedHardware::InitialVideoModeMask) == 0)
        goto Label0x1340;

    //     jp   Func0x13ba                     ;Offset 0x13ba
    if ((BDA::DetectedHardware::Get() & BDA::DetectedHardware::InitialVideoModeMask) == BDA::DetectedHardware::Monochrome80x25)
    {
        Func0x13ba(r.h.al, r.h.ah, videoParameterTableOverride);
        RETURN_ARG("SetVideoMode.Return 1", true);
    }
    // Label0x1340:                            ;Offset 0x1340
LABEL(SetVideoMode, Label0x1340);

    //     test ah, 02h
    //     jne  Label0x1354                    ;Offset 0x1354
    if ((r.h.ah & 0x02) != 0)
        goto Label0x1354;
    //     mov  si, 3d4h
    r.w.si = 0x3D4;

    //     cmp  al, 07h
    //     je   Label0x1350                    ;Offset 0x1350
    if (r.h.al == 0x07)
        goto Label0x1350;

    //     cmp  al, 0fh
    //     jne  Func0x13cf                     ;Offset 0x13cf
    if (r.h.al != 0x0F)
    {
        Func0x13cf(r.h.al, r.h.ah, r.w.si, videoParameterTableOverride);
        RETURN_ARG("SetVideoMode.Return 2", true);
    }
    // Label0x1350:                            ;Offset 0x1350
LABEL(SetVideoMode, Label0x1350);

    //     mov  al, 03h
    r.h.al = 0x03;

    //     jmp  Func0x13cc                     ;Offset 0x13cc
    Func0x13cc(r.h.al, r.h.ah, r.w.si, videoParameterTableOverride);
    RETURN_ARG("SetVideoMode.Return 3", true);
    return true;
    // Label0x1354:                            ;Offset 0x1354
LABEL(SetVideoMode, Label0x1354);

    //     cmp  al, 02h
    //     jb   Label0x135f                    ;Offset 0x135f
    if (r.h.al < 0x02)
        goto Label0x135f;

    //     cmp  al, 03h
    //     ja   Label0x135f                    ;Offset 0x135f
    if (r.h.al > 0x03)
        goto Label0x135f;

    //     or   ah, 04h
    r.h.ah |= 0x04;

    // Label0x135f:                            ;Offset 0x135f
LABEL(SetVideoMode, Label0x135f);

    //     mov  word ptr ds:[BDA_PointHeightOfCharacterMatrix], 08h;Offset 0x485 0x8
    BDA::PointHeightOfCharacterMatrix::Get() = 0x08;

    //     call DeactivateAndInvokeSystemHandler                     ;Offset 0x13aa
    DeactivateAndInvokeSystemHandler(r.h.al, r.h.ah);

    // Label0x1368:                            ;Offset 0x1368
LABEL(SetVideoMode, Label0x1368);

    //     pop  ax
    //     ret
    RETURN_ARG("SetVideoMode.Return 4", true);

    // Label0x136a:                            ;Offset 0x136a
LABEL(SetVideoMode, Label0x136a);

    //     cmp  al, 6ah
    //     je   Label0x138d                    ;Offset 0x138d
    if (r.h.al == 0x6A)
        goto Label0x138d;

    //     mov  ah, al
    r.h.ah = r.h.al;

    //     and  ah, 0c0h
    r.h.ah &= 0xC0;

    //     or   ah, 01h
    r.h.ah |= 0x01;

    //     and  al, 3fh
    r.h.al &= 0x3F;

    //     cmp  al, 20h
    //     jb   Label0x1368                    ;Offset 0x1368
    if (r.h.al < 0x20)
        goto Label0x1368;

    //     cmp  al, 3fh
    //     ja   Label0x1368                    ;Offset 0x1368
    if (r.h.al > 0x3F)
        goto Label0x1368;

    //     sub  al, 20h
    r.h.al -= 0x20;

    //     push bx
    //     mov  bx, ax
    r.w.bx = r.w.ax;

    //     mov  ax, 04f02h
    //     int  10h
    //     pop  bx
    //     pop  ax
    //     ret
    RETURN_ARG("SetVideoMode.Return 5", SetVESAMode(r.w.bx));

    // Label0x138d:                            ;Offset 0x138d
LABEL(SetVideoMode, Label0x138d);

    //     pop  ax
    //     push bx
    //     mov  ax, 4f02h
    //     mov  bx, 0102h
    //     int  10h
    //     pop  bx
    //     ret
    RETURN_ARG("SetVideoMode.Return 6", SetVESAMode(0x102));
}

bool SetVideoMode(Hag::VGA::VideoMode_t videoMode)//Offset 0x12f0
{
    return SetVideoModeInternal(videoMode, NULL);
}

Hag::Testing::Mock::PortAndValue Matrox_Mystique_DefaultPortValues [] =
{
    { 0x0062, 0x00 },
    { 0x03C2, 0x70 },
    { 0x03C4, 0xFF },
    { 0x03C5, 0xFF },
    { 0x03CA, 0x00 },
    { 0x03CC, 0x67 },
    { 0x03BA, 0xFF },
    { 0x03DA, 0x01 },
    { 0x03C3, 0xFF },
    { 0x03C6, 0xFF },
    { 0x03C7, 0x03 },
    { 0x03C8, 0x00 },
    { 0x03C9, 0x00 },
    { 0x03D4, 0xFF },
    { 0x03D5, 0xFF },
    { 0x0102, 0xFF },
    { 0x46E8, 0xFF }
};

uint8_t Matrox_Mystique_AttributeControllerRegisters[] =
{
    0x00,
    0x01,
    0x02,
    0x03,
    0x04,
    0x05,
    0x14,
    0x07,
    0x38,
    0x39,
    0x3A,
    0x3B,
    0x3C,
    0x3D,
    0x3E,
    0x3F,
    0x0C,
    0x00,
    0x0F,
    0x08,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00
};

uint8_t Matrox_Mystique_RamdacControllerRegisters[] =
{
    0x00, 0x00, 0x00, //0
    0x00, 0x00, 0x2A, //1
    0x00, 0x2A, 0x00, //2
    0x00, 0x2A, 0x2A, //3
    0x2A, 0x00, 0x00, //4
    0x2A, 0x00, 0x2A, //5
    0x2A, 0x2A, 0x00, //6
    0x2A, 0x2A, 0x2A, //7
    0x00, 0x00, 0x15, //8
    0x00, 0x00, 0x3F, //9
    0x00, 0x2A, 0x15, //10
    0x00, 0x2A, 0x3F, //11
    0x2A, 0x00, 0x15, //12
    0x2A, 0x00, 0x3F, //13
    0x2A, 0x2A, 0x15, //14
    0x2A, 0x2A, 0x3F, //15
    0x00, 0x15, 0x00, //16
    0x00, 0x15, 0x2A, //17
    0x00, 0x3F, 0x00, //18
    0x00, 0x3F, 0x2A, //19
    0x2A, 0x15, 0x00, //20
    0x2A, 0x15, 0x2A, //21
    0x2A, 0x3F, 0x00, //22
    0x2A, 0x3F, 0x2A, //23
    0x00, 0x15, 0x15, //24
    0x00, 0x15, 0x3F, //25
    0x00, 0x3F, 0x15, //26
    0x00, 0x3F, 0x3F, //27
    0x2A, 0x15, 0x15, //28
    0x2A, 0x15, 0x3F, //29
    0x2A, 0x3F, 0x15, //30
    0x2A, 0x3F, 0x3F, //31
    0x15, 0x00, 0x00, //32
    0x15, 0x00, 0x2A, //33
    0x15, 0x2A, 0x00, //34
    0x15, 0x2A, 0x2A, //35
    0x3F, 0x00, 0x00, //36
    0x3F, 0x00, 0x2A, //37
    0x3F, 0x2A, 0x00, //38
    0x3F, 0x2A, 0x2A, //39
    0x15, 0x00, 0x15, //40
    0x15, 0x00, 0x3F, //41
    0x15, 0x2A, 0x15, //42
    0x15, 0x2A, 0x3F, //43
    0x3F, 0x00, 0x15, //44
    0x3F, 0x00, 0x3F, //45
    0x3F, 0x2A, 0x15, //46
    0x3F, 0x2A, 0x3F, //47
    0x15, 0x15, 0x00, //48
    0x15, 0x15, 0x2A, //49
    0x15, 0x3F, 0x00, //50
    0x15, 0x3F, 0x2A, //51
    0x3F, 0x15, 0x00, //52
    0x3F, 0x15, 0x2A, //53
    0x3F, 0x3F, 0x00, //54
    0x3F, 0x3F, 0x2A, //55
    0x15, 0x15, 0x15, //56
    0x15, 0x15, 0x3F, //57
    0x15, 0x3F, 0x15, //58
    0x15, 0x3F, 0x3F, //59
    0x3F, 0x15, 0x15, //60
    0x3F, 0x15, 0x3F, //61
    0x3F, 0x3F, 0x15, //62
    0x3F, 0x3F, 0x3F, //63
    0x00, 0x00, 0x00, //64
    0x00, 0x00, 0x00, //65
    0x00, 0x00, 0x00, //66
    0x00, 0x00, 0x00, //67
    0x00, 0x00, 0x00, //68
    0x00, 0x00, 0x00, //69
    0x00, 0x00, 0x00, //70
    0x00, 0x00, 0x00, //71
    0x00, 0x00, 0x00, //72
    0x00, 0x00, 0x00, //73
    0x00, 0x00, 0x00, //74
    0x00, 0x00, 0x00, //75
    0x00, 0x00, 0x00, //76
    0x00, 0x00, 0x00, //77
    0x00, 0x00, 0x00, //78
    0x00, 0x00, 0x00, //79
    0x00, 0x00, 0x00, //80
    0x00, 0x00, 0x00, //81
    0x00, 0x00, 0x00, //82
    0x00, 0x00, 0x00, //83
    0x00, 0x00, 0x00, //84
    0x00, 0x00, 0x00, //85
    0x00, 0x00, 0x00, //86
    0x00, 0x00, 0x00, //87
    0x00, 0x00, 0x00, //88
    0x00, 0x00, 0x00, //89
    0x00, 0x00, 0x00, //90
    0x00, 0x00, 0x00, //91
    0x00, 0x00, 0x00, //92
    0x00, 0x00, 0x00, //93
    0x00, 0x00, 0x00, //94
    0x00, 0x00, 0x00, //95
    0x00, 0x00, 0x00, //96
    0x00, 0x00, 0x00, //97
    0x00, 0x00, 0x00, //98
    0x00, 0x00, 0x00, //99
    0x00, 0x00, 0x00, //100
    0x00, 0x00, 0x00, //101
    0x00, 0x00, 0x00, //102
    0x00, 0x00, 0x00, //103
    0x00, 0x00, 0x00, //104
    0x00, 0x00, 0x00, //105
    0x00, 0x00, 0x00, //106
    0x00, 0x00, 0x00, //107
    0x00, 0x00, 0x00, //108
    0x00, 0x00, 0x00, //109
    0x00, 0x00, 0x00, //110
    0x00, 0x00, 0x00, //111
    0x00, 0x00, 0x00, //112
    0x00, 0x00, 0x00, //113
    0x00, 0x00, 0x00, //114
    0x00, 0x00, 0x00, //115
    0x00, 0x00, 0x00, //116
    0x00, 0x00, 0x00, //117
    0x00, 0x00, 0x00, //118
    0x00, 0x00, 0x00, //119
    0x00, 0x00, 0x00, //120
    0x00, 0x00, 0x00, //121
    0x00, 0x00, 0x00, //122
    0x00, 0x00, 0x00, //123
    0x00, 0x00, 0x00, //124
    0x00, 0x00, 0x00, //125
    0x00, 0x00, 0x00, //126
    0x00, 0x00, 0x00, //127
    0x00, 0x00, 0x00, //128
    0x00, 0x00, 0x00, //129
    0x00, 0x00, 0x00, //130
    0x00, 0x00, 0x00, //131
    0x00, 0x00, 0x00, //132
    0x00, 0x00, 0x00, //133
    0x00, 0x00, 0x00, //134
    0x00, 0x00, 0x00, //135
    0x00, 0x00, 0x00, //136
    0x00, 0x00, 0x00, //137
    0x00, 0x00, 0x00, //138
    0x00, 0x00, 0x00, //139
    0x00, 0x00, 0x00, //140
    0x00, 0x00, 0x00, //141
    0x00, 0x00, 0x00, //142
    0x00, 0x00, 0x00, //143
    0x00, 0x00, 0x00, //144
    0x00, 0x00, 0x00, //145
    0x00, 0x00, 0x00, //146
    0x00, 0x00, 0x00, //147
    0x00, 0x00, 0x00, //148
    0x00, 0x00, 0x00, //149
    0x00, 0x00, 0x00, //150
    0x00, 0x00, 0x00, //151
    0x00, 0x00, 0x00, //152
    0x00, 0x00, 0x00, //153
    0x00, 0x00, 0x00, //154
    0x00, 0x00, 0x00, //155
    0x00, 0x00, 0x00, //156
    0x00, 0x00, 0x00, //157
    0x00, 0x00, 0x00, //158
    0x00, 0x00, 0x00, //159
    0x00, 0x00, 0x00, //160
    0x00, 0x00, 0x00, //161
    0x00, 0x00, 0x00, //162
    0x00, 0x00, 0x00, //163
    0x00, 0x00, 0x00, //164
    0x00, 0x00, 0x00, //165
    0x00, 0x00, 0x00, //166
    0x00, 0x00, 0x00, //167
    0x00, 0x00, 0x00, //168
    0x00, 0x00, 0x00, //169
    0x00, 0x00, 0x00, //170
    0x00, 0x00, 0x00, //171
    0x00, 0x00, 0x00, //172
    0x00, 0x00, 0x00, //173
    0x00, 0x00, 0x00, //174
    0x00, 0x00, 0x00, //175
    0x00, 0x00, 0x00, //176
    0x00, 0x00, 0x00, //177
    0x00, 0x00, 0x00, //178
    0x00, 0x00, 0x00, //179
    0x00, 0x00, 0x00, //180
    0x00, 0x00, 0x00, //181
    0x00, 0x00, 0x00, //182
    0x00, 0x00, 0x00, //183
    0x00, 0x00, 0x00, //184
    0x00, 0x00, 0x00, //185
    0x00, 0x00, 0x00, //186
    0x00, 0x00, 0x00, //187
    0x00, 0x00, 0x00, //188
    0x00, 0x00, 0x00, //189
    0x00, 0x00, 0x00, //190
    0x00, 0x00, 0x00, //191
    0x00, 0x00, 0x00, //192
    0x00, 0x00, 0x00, //193
    0x00, 0x00, 0x00, //194
    0x00, 0x00, 0x00, //195
    0x00, 0x00, 0x00, //196
    0x00, 0x00, 0x00, //197
    0x00, 0x00, 0x00, //198
    0x00, 0x00, 0x00, //199
    0x00, 0x00, 0x00, //200
    0x00, 0x00, 0x00, //201
    0x00, 0x00, 0x00, //202
    0x00, 0x00, 0x00, //203
    0x00, 0x00, 0x00, //204
    0x00, 0x00, 0x00, //205
    0x00, 0x00, 0x00, //206
    0x00, 0x00, 0x00, //207
    0x00, 0x00, 0x00, //208
    0x00, 0x00, 0x00, //209
    0x00, 0x00, 0x00, //210
    0x00, 0x00, 0x00, //211
    0x00, 0x00, 0x00, //212
    0x00, 0x00, 0x00, //213
    0x00, 0x00, 0x00, //214
    0x00, 0x00, 0x00, //215
    0x00, 0x00, 0x00, //216
    0x00, 0x00, 0x00, //217
    0x00, 0x00, 0x00, //218
    0x00, 0x00, 0x00, //219
    0x00, 0x00, 0x00, //220
    0x00, 0x00, 0x00, //221
    0x00, 0x00, 0x00, //222
    0x00, 0x00, 0x00, //223
    0x00, 0x00, 0x00, //224
    0x00, 0x00, 0x00, //225
    0x00, 0x00, 0x00, //226
    0x00, 0x00, 0x00, //227
    0x00, 0x00, 0x00, //228
    0x00, 0x00, 0x00, //229
    0x00, 0x00, 0x00, //230
    0x00, 0x00, 0x00, //231
    0x00, 0x00, 0x00, //232
    0x00, 0x00, 0x00, //233
    0x00, 0x00, 0x00, //234
    0x00, 0x00, 0x00, //235
    0x00, 0x00, 0x00, //236
    0x00, 0x00, 0x00, //237
    0x00, 0x00, 0x00, //238
    0x00, 0x00, 0x00, //239
    0x00, 0x00, 0x00, //240
    0x00, 0x00, 0x00, //241
    0x00, 0x00, 0x00, //242
    0x00, 0x00, 0x00, //243
    0x00, 0x00, 0x00, //244
    0x00, 0x00, 0x00, //245
    0x00, 0x00, 0x00, //246
    0x00, 0x00, 0x00, //247
    0x00, 0x00, 0x00, //248
    0x00, 0x00, 0x00, //249
    0x00, 0x00, 0x00, //250
    0x00, 0x00, 0x00, //251
    0x00, 0x00, 0x00, //252
    0x00, 0x00, 0x00, //253
    0x00, 0x00, 0x00, //254
    0x00, 0x00, 0x00 //255
};

uint8_t Matrox_Mystique_CRTControllerRegisters[] =
{
    0x5F,
    0x4F,
    0x50,
    0x82,
    0x55,
    0x81,
    0xBF,
    0x1F,
    0x00,
    0x4F,
    0x0D,
    0x0E,
    0x00,
    0x00,
    0x00,
    0x00,
    0x9C,
    0x8E,
    0x8F,
    0x28,
    0x1F,
    0x96,
    0xB9,
    0xA3,
    0xFF
};

uint8_t Matrox_Mystique_CRTControllerRegisters_AndMask[] =
{
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0x7F,
    0xFF,
    0x3F,
    0x7F,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0x7F,
    0xFF,
    0xFF,
    0xEF,
    0xFF
};

uint8_t Matrox_Mystique_CRTControllerRegisters_OrMask[] =
{
    0x00,
    0x00,
    0x00,
    0x80,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00
};

uint8_t Matrox_Mystique_GraphicsControllerRegisters[] =
{
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x10,
    0x0E,
    0x00,
    0xFF
};

uint8_t Matrox_Mystique_GraphicsControllerRegisters_AndMask[] =
{
    0x0F,
    0x0F,
    0x0F,
    0x1F,
    0x03,
    0x7B,
    0x0F,
    0x0F,
    0xFF
};

uint8_t Matrox_Mystique_SequencerControllerRegisters[] =
{
    0x03,
    0x00,
    0x03,
    0x00,
    0x02
};

uint8_t Matrox_Mystique_SequencerControllerRegisters_AndMask[] =
{
    0x03,
    0x3D,
    0x0F,
    0x3F,
    0x0E
};

uint8_t Matrox_Mystique_CRTCExtensionRegisters[] =
{
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00
};

uint8_t Matrox_Mystique_CRTCExtensionRegisters_AndMask[] =
{
    0xBF,
    0xFF,
    0xFF,
    0xE7,
    0x7F,
    0xFF,
    0x03,
    0x03
};

void MatroxMystiqueMockConfigSetup(Hag::IAllocator& allocator)
{
    using namespace Hag;
    using namespace Hag::System;
    using namespace Hag::Testing;
    
    //printf("Mock initialization...\n");

    Hag::Testing::Mock::Initialize(allocator,
        Matrox_Mystique_DefaultPortValues,
        sizeof(Matrox_Mystique_DefaultPortValues) / sizeof(Mock::PortAndValue),
        Matrox_Mystique_AttributeControllerRegisters,
        Matrox_Mystique_RamdacControllerRegisters);

    Mock::AddIndexedPort("CRT Controller B", Hag::VGA::Register::CRTControllerIndexB, 0xff, Hag::VGA::Register::CRTControllerDataB, 0x19, Matrox_Mystique_CRTControllerRegisters, Matrox_Mystique_CRTControllerRegisters_OrMask, Matrox_Mystique_CRTControllerRegisters_AndMask);
    Mock::AddIndexedPort("CRT Controller D", Hag::VGA::Register::CRTControllerIndexD, 0xff, Hag::VGA::Register::CRTControllerDataD, 0x19, Matrox_Mystique_CRTControllerRegisters, Matrox_Mystique_CRTControllerRegisters_OrMask, Matrox_Mystique_CRTControllerRegisters_AndMask);
    Mock::AddIndexedPort("Graphics Controller", Hag::VGA::Register::GraphicsControllerIndex, 0x0f, Hag::VGA::Register::GraphicsControllerData, 0x09, Matrox_Mystique_GraphicsControllerRegisters, NULL, Matrox_Mystique_GraphicsControllerRegisters_AndMask);
    Mock::AddIndexedPort("Sequence Controller", Hag::VGA::Register::SequencerIndex, 0x1f, Hag::VGA::Register::SequencerData, 0x05, Matrox_Mystique_SequencerControllerRegisters, NULL, Matrox_Mystique_SequencerControllerRegisters_AndMask);
    Mock::AddIndexedPort("CRTC Extension Controller", Hag::Matrox::Shared::Register::CRTCExtensionIndex, 0x07, Hag::Matrox::Shared::Register::CRTCExtensionData, 0x07, Matrox_Mystique_SequencerControllerRegisters, NULL, Matrox_Mystique_CRTCExtensionRegisters_AndMask);
    BDA::SystemBDA().DetectedHardware = 0x22; //Hack
    BDA::SystemBDA().EGAFeatureBitSwitches = 0xF9;
    BDA::SystemBDA().VideoDisplayDataArea = 0x11;
    Mock::SetDefaultMemory((uint8_t*)&BDA::SystemBDA(), 0x0400, 0x100);//TODO: Should use something more static.

    //printf("Attempting to instantiate mock mystiques...\n");
    Mock::AddDualPortRegister("Miscellaneous Output", VGA::Register::MiscellaneousR, VGA::Register::MiscellaneousW);
    Mock::AddDualPortRegister("Feature Control", VGA::Register::FeatureControlR, VGA::Register::FeatureControlWB, VGA::Register::FeatureControlWD);
    Mock::PCI::RegisterDevice(0, ::new(allocator.Allocate(sizeof(MockMystique))) MockMystique(allocator));
    Mock::PCI::RegisterDevice(1, ::new(allocator.Allocate(sizeof(MockMystique))) MockMystique(allocator));
    //printf("Succes!\n");
}

uint8_t modes[] = 
{
            //          text/   text    pixel   pixel       colors  display screen
            //          grph    resol   box     resolution          pages    addr
    0x00,   // 00h =    T       40x25   9x16    360x400      16       8     B800
    0x01,   // 01h =    T       40x25   9x16    360x400      16       8     B800
    0x02,   // 02h =    T       80x25   9x16    720x400      16       8     B800
    0x03,   // 03h =    T       80x25   9x16    720x400      16       8     B800
            //     =    T       80x50   8x8     640x400      16       4     B800
    0x04,   // 04h =    G       40x25   8x8     320x200       4       .     B800
    0x05,   // 05h =    G       40x25   8x8     320x200       4       .     B800
    0x06,   // 06h =    G       80x25   8x8     640x200       2       .     B800
    0x07,   // 07h =    T       80x25   9x16    720x400     mono      .     B000
            // 08h =    ?
            // 09h =    ?
            // 0Ah =    ?
            // 0Bh =    Reserved
            // 0Ch =    Reserved
    0x0D,   // 0Dh =    G       40x25   8x8     320x200      16       8     A000
    0x0E,   // 0Eh =    G       80x25   8x8     640x200      16       4     A000
    0x0F,   // 0Fh =    G       80x25   8x14    640x350     mono      2     A000
    0x10,   // 10h =    G         .      .      640x350      16       .     A000
    0x11,   // 11h =    G       80x30   8x16    640x480     mono      .     A000
    0x12,   // 12h =    G       80x30   8x16    640x480      16/256K  .     A000
    0x13    // 13h =    G       40x25   8x8     320x200     256/256K  .     A000
};

uint16_t modesCount = sizeof(modes);

int Diff(const char* name)
{
    int ret = -1;
    if (Hag::Testing::Mock::HasDifferences())
    {
        printf("\n%s >----------------\n", name);
        Hag::Testing::Mock::Report();
        ret = 0;
    }
    Hag::Testing::Mock::Snapshot();
    return ret;
}


void BDADump(FILE* fp, FILE* fpbin)
{
    using namespace Hag::System::BDA;
    fwrite(&SystemBDA(), 256, 1, fpbin);
    fprintf(fp, "BIOS Data Area:\n\n");
    fprintf(fp, "Display mode                  : 0x%02X\n", DisplayMode::Get());
    fprintf(fp, "Detected hardware             : 0x%02X\n", DetectedHardware::Get());
    fprintf(fp, "Number of screen columns      : 0x%04X\n", NumberOfScreenColumns::Get());
    fprintf(fp, "Video buffer size             : 0x%04X\n", VideoBufferSize::Get());
    fprintf(fp, "Video buffer offset           : 0x%04X\n", VideoBufferOffset::Get());
    
    for (uint8_t cursorPos = 0; cursorPos < 8; ++cursorPos)
    {
        fprintf(fp, "Cursor position %i             : 0x%02X, 0x%02X\n", cursorPos,
            CursorPositions::Get()[cursorPos].Column,
            CursorPositions::Get()[cursorPos].Row);
    }
    fprintf(fp, "Cursor start scanline         : 0x%02X\n", CursorScanLines::Get().Start);
    fprintf(fp, "Cursor end scanline           : 0x%02X\n", CursorScanLines::Get().End);
    fprintf(fp, "Active display number         : 0x%02X\n", ActiveDisplayNumber::Get());
    fprintf(fp, "Video Base IO port            : 0x%04X\n", VideoBaseIOPort::Get());
    fprintf(fp, "CRT mode control reg          : 0x%02X\n", CRTModeControlRegValue::Get());
    fprintf(fp, "CGA Color Palette mask        : 0x%02X\n", CGAColorPaletteMaskSetting::Get());
    fprintf(fp, "Rows on screen                : 0x%02X\n", RowsOnScreen::Get());
    fprintf(fp, "Point height of Char Matrix   : 0x%02X\n", PointHeightOfCharacterMatrix::Get());
    fprintf(fp, "Video mode options            : 0x%02X\n", VideoModeOptions::Get());
    fprintf(fp, "EGA feature bit switches      : 0x%02X\n", EGAFeatureBitSwitches::Get());
    fprintf(fp, "Video display data area       : 0x%02X\n", VideoDisplayDataArea::Get());
    fprintf(fp, "Display combination code index: 0x%02X\n", DisplayCombinationCodeTableIndex::Get());
    fprintf(fp, "Video parameter ctrl block ptr: %04X:%04X\n", VideoParameterControlBlockPointer::Get().Segment, VideoParameterControlBlockPointer::Get().Offset);
    if (!VideoParameterControlBlockPointer::Get().IsNull())
    {
        VideoParameterControlBlock* videoParameterControlBlock = VideoParameterControlBlockPointer::Get().ToPointer<VideoParameterControlBlock>();
        fprintf(fp, "\nVideo parameter control block:\n");
        fprintf(fp, "Video parameters              : %04X:%04X\n", videoParameterControlBlock->VideoParameters.Segment, videoParameterControlBlock->VideoParameters.Offset);        
        fprintf(fp, "Dynamic param save area       : %04X:%04X\n", videoParameterControlBlock->DynamicParamSaveArea.Segment, videoParameterControlBlock->DynamicParamSaveArea.Offset);
        fprintf(fp, "Alphanumeric Charset override : %04X:%04X\n", videoParameterControlBlock->AlphanumericCharsetOverride.Segment, videoParameterControlBlock->AlphanumericCharsetOverride.Offset);
        fprintf(fp, "Graphics charset override     : %04X:%04X\n", videoParameterControlBlock->GraphicsCharacterSetOverride.Segment, videoParameterControlBlock->GraphicsCharacterSetOverride.Offset);
        fprintf(fp, "Secondary save pointer        : %04X:%04X\n", videoParameterControlBlock->SecondarySavePointer.Segment, videoParameterControlBlock->SecondarySavePointer.Offset);

        if (!videoParameterControlBlock->DynamicParamSaveArea.IsNull())
        {
            DynamicParameterSaveArea* dynamicParameterSaveArea = videoParameterControlBlock->DynamicParamSaveArea.ToPointer<DynamicParameterSaveArea>();
            fprintf(fp, "\nDynamic parameter save area:\n");
            for (uint8_t i = 0; i < 16; ++i)
            {
                fprintf(fp, "Palette register %02i           : 0x%02X\n", i, dynamicParameterSaveArea->PaletteRegisters[i]);
            }
            fprintf(fp, "Border color                  : 0x%02X\n", dynamicParameterSaveArea->GraphicsControllerOverscanRegister);
        }

        if (!videoParameterControlBlock->AlphanumericCharsetOverride.IsNull())
        {
            AlphaNumericCharacterSetOverride* alphaNumericCharacterSetOverride = videoParameterControlBlock->AlphanumericCharsetOverride.ToPointer<AlphaNumericCharacterSetOverride>();
            fprintf(fp, "\nAlphanumeric character set override:\n");
            fprintf(fp, "Character length              : 0x%02X\n", alphaNumericCharacterSetOverride->CharacterLength);
            fprintf(fp, "Character generator RAM bank  : 0x%02X\n", alphaNumericCharacterSetOverride->CharacterGeneratorRAMBank);
            fprintf(fp, "Number of characters          : 0x%04X\n", alphaNumericCharacterSetOverride->NumberOfCharacters);
            fprintf(fp, "First character code in table : 0x%04X\n", alphaNumericCharacterSetOverride->FirstCharacterCodeInTable);
            fprintf(fp, "Character font definition tbl : %04X:%04X\n", alphaNumericCharacterSetOverride->CharacterFontDefinitionTable.Segment, alphaNumericCharacterSetOverride->CharacterFontDefinitionTable.Offset);
            fprintf(fp, "Character rows                : 0x%02X\n", alphaNumericCharacterSetOverride->NumberOfCharacterRowsDisplayed);
            int idx = 0;
            while (alphaNumericCharacterSetOverride->ApplicableVideoModes[idx] != 0xFF)
            {
                fprintf(fp, "Applicable mode %02i            : 0x%02X\n", alphaNumericCharacterSetOverride->ApplicableVideoModes[idx]);
                ++idx;
            }
        }
        
        if (!videoParameterControlBlock->GraphicsCharacterSetOverride.IsNull())
        {
            GraphicsCharacterSet* graphicsCharacterSet = videoParameterControlBlock->GraphicsCharacterSetOverride.ToPointer<GraphicsCharacterSet>();
            fprintf(fp, "\nGraphics character set override:\n");
            fprintf(fp, "Number of character rows      : 0x%02X\n", graphicsCharacterSet->NumberOfCharacterRowsDisplayed);
            fprintf(fp, "Character length              : 0x%04X\n", graphicsCharacterSet->CharacterLength);
            fprintf(fp, "Character font definition tbl : %04X:%04X\n", graphicsCharacterSet->CharacterFontDefinitionTable.Segment, graphicsCharacterSet->CharacterFontDefinitionTable.Offset);
            int idx = 0;
            while (graphicsCharacterSet->ApplicableVideoModes[idx] != 0xFF)
            {
                fprintf(fp, "Applicable mode %02i            : 0x%02X\n", graphicsCharacterSet->ApplicableVideoModes[idx]);
                ++idx;
            }
        }

        if (!videoParameterControlBlock->SecondarySavePointer.IsNull())
        {
            SecondarySavePointerTable* secondarySavePointerTable = videoParameterControlBlock->SecondarySavePointer.ToPointer<SecondarySavePointerTable>();
            fprintf(fp, "\nSecondary save pointer table:\n");
            fprintf(fp, "Length of table               : 0x%02X\n", secondarySavePointerTable->LengthOfTableInBytes);
            fprintf(fp, "Display comination code talbe : %04X:%04X\n", secondarySavePointerTable->DisplayCombinationCodeTable.Segment, secondarySavePointerTable->DisplayCombinationCodeTable.Offset);
            fprintf(fp, "Secondary Alpha charset ovr   : %04X:%04X\n", secondarySavePointerTable->SecondaryAlphanumericCharacterSetOverride.Segment, secondarySavePointerTable->SecondaryAlphanumericCharacterSetOverride.Offset);
            fprintf(fp, "User palette profile table    : %04X:%04X\n", secondarySavePointerTable->UserPaletteProfileTable.Segment, secondarySavePointerTable->UserPaletteProfileTable.Offset);

            if (!secondarySavePointerTable->SecondaryAlphanumericCharacterSetOverride.IsNull())
            {
                SecondaryAlphaModeAuxillaryCharacterGeneratorTable* secondaryAlpha = secondarySavePointerTable->SecondaryAlphanumericCharacterSetOverride.ToPointer<SecondaryAlphaModeAuxillaryCharacterGeneratorTable>();
                fprintf(fp, "\nSecondary alpha charset override:\n");
                fprintf(fp, "Character height              : 0x%02X\n", secondaryAlpha->CharacterHeight);
                fprintf(fp, "RAM bank                      : 0x%02X\n", secondaryAlpha->RamBank);
                fprintf(fp, "Font data                     : %04X:%04X\n", secondaryAlpha->FontData.Segment, secondaryAlpha->FontData.Offset);
                int idx = 0;
                while (secondaryAlpha->ApplicableModes[idx] != 0xFF)
                {
                    fprintf(fp, "Applicable mode %02i            : 0x%02X\n", secondaryAlpha->ApplicableModes[idx]);
                    ++idx;
                }
            }

            if (!secondarySavePointerTable->UserPaletteProfileTable.IsNull())
            {
                PaletteProfile* paletteProfile = secondarySavePointerTable->UserPaletteProfileTable.ToPointer<PaletteProfile>();
                fprintf(fp, "\nUser palette profile table:\n");
                fprintf(fp, "Underlining                   : 0x%02X\n", paletteProfile->Underlining);
                fprintf(fp, "Attribute register count      : 0x%04X\n", paletteProfile->AttributeRegisterCount);
                fprintf(fp, "Attribute start index         : 0x%04X\n", paletteProfile->AttributeRegisterStartIndex);
                fprintf(fp, "Attribute register table      : %04X:%04X\n", paletteProfile->AttributeRegisterTable.Segment, paletteProfile->AttributeRegisterTable.Offset);
                fprintf(fp, "DAC register count            : 0x%04X\n", paletteProfile->DACRegisterCount);
                fprintf(fp, "DAC start index               : 0x%02X\n", paletteProfile->DACRegisterStartIndex);
                fprintf(fp, "DAC register table            : %04X:%04X\n", paletteProfile->DACRegisterTable.Segment, paletteProfile->DACRegisterTable.Offset);
                int idx = 0;
                while (paletteProfile->ApplicableModes[idx] != 0xFF)
                {
                    fprintf(fp, "Applicable mode %02i            : 0x%02X\n", paletteProfile->ApplicableModes[idx]);
                    ++idx;
                }
            }
        }
    }
    fprintf(fp, "\n");
}

void VGADump(FILE* fp, FILE* fpbin, Hag::VGA::Register_t baseIOPort)
{
    using namespace Hag::VGA;
    fprintf(fp, "VGA Registers:\n\n");

    FeatureControl_t featureControl = FeatureControl::Read();
    fprintf(fp, "Feature control               : 0x%02X\n", featureControl);
    fwrite(&featureControl, sizeof(featureControl), 1, fpbin);

    InputStatus1_t inputStatus1 = InputStatus1::Read(baseIOPort + 0x06);
    fprintf(fp, "Input status 1                : 0x%02X\n", inputStatus1);
    fwrite(&inputStatus1, sizeof(inputStatus1), 1, fpbin);

    MiscellaneousOutput_t miscellaneousOutput = MiscellaneousOutput::Read();
    fprintf(fp, "Miscellaneous output          : 0x%02X\n", miscellaneousOutput);
    fwrite(&miscellaneousOutput, sizeof(miscellaneousOutput), 1, fpbin);

    InputStatus0_t inputStatus0 = InputStatus0::Read();
    fprintf(fp, "Input status 0                : 0x%02X\n", inputStatus0);
    fwrite(&inputStatus0, sizeof(inputStatus0), 1, fpbin);

    VideoSubsystemEnable_t videoSubsystemEnable = VideoSubsystemEnable::Read();
    fprintf(fp, "Video subsystem enable        : 0x%02X\n", videoSubsystemEnable);
    fwrite(&videoSubsystemEnable, sizeof(videoSubsystemEnable), 1, fpbin);

    DACMask_t dacMask = DACMask::Read();
    fprintf(fp, "DAC mask                      : 0x%02X\n", dacMask);
    fwrite(&dacMask, sizeof(dacMask), 1, fpbin);

    DACStatus_t dacStatus = DACStatus::Read();
    fprintf(fp, "DAC status                    : 0x%02X\n", dacStatus);
    fwrite(&dacStatus, sizeof(dacStatus), 1, fpbin);

    fprintf(fp, "\nAttributes:\n");
    InputStatus1::Read(baseIOPort + 0x06);
    AttributeController::Register_t origAttribIdx = AttributeControllerIndex::Read();
    fprintf(fp, "Attribute Index:              : 0x%02X\n", origAttribIdx);
    fwrite(&origAttribIdx, sizeof(origAttribIdx), 1, fpbin);

    for (uint8_t attribIdx = 0; attribIdx < 0x10; ++attribIdx)
    {
        InputStatus1::Read(baseIOPort + 0x06);
        uint8_t idx = (origAttribIdx & 0xE0) | attribIdx;
        AttributeController::Palette_t palette = AttributeController::Palette::Read(idx);
        fprintf(fp, "Palette entry %02X              : 0x%02X\n", attribIdx, palette);
        fwrite(&palette, sizeof(palette), 1, fpbin);
    }

    InputStatus1::Read(baseIOPort + 0x06);
    AttributeController::AttributeMode_t attributeMode = AttributeController::AttributeMode::Read();
    fprintf(fp, "Attribute mode control        : 0x%02X\n", attributeMode);
    fwrite(&attributeMode, sizeof(attributeMode), 1, fpbin);

    InputStatus1::Read(baseIOPort + 0x06);
    AttributeController::BorderColor_t borderColor = AttributeController::BorderColor::Read();
    fprintf(fp, "Overscan color                : 0x%02X\n", borderColor);
    fwrite(&borderColor, sizeof(borderColor), 1, fpbin);

    InputStatus1::Read(baseIOPort + 0x06);
    AttributeController::ColorPlane_t colorPlane = AttributeController::ColorPlane::Read();
    fprintf(fp, "Color palette enable          : 0x%02X\n", colorPlane);
    fwrite(&colorPlane, sizeof(colorPlane), 1, fpbin);

    InputStatus1::Read(baseIOPort + 0x06);
    AttributeController::HorizontalPixelPanning_t horizontalPixelPanning = AttributeController::HorizontalPixelPanning::Read();
    fprintf(fp, "Horizontal PEL panning        : 0x%02X\n", horizontalPixelPanning);
    fwrite(&horizontalPixelPanning, sizeof(horizontalPixelPanning), 1, fpbin);

    InputStatus1::Read(baseIOPort + 0x06);
    AttributeController::PixelPadding_t pixelPadding = AttributeController::PixelPadding::Read();
    fprintf(fp, "Color select                  : 0x%02X\n", pixelPadding);
    fwrite(&pixelPadding, sizeof(pixelPadding), 1, fpbin);


    InputStatus1::Read(baseIOPort + 0x06);
    AttributeControllerIndex::Write(origAttribIdx);

    fprintf(fp, "\nCRTC:\n");
    CRTController::HorizontalTotal_t horizontalTotal = CRTController::HorizontalTotal::Read(baseIOPort);
    fprintf(fp, "Horizontal total              : 0x%02X\n", horizontalTotal);
    fwrite(&horizontalTotal, sizeof(horizontalTotal), 1, fpbin);

    CRTController::HorizontalDisplayEnd_t horizontalDisplayEnd = CRTController::HorizontalDisplayEnd::Read(baseIOPort);
    fprintf(fp, "Horizontal display enable end : 0x%02X\n", horizontalDisplayEnd);
    fwrite(&horizontalDisplayEnd, sizeof(horizontalDisplayEnd), 1, fpbin);

    CRTController::StartHorizontalBlank_t startHorizontalBlank = CRTController::StartHorizontalBlank::Read(baseIOPort);
    fprintf(fp, "Star horizontal blanking      : 0x%02X\n", startHorizontalBlank);
    fwrite(&startHorizontalBlank, sizeof(startHorizontalBlank), 1, fpbin);

    CRTController::EndHorizontalBlank_t endHorizontalBlank = CRTController::EndHorizontalBlank::Read(baseIOPort);
    fprintf(fp, "End horizontal blanking       : 0x%02X\n", endHorizontalBlank);
    fwrite(&endHorizontalBlank, sizeof(endHorizontalBlank), 1, fpbin);

    CRTController::StartHorizontalSyncPosition_t startHorizontalSyncPosition = CRTController::StartHorizontalSyncPosition::Read(baseIOPort);
    fprintf(fp, "Start horizontal retrace pulse: 0x%02X\n", startHorizontalSyncPosition);
    fwrite(&startHorizontalSyncPosition, sizeof(startHorizontalSyncPosition), 1, fpbin);

    CRTController::EndHorizontalSyncPosition_t endHorizontalSyncPosition = CRTController::EndHorizontalSyncPosition::Read(baseIOPort);
    fprintf(fp, "End horizontal retrace pulse  : 0x%02X\n", endHorizontalSyncPosition);
    fwrite(&endHorizontalSyncPosition, sizeof(endHorizontalSyncPosition), 1, fpbin);

    CRTController::VerticalTotal_t verticalTotal = CRTController::VerticalTotal::Read(baseIOPort);
    fprintf(fp, "Vertical total                : 0x%02X\n", verticalTotal);
    fwrite(&verticalTotal, sizeof(verticalTotal), 1, fpbin);

    CRTController::CRTCOverflow_t crtcOverflow = CRTController::CRTCOverflow::Read(baseIOPort);
    fprintf(fp, "Overflow                      : 0x%02X\n", crtcOverflow);
    fwrite(&crtcOverflow, sizeof(crtcOverflow), 1, fpbin);

    CRTController::PresetRowScan_t presetRowScan = CRTController::PresetRowScan::Read(baseIOPort);
    fprintf(fp, "Preset row scan               : 0x%02X\n", presetRowScan);
    fwrite(&presetRowScan, sizeof(presetRowScan), 1, fpbin);

    CRTController::MaximumScanLine_t maximumScanLine = CRTController::MaximumScanLine::Read(baseIOPort);
    fprintf(fp, "Maximum scan line             : 0x%02X\n", maximumScanLine);
    fwrite(&maximumScanLine, sizeof(maximumScanLine), 1, fpbin);

    CRTController::CursorStartScanLine_t cursorStartScanLine = CRTController::CursorStartScanLine::Read(baseIOPort);
    fprintf(fp, "Cursor start                  : 0x%02X\n", cursorStartScanLine);
    fwrite(&cursorStartScanLine, sizeof(cursorStartScanLine), 1, fpbin);

    CRTController::CursorEndScanLine_t cursorEndScanLine = CRTController::CursorEndScanLine::Read(baseIOPort);
    fprintf(fp, "Cursor end                    : 0x%02X\n", cursorEndScanLine);
    fwrite(&cursorEndScanLine, sizeof(cursorEndScanLine), 1, fpbin);

    CRTController::StartAddressHigh_t startAddressHigh = CRTController::StartAddressHigh::Read(baseIOPort);
    fprintf(fp, "Start address high            : 0x%02X\n", startAddressHigh);
    fwrite(&startAddressHigh, sizeof(startAddressHigh), 1, fpbin);

    CRTController::StartAddressLow_t startAddressLow = CRTController::StartAddressLow::Read(baseIOPort);
    fprintf(fp, "Start address low             : 0x%02X\n", startAddressLow);
    fwrite(&startAddressLow, sizeof(startAddressLow), 1, fpbin);

    CRTController::CursorLocationAddressHigh_t cursorLocationAddressHigh = CRTController::CursorLocationAddressHigh::Read(baseIOPort);
    fprintf(fp, "Cursor location high          : 0x%02X\n", cursorLocationAddressHigh);
    fwrite(&cursorLocationAddressHigh, sizeof(cursorLocationAddressHigh), 1, fpbin);

    CRTController::CursorLocationAddressLow_t cursorLocationAddressLow = CRTController::CursorLocationAddressLow::Read(baseIOPort);
    fprintf(fp, "Cursor location low           : 0x%02X\n", cursorLocationAddressLow);
    fwrite(&cursorLocationAddressLow, sizeof(cursorLocationAddressLow), 1, fpbin);

    CRTController::VerticalRetraceStart_t verticalRetraceStart = CRTController::VerticalRetraceStart::Read(baseIOPort);
    fprintf(fp, "Vertical retrace start        : 0x%02X\n", verticalRetraceStart);
    fwrite(&verticalRetraceStart, sizeof(verticalRetraceStart), 1, fpbin);

    CRTController::VerticalRetraceEnd_t verticalRetraceEnd = CRTController::VerticalRetraceEnd::Read(baseIOPort);
    fprintf(fp, "Vertical retrace end          : 0x%02X\n", verticalRetraceEnd);
    fwrite(&verticalRetraceEnd, sizeof(verticalRetraceEnd), 1, fpbin);

    CRTController::VerticalDisplayEnd_t verticalDisplayEnd = CRTController::VerticalDisplayEnd::Read(baseIOPort);
    fprintf(fp, "Vertical display enable end   : 0x%02X\n", verticalDisplayEnd);
    fwrite(&verticalDisplayEnd, sizeof(verticalDisplayEnd), 1, fpbin);

    CRTController::ScreenOffset_t screenOffset = CRTController::ScreenOffset::Read(baseIOPort);
    fprintf(fp, "Offset                        : 0x%02X\n", screenOffset);
    fwrite(&screenOffset, sizeof(screenOffset), 1, fpbin);

    CRTController::UnderlineLocation_t underlineLocation = CRTController::UnderlineLocation::Read(baseIOPort);
    fprintf(fp, "Underline location            : 0x%02X\n", underlineLocation);
    fwrite(&underlineLocation, sizeof(underlineLocation), 1, fpbin);

    CRTController::StartVerticalBlank_t startVerticalBlank = CRTController::StartVerticalBlank::Read(baseIOPort);
    fprintf(fp, "Start vertical blank          : 0x%02X\n", startVerticalBlank);
    fwrite(&startVerticalBlank, sizeof(startVerticalBlank), 1, fpbin);

    CRTController::EndVerticalBlank_t endVerticalBlank = CRTController::EndVerticalBlank::Read(baseIOPort);
    fprintf(fp, "End vertical blank            : 0x%02X\n", endVerticalBlank);
    fwrite(&endVerticalBlank, sizeof(endVerticalBlank), 1, fpbin);

    CRTController::CRTCModeControl_t crtcModeControl = CRTController::CRTCModeControl::Read(baseIOPort);
    fprintf(fp, "CRTC mode control             : 0x%02X\n", crtcModeControl);
    fwrite(&crtcModeControl, sizeof(crtcModeControl), 1, fpbin);

    CRTController::LineCompare_t lineCompare = CRTController::LineCompare::Read(baseIOPort);
    fprintf(fp, "Line compare                  : 0x%02X\n", lineCompare);
    fwrite(&lineCompare, sizeof(lineCompare), 1, fpbin);


    fprintf(fp, "\nSequencer:\n");
    Sequencer::Reset_t reset = Sequencer::Reset::Read();
    fprintf(fp, "Reset                         : 0x%02X\n", reset);
    fwrite(&reset, sizeof(reset), 1, fpbin);

    Sequencer::ClockingMode_t clockingMode = Sequencer::ClockingMode::Read();
    fprintf(fp, "Clocking mode                 : 0x%02X\n", clockingMode);
    fwrite(&clockingMode, sizeof(clockingMode), 1, fpbin);

    Sequencer::EnableWritePlane_t enableWritePlane = Sequencer::EnableWritePlane::Read();
    fprintf(fp, "Map mask                      : 0x%02X\n", enableWritePlane);
    fwrite(&enableWritePlane, sizeof(enableWritePlane), 1, fpbin);

    Sequencer::CharacterFontSelect_t characterFontSelect = Sequencer::CharacterFontSelect::Read();
    fprintf(fp, "Character map select          : 0x%02X\n", characterFontSelect);
    fwrite(&characterFontSelect, sizeof(characterFontSelect), 1, fpbin);

    Sequencer::MemoryModeControl_t memoryModeControl = Sequencer::MemoryModeControl::Read();
    fprintf(fp, "Memory mode                   : 0x%02X\n", memoryModeControl);
    fwrite(&memoryModeControl, sizeof(memoryModeControl), 1, fpbin);


    fprintf(fp, "\nGraphics controller:\n");
    GraphicsController::SetResetData_t setResetData = GraphicsController::SetResetData::Read();
    fprintf(fp, "Set/Reset                     : 0x%02X\n", setResetData);
    fwrite(&setResetData, sizeof(setResetData), 1, fpbin);

    GraphicsController::EnableSetResetData_t enableSetResetData = GraphicsController::EnableSetResetData::Read();
    fprintf(fp, "Enable Set/Reset              : 0x%02X\n", enableSetResetData);
    fwrite(&enableSetResetData, sizeof(enableSetResetData), 1, fpbin);

    GraphicsController::ColorCompare_t colorCompare = GraphicsController::ColorCompare::Read();
    fprintf(fp, "Color compare                 : 0x%02X\n", colorCompare);
    fwrite(&colorCompare, sizeof(colorCompare), 1, fpbin);

    GraphicsController::RasterOperationRotateCount_t rasterOperationRotateCount = GraphicsController::RasterOperationRotateCount::Read();
    fprintf(fp, "Data rotate                   : 0x%02X\n", rasterOperationRotateCount);
    fwrite(&rasterOperationRotateCount, sizeof(rasterOperationRotateCount), 1, fpbin);

    GraphicsController::ReadPlaneSelect_t readPlaneSelect = GraphicsController::ReadPlaneSelect::Read();
    fprintf(fp, "Read map select               : 0x%02X\n", readPlaneSelect);
    fwrite(&readPlaneSelect, sizeof(readPlaneSelect), 1, fpbin);

    GraphicsController::GraphicsControllerMode_t graphicsControllerMode = GraphicsController::GraphicsControllerMode::Read();
    fprintf(fp, "Graphics mode                 : 0x%02X\n", graphicsControllerMode);
    fwrite(&graphicsControllerMode, sizeof(graphicsControllerMode), 1, fpbin);

    GraphicsController::MemoryMapModeControl_t memoryMapModeControl = GraphicsController::MemoryMapModeControl::Read();
    fprintf(fp, "Miscellaneous                 : 0x%02X\n", memoryMapModeControl);
    fwrite(&memoryMapModeControl, sizeof(memoryMapModeControl), 1, fpbin);

    GraphicsController::ColorDontCare_t colorDontCare = GraphicsController::ColorDontCare::Read();
    fprintf(fp, "Color don't care              : 0x%02X\n", colorDontCare);
    fwrite(&colorDontCare, sizeof(colorDontCare), 1, fpbin);

    GraphicsController::BitMask_t bitMask = GraphicsController::BitMask::Read();
    fprintf(fp, "Bit mask                      : 0x%02X\n", bitMask);
    fwrite(&bitMask, sizeof(bitMask), 1, fpbin);


    fprintf(fp, "\nRAMDAC registers:\n");
    DACReadIndex::Write(0);
    for (uint16_t color = 0; color < 256; ++color)
    {
        uint8_t red = RAMDACData::Read();
        uint8_t green = RAMDACData::Read();
        uint8_t blue = RAMDACData::Read();
        fprintf(fp, "0x%02X: 0x%02X, 0x%02X, 0x%02X\n", color, red, green, blue);
        fwrite(&red, 1, 1, fpbin);
        fwrite(&green, 1, 1, fpbin);
        fwrite(&blue, 1, 1, fpbin);
    }

    fprintf(fp, "\n");
}

struct Device
{
    uint16_t DeviceID;
    const char* Name;
};

struct ScanContext
{
    FILE* fp;
    FILE* fpbin;
    Device* devices;
    uint16_t deviceCount;
    uint16_t vendor;
};

bool pciDeviceFound = false;
uint8_t pciDeviceBus = 0;
uint8_t pciDeviceSlot = 0;
uint8_t pciDeviceFunction = 0;

bool FindDevices(uint8_t bus, uint8_t slot, uint8_t function, void* context)
{
    using namespace Hag::System;

    ScanContext* ctx = (ScanContext*)context;

    if (PCI::GetVendorId(bus, slot, function) == ctx->vendor)
    {
        if (!pciDeviceFound)
        {
            pciDeviceFound = true;
            pciDeviceBus = bus;
            pciDeviceSlot = slot;
            pciDeviceFunction = function;
        }
        fprintf(ctx->fp, "\nBus: 0x%02X, Slot: 0x%02X, Function: 0x%02X\n", bus, slot, function);
        uint16_t deviceID = PCI::GetDeviceId(bus, slot, function);
        bool found = false;
        for (uint16_t deviceIdx = 0; deviceIdx < ctx->deviceCount; ++deviceIdx)
        {
            if (ctx->devices[deviceIdx].DeviceID == deviceID)
            {
                found = true;
                fprintf(ctx->fp, "%s:\n", ctx->devices[deviceIdx].Name);
                break;
            }
        }
        if (!found)
        {
            fprintf(ctx->fp, "Unknown Matrox device 0x%04X:\n", deviceID);
        }
        for (uint8_t pciRegIdx = 0; pciRegIdx < 64; ++pciRegIdx)
        {
            uint32_t pciReg = PCI::Read32(bus, slot, function, pciRegIdx << 2);
            fprintf(ctx->fp, "0x%02X: 0x%02X, 0x%02X, 0x%02X, 0x%02X,    0x%08X\n",
                    pciRegIdx,
                    uint8_t(pciReg),
                    uint8_t(pciReg >> 8),
                    uint8_t(pciReg >> 16),
                    uint8_t(pciReg >> 24),
                    pciReg);
            fwrite(&pciReg, sizeof(pciReg), 1, ctx->fpbin);
        }
        fprintf(ctx->fp, "\n");
    }
    return true;
}

void PCIDump(FILE* fp, FILE* fpbin, uint16_t vendor, Device* devices, uint16_t deviceCount)
{
    ScanContext context;
    context.fp = fp;
    context.fpbin = fpbin;
    context.devices = devices;
    context.deviceCount = deviceCount;
    context.vendor = vendor;

    Hag::System::PCI::ScanBus(0, FindDevices, &context);
}

void MatroxDump(FILE* fp, FILE* fpbin, uint16_t baseIOPort)
{
    using namespace Hag;
    using namespace Hag::Matrox::Shared;

    System::PCI::Device_t device = (uint16_t(pciDeviceBus) << 8) | (pciDeviceSlot << 3) | pciDeviceFunction;
    fprintf(fp, "\nMatrox specific registers:\n");

    //PCI::ControlAperture_t controlAperture = PCI::ControlAperture::Read(device) & PCI::ControlAperture::BaseAddress;

    //fwrite((void*)controlAperture, 16 * 1024, 1, fpbin);

    fprintf(fp, "\nCRTC:\n");
    CRTController::CPUReadLatch_t cpuReadLatch = CRTController::CPUReadLatch::Read(baseIOPort);
    fprintf(fp, "CPU read latch                : 0x%02X\n", cpuReadLatch);
    fwrite(&cpuReadLatch, sizeof(cpuReadLatch), 1, fpbin);

    CRTController::AttributeAddressDataSelect_t attributeAddressDataSelect = CRTController::AttributeAddressDataSelect::Read(baseIOPort);
    fprintf(fp, "Attributes addres/data select : 0x%02X\n", attributeAddressDataSelect);
    fwrite(&attributeAddressDataSelect, sizeof(attributeAddressDataSelect), 1, fpbin);

    CRTController::AttributeAddress_t attributeAddress = CRTController::AttributeAddress::Read(baseIOPort);
    fprintf(fp, "Attributes address            : 0x%02X\n", attributeAddress);
    fwrite(&attributeAddress, sizeof(attributeAddress), 1, fpbin);

    fprintf(fp, "\nCRTC Extension:\n");
    fprintf(fp, "Address generator extensions  : 0x%02X\n", CRTCExtension::AddressGeneratorExtensions::Read());
    fprintf(fp, "Horizontal counter extensions : 0x%02X\n", CRTCExtension::HorizontalCounterExtensions::Read());
    fprintf(fp, "Miscellaneous                 : 0x%02X\n", CRTCExtension::Miscellaneous::Read());
    fprintf(fp, "Memory page                   : 0x%02X\n", CRTCExtension::MemoryPage::Read());
    fprintf(fp, "Horizontal video half count   : 0x%02X\n", CRTCExtension::HorizontalCounterExtensions::Read());
    CRTCExtensionIndex::Write(0x06);
    fprintf(fp, "Priority request control      : 0x%02X\n", CRTCExtensionData::Read());
    CRTCExtensionIndex::Write(0x07);
    fprintf(fp, "Requester control             : 0x%02X\n", CRTCExtensionData::Read());
    CRTCExtensionIndex::Write(0x08);
    fprintf(fp, "Address extension             : 0x%02X\n", CRTCExtensionData::Read());
    CRTCExtensionIndex::Write(0x09);
    fprintf(fp, "Unknown 0x09                  : 0x%02X\n", CRTCExtensionData::Read());
    CRTCExtensionIndex::Write(0x0A);
    fprintf(fp, "Unknown 0x0A                  : 0x%02X\n", CRTCExtensionData::Read());
    CRTCExtensionIndex::Write(0x0B);
    fprintf(fp, "Unknown 0x0B                  : 0x%02X\n", CRTCExtensionData::Read());
    CRTCExtensionIndex::Write(0x0C);
    fprintf(fp, "Unknown 0x0C                  : 0x%02X\n", CRTCExtensionData::Read());
    CRTCExtensionIndex::Write(0x0D);
    fprintf(fp, "Unknown 0x0D                  : 0x%02X\n", CRTCExtensionData::Read());
    CRTCExtensionIndex::Write(0x0E);
    fprintf(fp, "Unknown 0x0E                  : 0x%02X\n", CRTCExtensionData::Read());
    CRTCExtensionIndex::Write(0x0F);
    fprintf(fp, "Unknown 0x0F                  : 0x%02X\n", CRTCExtensionData::Read());
    for (uint8_t idx = 0; idx < 0x10; ++idx)
    {
        CRTCExtensionIndex::Write(0x0F);
        CRTCExtensionData_t data = CRTCExtensionData::Read();
        fwrite(&data, sizeof(data), 1, fpbin);
    }

    fprintf(fp, "\nIndexed registers:\n");
    fprintf(fp, "Cursor base address low       : 0x%02X\n", PCI::Indexed::CursorBaseAddressLow::Read(device));
    fprintf(fp, "Cursor base address high      : 0x%02X\n", PCI::Indexed::CursorBaseAddressHigh::Read(device));
    fprintf(fp, "Cursor control                : 0x%02X\n", PCI::Indexed::CursorControl::Read(device));
    fprintf(fp, "Cursor color 0 red            : 0x%02X\n", PCI::Indexed::CursorColor::ReadRed0(device));
    fprintf(fp, "Cursor color 0 green          : 0x%02X\n", PCI::Indexed::CursorColor::ReadGreen0(device));
    fprintf(fp, "Cursor color 0 blue           : 0x%02X\n", PCI::Indexed::CursorColor::ReadBlue0(device));
    fprintf(fp, "Cursor color 1 red            : 0x%02X\n", PCI::Indexed::CursorColor::ReadRed1(device));
    fprintf(fp, "Cursor color 1 green          : 0x%02X\n", PCI::Indexed::CursorColor::ReadGreen1(device));
    fprintf(fp, "Cursor color 1 blue           : 0x%02X\n", PCI::Indexed::CursorColor::ReadBlue1(device));
    fprintf(fp, "Cursor color 2 red            : 0x%02X\n", PCI::Indexed::CursorColor::ReadRed2(device));
    fprintf(fp, "Cursor color 2 green          : 0x%02X\n", PCI::Indexed::CursorColor::ReadGreen2(device));
    fprintf(fp, "Cursor color 2 blue           : 0x%02X\n", PCI::Indexed::CursorColor::ReadBlue2(device));
    fprintf(fp, "Voltage reference control     : 0x%02X\n", PCI::Indexed::VoltageReferenceControl::Read(device));
    fprintf(fp, "Multiplex control             : 0x%02X\n", PCI::Indexed::MultiplexControl::Read(device));
    fprintf(fp, "Pixel clock control           : 0x%02X\n", PCI::Indexed::PixelClockControl::Read(device));
    fprintf(fp, "General control               : 0x%02X\n", PCI::Indexed::GeneralControl::Read(device));
    fprintf(fp, "Miscellaneous control         : 0x%02X\n", PCI::Indexed::MiscellaneousControl::Read(device));
    
    fprintf(fp, "Panel mode                    : 0x%02X\n", PCI::IndexedData::Read(device, 0x1F));
    fprintf(fp, "MAFC delay                    : 0x%02X\n", PCI::IndexedData::Read(device, 0x20));
    
    fprintf(fp, "General purpose IO control    : 0x%02X\n", PCI::Indexed::GeneralPurposeIOControl::Read(device));
    fprintf(fp, "General purpose data          : 0x%02X\n", PCI::Indexed::GeneralPurposeIOData::Read(device));
    fprintf(fp, "System PLL M value            : 0x%02X\n", PCI::Indexed::SystemPLLM::Read(device));
    fprintf(fp, "System PLL N value            : 0x%02X\n", PCI::Indexed::SystemPLLN::Read(device));
    fprintf(fp, "System PLL P value            : 0x%02X\n", PCI::Indexed::SystemPLLP::Read(device));
    fprintf(fp, "System PLL status             : 0x%02X\n", PCI::Indexed::SystemPLLStatus::Read(device));
    fprintf(fp, "Zoom control                  : 0x%02X\n", PCI::Indexed::ZoomControl::Read(device));
    fprintf(fp, "Sense test                    : 0x%02X\n", PCI::Indexed::SenseTest::Read(device));
    fprintf(fp, "CRC remainder low             : 0x%02X\n", PCI::Indexed::CRCRemainderLow::Read(device));
    fprintf(fp, "CRC remainder high            : 0x%02X\n", PCI::Indexed::CRCRemainderHigh::Read(device));
    fprintf(fp, "CRC bit select                : 0x%02X\n", PCI::Indexed::CRCBitSelect::Read(device));
    fprintf(fp, "Color key mask low            : 0x%02X\n", PCI::Indexed::ColorKeyMaskLow::Read(device));
    fprintf(fp, "Color key mask high           : 0x%02X\n", PCI::Indexed::ColorKeyMaskHigh::Read(device));
    fprintf(fp, "Color key low                 : 0x%02X\n", PCI::Indexed::ColorKeyLow::Read(device));
    fprintf(fp, "Color key high                : 0x%02X\n", PCI::Indexed::ColorKeyHigh::Read(device));
    fprintf(fp, "Pixel PLL A M value           : 0x%02X\n", PCI::Indexed::PixelPLLM::ReadA(device));
    fprintf(fp, "Pixel PLL A N value           : 0x%02X\n", PCI::Indexed::PixelPLLN::ReadA(device));
    fprintf(fp, "Pixel PLL A P value           : 0x%02X\n", PCI::Indexed::PixelPLLP::ReadA(device));
    fprintf(fp, "Pixel PLL B M value           : 0x%02X\n", PCI::Indexed::PixelPLLM::ReadB(device));
    fprintf(fp, "Pixel PLL B N value           : 0x%02X\n", PCI::Indexed::PixelPLLN::ReadB(device));
    fprintf(fp, "Pixel PLL B P value           : 0x%02X\n", PCI::Indexed::PixelPLLP::ReadB(device));
    fprintf(fp, "Pixel PLL C M value           : 0x%02X\n", PCI::Indexed::PixelPLLM::ReadC(device));
    fprintf(fp, "Pixel PLL C N value           : 0x%02X\n", PCI::Indexed::PixelPLLN::ReadC(device));
    fprintf(fp, "Pixel PLL C P value           : 0x%02X\n", PCI::Indexed::PixelPLLP::ReadC(device));
    fprintf(fp, "Pixel PLL status              : 0x%02X\n", PCI::Indexed::PixelPLLStatus::Read(device));

    fprintf(fp, "Keying operating mode         : 0x%02X\n", PCI::IndexedData::Read(device, 0x51));
    fprintf(fp, "Color mask 0 red              : 0x%02X\n", PCI::IndexedData::Read(device, 0x52));
    fprintf(fp, "Color mask 0 green            : 0x%02X\n", PCI::IndexedData::Read(device, 0x53));
    fprintf(fp, "Color mask 0 blue             : 0x%02X\n", PCI::IndexedData::Read(device, 0x54));
    fprintf(fp, "Color key 0 red               : 0x%02X\n", PCI::IndexedData::Read(device, 0x55));
    fprintf(fp, "Color key 0 green             : 0x%02X\n", PCI::IndexedData::Read(device, 0x56));
    fprintf(fp, "Color key 0 blue              : 0x%02X\n", PCI::IndexedData::Read(device, 0x57));

    for (uint16_t index = 0x58; index < 0x80; ++index)
    {
        fprintf(fp, "Unknown indexed register 0x%02X : 0x%02X\n", index, PCI::IndexedData::Read(device, index));
    }

    for (uint16_t index = 0; index < 0x80; ++index)
    {
        PCI::IndexedData_t data = PCI::IndexedData::Read(device, index);
        fwrite(&data, sizeof(data), 1, fpbin);
    }

    fprintf(fp, "\n");
}

int main(void)
{
    using namespace Hag;
    using namespace Hag::System;
    
    static Device devices[] =
    {
        { 0x0519, "Matrox Millennium 2064W PCI" },
        { 0x051A, "Matrox Mystique 1064SG PCI", },
        { 0x051B, "Matrox Millennium II 2164W PCI" },
        { 0x051F, "Matrox Millennium II 2164W AGP" },
        { 0x0520, "Matrox G200 PCI" },
        { 0x0521, "Matrox G200 AGP" },
        { 0x0525, "Matrox G400/G450 AGP" },
        { 0x0D10, "Matrox Ultima/Impression PCI" },
        { 0x1001, "Matrox Productiva G100 AGP" },
        { 0x1000, "Matrox Productiva G100 PCI" }
    };

    Support::Allocator allocator;
    MatroxMystiqueMockConfigSetup(allocator);

    for (uint16_t modesIdx = 0; modesIdx < modesCount; ++modesIdx)
    {
        //printf("Resetting...\n");
        Hag::Testing::Mock::Reset();

        uint8_t mode = modes[modesIdx];

        Hag::Testing::Mock::SelectInstance(0);
        printf("Setting video mode 0x%02X...\n", mode);
        SetVideoMode(mode);

        char filename[50];
        FILE* fp = NULL;
        FILE* fpbin = NULL;
        
        sprintf(filename, "bda00%02X.txt", mode);
        fp = fopen(filename, "w");
        sprintf(filename, "bda00%02X.bin", mode);
        fpbin = fopen(filename, "wb");
        BDADump(fp, fpbin);
        fclose(fp);
        fclose(fpbin);


        sprintf(filename, "vga00%02X.txt", mode);
        fp = fopen(filename, "w");
        sprintf(filename, "vga00%02X.bin", mode);
        fpbin = fopen(filename, "wb");
        VGADump(fp, fpbin, BDA::VideoBaseIOPort::Get());
        fclose(fp);
        fclose(fpbin);

        sprintf(filename, "pci00%02X.txt", mode);
        fp = fopen(filename, "w");
        sprintf(filename, "pci00%02X.bin", mode);
        fpbin = fopen(filename, "wb");
        PCIDump(fp, fpbin, 0x102B, devices, sizeof(devices) / sizeof(Device));
        fclose(fp);
        fclose(fpbin);

        if (pciDeviceFound)
        {
            sprintf(filename, "mtx00%02X.txt", mode);
            fp = fopen(filename, "w");
            sprintf(filename, "mtx00%02X.bin", mode);
            fpbin = fopen(filename, "wb");
            MatroxDump(fp, fpbin, BDA::VideoBaseIOPort::Get());
            fclose(fp);
            fclose(fpbin);
        }


        //Hag::Testing::Mock::SelectInstance(1);
        //TODO: we put our C++ version here.

        //Diff("SetMode");
    }


    uint16_t vesaModes[] =
    {
        0x100, //640x400x256
        0x101, //640x480x256
        0x102, //800x600x16
        0x103, //800x600x256
        0x104, //1024x768x16
        0x105, //1024x768x256
        0x106, //1280x1024x16
        0x107, //1280x1024x256
        0x108, //80x60 text
        0x109, //132x25 text
        0x10A, //132x43 text
        0x10B, //132x50 text
        0x10C, //132x60 text
        0x10D, //320x200x32K
        0x10E, //320x200x64K
        0x10F, //320x200x16M
        0x110, //640x480x32K
        0x111, //640x480x64K
        0x112, //640x480x16M
        0x113, //800x600x32K
        0x114, //800x600x64K
        0x115, //800x600x16M
        0x116, //1024x768x32K
        0x117, //1024x768x64K
        0x118, //1024x768x16M
        0x119, //1280x1024x32K
        0x11A, //1280x1024x64K
        0x11B, //1280x1024x16M
        0x11C, //1600x1200x256
        0x11D, //1600x1200x32k
        0x11E, //1600x1200x64k
        0x120, //1600x1200x256 //Duplicates??
        0x121, //1600x1200x32K
        0x122, //1600x1200x64K
    };

    for (uint8_t modeIdx = 0; modeIdx < (sizeof(vesaModes) / sizeof(uint16_t)); ++modeIdx)
    {
        //printf("Resetting...\n");
        Hag::Testing::Mock::Reset();

        uint16_t vesaMode = vesaModes[modeIdx];

        Hag::Testing::Mock::SelectInstance(0);
        printf("Setting vesa mode 0x%04X...\n", vesaMode);
        SetVESAMode(vesaMode);

        char filename[50];
        FILE* fp = NULL;
        FILE* fpbin = NULL;

        sprintf(filename, "bda%04X.txt", vesaMode);
        fp = fopen(filename, "w");
        sprintf(filename, "bda%04X.bin", vesaMode);
        fpbin = fopen(filename, "wb");
        BDADump(fp, fpbin);
        fclose(fp);
        fclose(fpbin);

        sprintf(filename, "vesa%04X.txt", vesaMode);
        fp = fopen(filename, "w");
        sprintf(filename, "vesa%04X.bin", vesaMode);
        fpbin = fopen(filename, "wb");
        VGADump(fp, fpbin, BDA::VideoBaseIOPort::Get());
        fclose(fp);
        fclose(fpbin);

        sprintf(filename, "pci%04X.txt", vesaMode);
        fp = fopen(filename, "w");
        sprintf(filename, "pci%04X.bin", vesaMode);
        fpbin = fopen(filename, "wb");
        PCIDump(fp, fpbin, 0x102B, devices, sizeof(devices) / sizeof(Device));
        fclose(fp);
        fclose(fpbin);

        if (pciDeviceFound)
        {
            sprintf(filename, "mtx%04X.txt", vesaMode);
            fp = fopen(filename, "w");
            sprintf(filename, "mtx%04X.bin", vesaMode);
            fpbin = fopen(filename, "wb");
            MatroxDump(fp, fpbin, BDA::VideoBaseIOPort::Get());
            fclose(fp);
            fclose(fpbin);
        }

        //Hag::Testing::Mock::SelectInstance(1);
        //TODO: we put our C++ version here.

        //Diff("SetVesaMode");
    }

    Hag::Testing::Mock::Shutdown();
    return 0;
}

//Offset 0xc4e0
Hag::System::BDA::VideoParameterTable VideoParameters[] =
{
    {
        0x28,
        0x18,
        0x08,
        0x0800,
        { 0x09, 0x03, 0x00, 0x02 },
        0x63,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0xA0, 0xBF, 0x1F, 0x00, 0xC7, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x0800,
        { 0x09, 0x03, 0x00, 0x02 },
        0x63,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0xA0, 0xBF, 0x1F, 0x00, 0xC7, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x1000,
        { 0x01, 0x03, 0x00, 0x02 },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0xC7, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x1000,
        { 0x01, 0x03, 0x00, 0x02 },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0xC7, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x4000,
        { 0x09, 0x03, 0x00, 0x02 },
        0x63,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0x80, 0xBF, 0x1F, 0x00, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x00, 0x96, 0xB9, 0xA2, 0xFF },
        { 0x00, 0x13, 0x15, 0x17, 0x02, 0x04, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x03, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0F, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x4000,
        { 0x09, 0x03, 0x00, 0x02 },
        0x63,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0x80, 0xBF, 0x1F, 0x00, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x00, 0x96, 0xB9, 0xA2, 0xFF },
        { 0x00, 0x13, 0x15, 0x17, 0x02, 0x04, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x03, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0F, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x4000,
        { 0x01, 0x01, 0x00, 0x06 },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x00, 0x96, 0xB9, 0xC2, 0xFF },
        { 0x00, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x01, 0x00, 0x01, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x1000,
        { 0x00, 0x03, 0x00, 0x03 },
        0xA6,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x4D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x28, 0x0D, 0x63, 0xBA, 0xA3, 0xFF },
        { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x0F, 0x08 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0A, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x10,
        0x7D00,
        { 0x21, 0x0F, 0x00, 0x06 },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x00,
        0x00,
        0x00,
        0x0000,
        { 0x00, 0x00, 0x00, 0x00 },
        0x00,
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    },
    {
        0x28,
        0x18,
        0x08,
        0x4000,
        { 0x00, 0x00, 0x00, 0x03 },
        0x23,
        { 0x37, 0x27, 0x2D, 0x37, 0x31, 0x15, 0x04, 0x11, 0x00, 0x47, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x14, 0x08, 0xE0, 0xF0, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x00,
        0x00,
        0x0000,
        { 0x29, 0x0F, 0x00, 0x06 },
        0x62,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xE3, 0xFF },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x0F, 0x00, 0x00, 0x08, 0x05, 0x0F, 0xFF }
    },
    {
        0x50,
        0x00,
        0x00,
        0x0000,
        { 0x29, 0x0F, 0x00, 0x06 },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xE3, 0xFF },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x0F, 0x00, 0x00, 0x08, 0x05, 0x0F, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x2000,
        { 0x09, 0x0F, 0x00, 0x06 },
        0x63,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0x80, 0xBF, 0x1F, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x00, 0x96, 0xB9, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x4000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x00, 0x96, 0xB9, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x8000,
        { 0x05, 0x0F, 0x00, 0x00 },
        0xA2,
        { 0x60, 0x4F, 0x56, 0x1A, 0x50, 0xE0, 0x70, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2E, 0x5D, 0x14, 0x00, 0x5E, 0x6E, 0x8B, 0xFF },
        { 0x00, 0x08, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x0B, 0x00, 0x05, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x07, 0x0F, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x8000,
        { 0x05, 0x0F, 0x00, 0x00 },
        0xA7,
        { 0x5B, 0x4F, 0x53, 0x17, 0x50, 0xBA, 0x6C, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2B, 0x5D, 0x14, 0x0F, 0x5F, 0x0A, 0x8B, 0xFF },
        { 0x00, 0x01, 0x00, 0x00, 0x04, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x04, 0x07, 0x00, 0x00, 0x01, 0x00, 0x05, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x07, 0x0F, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x8000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0xA2,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x28, 0x0F, 0x63, 0xBA, 0xE3, 0xFF },
        { 0x00, 0x08, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x0B, 0x00, 0x05, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x8000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0xA3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x28, 0x0F, 0x63, 0xBA, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x28,
        0x18,
        0x0E,
        0x0800,
        { 0x09, 0x03, 0x00, 0x02 },
        0xA3,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0xA0, 0xBF, 0x1F, 0x00, 0x4D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x14, 0x1F, 0x63, 0xBA, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x0E,
        0x0800,
        { 0x09, 0x03, 0x00, 0x02 },
        0xA3,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0xA0, 0xBF, 0x1F, 0x00, 0x4D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x14, 0x1F, 0x63, 0xBA, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x1000,
        { 0x01, 0x03, 0x00, 0x02 },
        0xA3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x4D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x28, 0x1F, 0x63, 0xBA, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x1000,
        { 0x01, 0x03, 0x00, 0x02 },
        0xA3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x4D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x28, 0x1F, 0x63, 0xBA, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x10,
        0x0800,
        { 0x08, 0x03, 0x00, 0x02 },
        0x67,
        { 0x2D, 0x27, 0x28, 0x90, 0x2B, 0xA0, 0xBF, 0x1F, 0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x08 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x10,
        0x1000,
        { 0x00, 0x03, 0x00, 0x02 },
        0x67,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x08 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x10,
        0x1000,
        { 0x00, 0x03, 0x00, 0x02 },
        0x66,
        { 0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x0F, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x0F, 0x08 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0A, 0x00, 0xFF }
    },
    {
        0x50,
        0x1D,
        0x10,
        0xA000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0xE3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C, 0xDF, 0x28, 0x00, 0xE7, 0x04, 0xC3, 0xFF },
        { 0x00, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01, 0xFF }
    },
    {
        0x50,
        0x1D,
        0x10,
        0xA000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0xE3,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C, 0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x2000,
        { 0x01, 0x0F, 0x00, 0x0E },
        0x63,
        { 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x40, 0x96, 0xB9, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x0800,
        { 0x0B, 0x03, 0x00, 0x03 },
        0x23,
        { 0x37, 0x27, 0x2D, 0x37, 0x31, 0x15, 0x04, 0x11, 0x00, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x14, 0x08, 0xE0, 0xF0, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x0800,
        { 0x0B, 0x03, 0x00, 0x03 },
        0x23,
        { 0x37, 0x27, 0x2D, 0x37, 0x31, 0x15, 0x04, 0x11, 0x00, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x14, 0x08, 0xE0, 0xF0, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x1000,
        { 0x01, 0x03, 0x00, 0x03 },
        0x23,
        { 0x70, 0x4F, 0x5C, 0x2F, 0x5F, 0x07, 0x04, 0x11, 0x00, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x28, 0x08, 0xE0, 0xF0, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x1000,
        { 0x01, 0x03, 0x00, 0x03 },
        0x23,
        { 0x70, 0x4F, 0x5C, 0x2F, 0x5F, 0x07, 0x04, 0x11, 0x00, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x28, 0x08, 0xE0, 0xF0, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x4000,
        { 0x0B, 0x03, 0x00, 0x02 },
        0x23,
        { 0x37, 0x27, 0x2D, 0x37, 0x30, 0x14, 0x04, 0x11, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x14, 0x00, 0xE0, 0xF0, 0xA2, 0xFF },
        { 0x00, 0x13, 0x15, 0x17, 0x02, 0x04, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x03, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0F, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x4000,
        { 0x0B, 0x03, 0x00, 0x02 },
        0x23,
        { 0x37, 0x27, 0x2D, 0x37, 0x30, 0x14, 0x04, 0x11, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x14, 0x00, 0xE0, 0xF0, 0xA2, 0xFF },
        { 0x00, 0x13, 0x15, 0x17, 0x02, 0x04, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x03, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0F, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x4000,
        { 0x01, 0x01, 0x00, 0x06 },
        0x23,
        { 0x70, 0x4F, 0x59, 0x2D, 0x5E, 0x06, 0x04, 0x11, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x23, 0xC7, 0x28, 0x00, 0xDF, 0xEF, 0xC2, 0xFF },
        { 0x00, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x01, 0x00, 0x01, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x1000,
        { 0x00, 0x03, 0x00, 0x03 },
        0xA6,
        { 0x60, 0x4F, 0x56, 0x3A, 0x51, 0x60, 0x70, 0x1F, 0x00, 0x0D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2E, 0x5D, 0x28, 0x0D, 0x5E, 0x6E, 0xA3, 0xFF },
        { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x0F, 0x08 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0A, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x4000,
        { 0x00, 0x00, 0x00, 0x03 },
        0x23,
        { 0x37, 0x27, 0x2D, 0x37, 0x31, 0x15, 0x04, 0x11, 0x00, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x14, 0x08, 0xE0, 0xF0, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x4000,
        { 0x00, 0x00, 0x00, 0x03 },
        0x23,
        { 0x37, 0x27, 0x2D, 0x37, 0x31, 0x15, 0x04, 0x11, 0x00, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x14, 0x08, 0xE0, 0xF0, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x4000,
        { 0x00, 0x00, 0x00, 0x03 },
        0x23,
        { 0x37, 0x27, 0x2D, 0x37, 0x31, 0x15, 0x04, 0x11, 0x00, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x14, 0x08, 0xE0, 0xF0, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x1000,
        { 0x01, 0x04, 0x00, 0x07 },
        0x23,
        { 0x70, 0x4F, 0x5C, 0x2F, 0x5F, 0x07, 0x04, 0x11, 0x00, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x28, 0x08, 0xE0, 0xF0, 0xA3, 0xFF },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x1000,
        { 0x00, 0x04, 0x00, 0x07 },
        0xA6,
        { 0x60, 0x4F, 0x56, 0x3A, 0x51, 0x60, 0x70, 0x1F, 0x00, 0x0D, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2E, 0x5D, 0x28, 0x0D, 0x5E, 0x6E, 0xA3, 0xFF },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x0F, 0x08 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x08,
        0x2000,
        { 0x0B, 0x0F, 0x00, 0x06 },
        0x23,
        { 0x37, 0x27, 0x2D, 0x37, 0x30, 0x14, 0x04, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x24, 0xC7, 0x14, 0x00, 0xE0, 0xF0, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x50,
        0x18,
        0x08,
        0x4000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0x23,
        { 0x70, 0x4F, 0x59, 0x2D, 0x5E, 0x06, 0x04, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x23, 0xC7, 0x28, 0x00, 0xDF, 0xEF, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x8000,
        { 0x05, 0x0F, 0x00, 0x00 },
        0xA2,
        { 0x60, 0x4F, 0x56, 0x1A, 0x50, 0xE0, 0x70, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2E, 0x5D, 0x14, 0x0D, 0x5E, 0x6E, 0x8B, 0xFF },
        { 0x00, 0x08, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x0B, 0x00, 0x05, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x07, 0x0F, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x8000,
        { 0x05, 0x0F, 0x00, 0x00 },
        0xA7,
        { 0x5B, 0x4F, 0x53, 0x17, 0x50, 0xBA, 0x6C, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2B, 0x5D, 0x14, 0x0F, 0x5F, 0x0A, 0x8B, 0xFF },
        { 0x00, 0x01, 0x00, 0x00, 0x04, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x04, 0x07, 0x00, 0x00, 0x01, 0x00, 0x05, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x07, 0x0F, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x8000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0xA2,
        { 0x60, 0x4F, 0x56, 0x3A, 0x50, 0x60, 0x70, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2E, 0x5D, 0x28, 0x0D, 0x5E, 0x6E, 0xE3, 0xFF },
        { 0x00, 0x08, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x0B, 0x00, 0x05, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x8000,
        { 0x01, 0x0F, 0x00, 0x06 },
        0xA7,
        { 0x5B, 0x4F, 0x53, 0x37, 0x52, 0x00, 0x6C, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2B, 0x5D, 0x28, 0x0F, 0x5F, 0x0A, 0xE3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF }
    },
    {
        0x28,
        0x18,
        0x0E,
        0x0800,
        { 0x0B, 0x03, 0x00, 0x03 },
        0xA7,
        { 0x2D, 0x27, 0x2B, 0x2D, 0x28, 0x6D, 0x6C, 0x1F, 0x00, 0x0D, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2B, 0x5D, 0x14, 0x0F, 0x5E, 0x0A, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x28,
        0x18,
        0x0E,
        0x0800,
        { 0x0B, 0x03, 0x00, 0x03 },
        0xA7,
        { 0x2D, 0x27, 0x2B, 0x2D, 0x28, 0x6D, 0x6C, 0x1F, 0x00, 0x0D, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2B, 0x5D, 0x14, 0x0F, 0x5E, 0x0A, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x1000,
        { 0x01, 0x03, 0x00, 0x03 },
        0xA7,
        { 0x5B, 0x4F, 0x53, 0x37, 0x51, 0x5B, 0x6C, 0x1F, 0x00, 0x0D, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2B, 0x5D, 0x28, 0x0F, 0x5E, 0x0A, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    },
    {
        0x50,
        0x18,
        0x0E,
        0x1000,
        { 0x01, 0x03, 0x00, 0x03 },
        0xA7,
        { 0x5B, 0x4F, 0x53, 0x37, 0x51, 0x5B, 0x6C, 0x1F, 0x00, 0x0D, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x2B, 0x5D, 0x28, 0x0F, 0x5E, 0x0A, 0xA3, 0xFF },
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x08, 0x00, 0x0F, 0x00 },
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF }
    }
};

PaletteData Data0x32f2 = 
{
    Hag::System::BDA::VideoDisplayDataArea::GrayScale | Hag::System::BDA::VideoDisplayDataArea::MonochromeMonitor,
    0x00,
    0x0040,
    {
        0x00, 0x02, 0x08, 0x0A, 0x20, 0x22, 0x28, 0x2A, 0x01, 0x03, 0x09, 0x0B, 0x21, 0x23, 0x29, 0x2B,
        0x04, 0x06, 0x0C, 0x0E, 0x24, 0x26, 0x2C, 0x2E, 0x05, 0x07, 0x0D, 0x0F, 0x25, 0x27, 0x2D, 0x2F,
        0x10, 0x12, 0x18, 0x1A, 0x30, 0x32, 0x38, 0x3A, 0x11, 0x13, 0x19, 0x1B, 0x31, 0x33, 0x39, 0x3B,
        0x14, 0x16, 0x1C, 0x1E, 0x34, 0x36, 0x3C, 0x3E, 0x15, 0x17, 0x1D, 0x1F, 0x35, 0x37, 0x3D, 0x3F
    }
};

PaletteData Data0x3236 =
{
    0x00,
    0x80,
    0x0040,
    {
        0x00, 0x05, 0x11, 0x1C, 0x08, 0x0B, 0x25, 0x28, 0x02, 0x07, 0x1B, 0x20, 0x0F, 0x14, 0x28, 0x2C,
        0x0C, 0x11, 0x25, 0x2A, 0x14, 0x1E, 0x32, 0x36, 0x0F, 0x13, 0x27, 0x2C, 0x1B, 0x20, 0x34, 0x39,
        0x06, 0x0B, 0x1F, 0x24, 0x13, 0x18, 0x2C, 0x30, 0x09, 0x0D, 0x21, 0x26, 0x15, 0x1A, 0x2E, 0x33,
        0x13, 0x17, 0x2B, 0x30, 0x1F, 0x24, 0x38, 0x3D, 0x0E, 0x18, 0x2D, 0x32, 0x20, 0x24, 0x38, 0x3F
    }
};

PaletteData Data0x337a =
{
    Hag::System::BDA::VideoDisplayDataArea::GrayScale | Hag::System::BDA::VideoDisplayDataArea::MonochromeMonitor,
    0x00,
    0x0040,
    {
        0x00, 0x02, 0x08, 0x0A, 0x20, 0x22, 0x24, 0x2A, 0x00, 0x02, 0x08, 0x0A, 0x20, 0x22, 0x24, 0x2A,
        0x15, 0x17, 0x1D, 0x1F, 0x35, 0x37, 0x3D, 0x3F, 0x15, 0x17, 0x1D, 0x1F, 0x35, 0x37, 0x3D, 0x3F,
        0x00, 0x02, 0x08, 0x0A, 0x20, 0x22, 0x24, 0x2A, 0x00, 0x02, 0x08, 0x0A, 0x20, 0x22, 0x24, 0x2A,
        0x15, 0x17, 0x1D, 0x1F, 0x35, 0x37, 0x3D, 0x3F, 0x15, 0x17, 0x1D, 0x1F, 0x35, 0x37, 0x3D, 0x3F
    }
};

PaletteData Data0x32be =
{
    0x00,
    0x80,
    0x0040,
    {
        0x00, 0x05, 0x11, 0x1C, 0x08, 0x0B, 0x14, 0x28, 0x00, 0x05, 0x11, 0x1C, 0x08, 0x0B, 0x14, 0x28,
        0x0E, 0x18, 0x2D, 0x32, 0x20, 0x24, 0x38, 0x3F, 0x0E, 0x18, 0x2D, 0x32, 0x20, 0x24, 0x38, 0x3F,
        0x00, 0x05, 0x11, 0x1C, 0x08, 0x0B, 0x14, 0x28, 0x00, 0x05, 0x11, 0x1C, 0x08, 0x0B, 0x14, 0x28,
        0x0E, 0x18, 0x2D, 0x32, 0x20, 0x24, 0x38, 0x3F, 0x0E, 0x18, 0x2D, 0x32, 0x20, 0x24, 0x38, 0x3F
    }
};

PaletteData Data0x3402 =
{
    0x00,
    0x00,
    0x0040,
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
        0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
        0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F
    }
};

PaletteData Data0x3446 =
{
    Hag::System::BDA::VideoDisplayDataArea::GrayScale | Hag::System::BDA::VideoDisplayDataArea::MonochromeMonitor,
    0x00,
    0x0010,
    {
        0x00, 0x02, 0x08, 0x0A, 0x20, 0x22, 0x24, 0x2A, 0x15, 0x17, 0x1D, 0x1F, 0x35, 0x37, 0x3D, 0x3F
    }
};

PaletteData Data0x345a =
{
    0x00,
    0x80,
    0x0010,
    {
        0x00, 0x05, 0x11, 0x1C, 0x08, 0x0B, 0x14, 0x28, 0x0E, 0x18, 0x2D, 0x32, 0x20, 0x24, 0x38, 0x3F
    }
};

PaletteData Data0x346e =
{
    0x00,
    0x80,
    0x0010,
    {
        0x00, 0x05, 0x08, 0x0B, 0x0E, 0x11, 0x14, 0x18, 0x1C, 0x20, 0x24, 0x28, 0x2D, 0x32, 0x38, 0x3F
    }
};

PaletteData Data0x3482 =
{
    0x00,
    0x40,
    0x00D8,
    {
        0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F, 0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00, 0x3F, 0x3F,
        0x00, 0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F,
        0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00, 0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x00,
        0x00, 0x3F, 0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F, 0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00,
        0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F, 0x2F, 0x1F,
        0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x1F, 0x37, 0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27,
        0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F, 0x2F, 0x1F, 0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x37,
        0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27, 0x3F, 0x1F, 0x1F, 0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F,
        0x2F, 0x1F, 0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x37, 0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27, 0x3F,
        0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36, 0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D, 0x3F, 0x3F,
        0x2D, 0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36,
        0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D, 0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x2D,
        0x2D, 0x3F, 0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36, 0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D,
        0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C, 0x0E, 0x00,
        0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x1C, 0x1C, 0x00, 0x15, 0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07,
        0x1C, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C, 0x0E, 0x00, 0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x15,
        0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07, 0x1C, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C,
        0x0E, 0x00, 0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x15, 0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07, 0x1C,
        0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15, 0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E, 0x1C, 0x1C,
        0x0E, 0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15,
        0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E, 0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x0E,
        0x0E, 0x1C, 0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15, 0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E,
        0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C, 0x18, 0x14,
        0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1C, 0x1C, 0x14, 0x1A, 0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16,
        0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C, 0x18, 0x14, 0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1A,
        0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16, 0x1C, 0x14, 0x14, 0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C,
        0x18, 0x14, 0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1A, 0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16, 0x1C,
        0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10,
        0x00, 0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08,
        0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00, 0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00,
        0x00, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00,
        0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10, 0x0C, 0x08,
        0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x10, 0x10, 0x08, 0x0E, 0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A,
        0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10, 0x0C, 0x08, 0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x0E,
        0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A, 0x10, 0x08, 0x08, 0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10,
        0x0C, 0x08, 0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x0E, 0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A, 0x10,
        0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D, 0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B, 0x10, 0x10,
        0x0B, 0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D,
        0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B, 0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x0B,
        0x0B, 0x10, 0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D, 0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B,
        0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10
    }
};

PaletteData* Palettes[] =
{
    &Data0x32f2,         // 0
    &Data0x3236,         // 1
    &Data0x337a,         // 2
    &Data0x32be,         // 3
    &Data0x3402,         // 4
    &Data0x3446,         // 5
    &Data0x345a,         // 6
    &Data0x346e,         // 7
    &Data0x3482          // 8
};

uint8_t Font8x8[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E,
    0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E, 0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00,
    0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x38, 0x7C, 0x38, 0xFE, 0xFE, 0x7C, 0x38, 0x7C,
    0x10, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x7C, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00,
    0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF, 0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00,
    0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF, 0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78,
    0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0,
    0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0, 0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99,
    0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00, 0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00,
    0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
    0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00, 0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0xCC, 0x78,
    0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,
    0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,
    0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00,
    0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
    0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
    0x30, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x30, 0x00, 0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,
    0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00, 0x60, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
    0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00, 0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00,
    0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00, 0x78, 0xCC, 0x0C, 0x38, 0x0C, 0xCC, 0x78, 0x00,
    0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00, 0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
    0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00, 0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
    0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00,
    0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
    0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0xFC, 0x00, 0x00,
    0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x78, 0xCC, 0x0C, 0x18, 0x30, 0x00, 0x30, 0x00,
    0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00, 0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00,
    0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00, 0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00,
    0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00,
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00, 0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00,
    0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, 0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00,
    0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
    0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
    0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0xDC, 0x78, 0x1C, 0x00,
    0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00, 0x78, 0xCC, 0xE0, 0x70, 0x1C, 0xCC, 0x78, 0x00,
    0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFC, 0x00,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, 0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00,
    0xC6, 0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00,
    0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
    0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
    0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00,
    0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
    0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
    0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00, 0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x0C, 0x00, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00,
    0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xC6, 0x00,
    0x00, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
    0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E,
    0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x00,
    0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
    0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, 0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00,
    0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
    0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00, 0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00,
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00, 0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00,
    0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00,
    0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x18, 0x0C, 0x78, 0x00, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00,
    0x1C, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 0x7E, 0xC3, 0x3C, 0x06, 0x3E, 0x66, 0x3F, 0x00,
    0xCC, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00, 0xE0, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00,
    0x30, 0x30, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00, 0x00, 0x00, 0x78, 0xC0, 0xC0, 0x78, 0x0C, 0x38,
    0x7E, 0xC3, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00, 0xCC, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
    0xE0, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 0xCC, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x7C, 0xC6, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00, 0xE0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
    0xC6, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0x00, 0x30, 0x30, 0x00, 0x78, 0xCC, 0xFC, 0xCC, 0x00,
    0x1C, 0x00, 0xFC, 0x60, 0x78, 0x60, 0xFC, 0x00, 0x00, 0x00, 0x7F, 0x0C, 0x7F, 0xCC, 0x7F, 0x00,
    0x3E, 0x6C, 0xCC, 0xFE, 0xCC, 0xCC, 0xCE, 0x00, 0x78, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
    0x00, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0xE0, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
    0x78, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00, 0x00, 0xE0, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00,
    0x00, 0xCC, 0x00, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, 0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00,
    0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x18, 0x18, 0x7E, 0xC0, 0xC0, 0x7E, 0x18, 0x18,
    0x38, 0x6C, 0x64, 0xF0, 0x60, 0xE6, 0xFC, 0x00, 0xCC, 0xCC, 0x78, 0xFC, 0x30, 0xFC, 0x30, 0x30,
    0xF8, 0xCC, 0xCC, 0xFA, 0xC6, 0xCF, 0xC6, 0xC7, 0x0E, 0x1B, 0x18, 0x3C, 0x18, 0x18, 0xD8, 0x70,
    0x1C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00, 0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x00, 0x1C, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x1C, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00,
    0x00, 0xF8, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0x00, 0xFC, 0x00, 0xCC, 0xEC, 0xFC, 0xDC, 0xCC, 0x00,
    0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00,
    0x30, 0x00, 0x30, 0x60, 0xC0, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xC0, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFC, 0x0C, 0x0C, 0x00, 0x00, 0xC3, 0xC6, 0xCC, 0xDE, 0x33, 0x66, 0xCC, 0x0F,
    0xC3, 0xC6, 0xCC, 0xDB, 0x37, 0x6F, 0xCF, 0x03, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00,
    0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00, 0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00,
    0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
    0xDB, 0x77, 0xDB, 0xEE, 0xDB, 0x77, 0xDB, 0xEE, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36,
    0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36,
    0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00,
    0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36,
    0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
    0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36,
    0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xDC, 0xC8, 0xDC, 0x76, 0x00, 0x00, 0x78, 0xCC, 0xF8, 0xCC, 0xF8, 0xC0, 0xC0,
    0x00, 0xFC, 0xCC, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00,
    0xFC, 0xCC, 0x60, 0x30, 0x60, 0xCC, 0xFC, 0x00, 0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0x70, 0x00,
    0x00, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0xC0, 0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x00,
    0xFC, 0x30, 0x78, 0xCC, 0xCC, 0x78, 0x30, 0xFC, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x6C, 0x38, 0x00,
    0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x6C, 0xEE, 0x00, 0x1C, 0x30, 0x18, 0x7C, 0xCC, 0xCC, 0x78, 0x00,
    0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00, 0x06, 0x0C, 0x7E, 0xDB, 0xDB, 0x7E, 0x60, 0xC0,
    0x38, 0x60, 0xC0, 0xF8, 0xC0, 0x60, 0x38, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00,
    0x00, 0xFC, 0x00, 0xFC, 0x00, 0xFC, 0x00, 0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0xFC, 0x00,
    0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xFC, 0x00, 0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xFC, 0x00,
    0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0x70,
    0x30, 0x30, 0x00, 0xFC, 0x00, 0x30, 0x30, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00,
    0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x0F, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x3C, 0x1C,
    0x78, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

uint8_t* GraphicsFont8x8 = Font8x8 + 64 * 16;

uint8_t Font8x16[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0x81, 0xBD, 0x99, 0x81, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0xFF, 0xDB, 0xFF, 0xFF, 0xC3, 0xE7, 0xFF, 0xFF, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0xE7, 0xE7, 0xE7, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x1E, 0x0E, 0x1A, 0x32, 0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3F, 0x33, 0x3F, 0x30, 0x30, 0x30, 0x30, 0x70, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0x63, 0x7F, 0x63, 0x63, 0x63, 0x63, 0x67, 0xE7, 0xE6, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x18, 0xDB, 0x3C, 0xE7, 0x3C, 0xDB, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFE, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x06, 0x0E, 0x1E, 0x3E, 0xFE, 0x3E, 0x1E, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0xDB, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x7C, 0xC6, 0x60, 0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x6C, 0xFE, 0x6C, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7C, 0x7C, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x7C, 0x7C, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06, 0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xD6, 0xD6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38, 0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38, 0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x0C, 0x06, 0x7C, 0x00, 0x00,
    0x00, 0x00, 0xCC, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x18, 0x30, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xCC, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x38, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x66, 0x3C, 0x0C, 0x06, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x3C, 0x66, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC6, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x38, 0x6C, 0x38, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x30, 0x60, 0x00, 0xFE, 0x66, 0x60, 0x7C, 0x60, 0x60, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x76, 0x36, 0x7E, 0xD8, 0xD8, 0x6E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3E, 0x6C, 0xCC, 0xCC, 0xFE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x78, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00,
    0x00, 0xC6, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC6, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xE6, 0xFC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xF8, 0xCC, 0xCC, 0xF8, 0xC4, 0xCC, 0xDE, 0xCC, 0xCC, 0xCC, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0E, 0x1B, 0x18, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0x70, 0x00, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x18, 0x30, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xDC, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x76, 0xDC, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0xC0, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30, 0x60, 0xDC, 0x86, 0x0C, 0x18, 0x3E, 0x00, 0x00,
    0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xCE, 0x9E, 0x3E, 0x06, 0x06, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x6C, 0xD8, 0x6C, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x6C, 0x36, 0x6C, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,
    0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
    0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0xD8, 0xD8, 0xD8, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0xD8, 0xCC, 0xC6, 0xC6, 0xC6, 0xCC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0xC6, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0xC6, 0x60, 0x30, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7E, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x6C, 0x6C, 0x6C, 0xEE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1E, 0x30, 0x18, 0x0C, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xDB, 0xDB, 0xDB, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03, 0x06, 0x7E, 0xDB, 0xDB, 0xF3, 0x7E, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1C, 0x30, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x30, 0x1C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x6C, 0x3C, 0x1C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xD8, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x70, 0xD8, 0x30, 0x60, 0xC8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};